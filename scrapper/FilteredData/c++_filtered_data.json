[
  {
    "url": "https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean",
    "body": "struct Foo {\n    // Single parameter constructor, can be used as an implicit conversion.\n    // Such a constructor is called \"converting constructor\".\n    Foo(int x) {}\n};\nstruct Faz {\n    // Also a converting constructor.\n    Faz(Foo foo) {}\n};\n// The parameter is of type Foo, not of type int, so it looks like\n// we have to pass a Foo.\nvoid bar(Foo foo) {};\nint main() {\n    // However, the converting constructor allows us to pass an int.\n    bar(42);\n    // Also allowed thanks to the converting constructor.\n    Foo foo = 42;\n    // Error! This would require two conversions (int -> Foo -> Faz).\n    Faz faz = 42;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/375913/how-do-i-profile-c-code-running-on-linux",
    "body": "Prior\nP(f=x) x  P(o=2/2|f=x) P(o=2/2&&f=x)  P(o=2/2&&f >= x)  P(f >= x | o=2/2)\n0.1    1     1             0.1          0.1            0.25974026\n0.1    0.9   0.81          0.081        0.181          0.47012987\n0.1    0.8   0.64          0.064        0.245          0.636363636\n0.1    0.7   0.49          0.049        0.294          0.763636364\n0.1    0.6   0.36          0.036        0.33           0.857142857\n0.1    0.5   0.25          0.025        0.355          0.922077922\n0.1    0.4   0.16          0.016        0.371          0.963636364\n0.1    0.3   0.09          0.009        0.38           0.987012987\n0.1    0.2   0.04          0.004        0.384          0.997402597\n0.1    0.1   0.01          0.001        0.385          1\n                  P(o=2/2) 0.385"
  },
  {
    "url": "https://stackoverflow.com/questions/375913/how-do-i-profile-c-code-running-on-linux",
    "body": "Prior\nP(f=x) x  P(o=2/2|f=x) P(o=2/2&& f=x)  P(o=2/2&&f >= x)  P(f >= x | o=2/2)\n0.001  1    1              0.001        0.001          0.072727273\n0.001  0.9  0.81           0.00081      0.00181        0.131636364\n0.001  0.8  0.64           0.00064      0.00245        0.178181818\n0.001  0.7  0.49           0.00049      0.00294        0.213818182\n0.001  0.6  0.36           0.00036      0.0033         0.24\n0.001  0.5  0.25           0.00025      0.00355        0.258181818\n0.001  0.4  0.16           0.00016      0.00371        0.269818182\n0.001  0.3  0.09           0.00009      0.0038         0.276363636\n0.001  0.2  0.04           0.00004      0.00384        0.279272727\n0.991  0.1  0.01           0.00991      0.01375        1\n                  P(o=2/2) 0.01375"
  },
  {
    "url": "https://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files",
    "body": "# Minimal makefile for prog1\nPROGRAM = prog1\nFILES.c = prog1.c file1.c file2.c\nFILES.h = prog1.h file3.h\nFILES.o = ${FILES.c:.c=.o}\nCC      = gcc\nSFLAGS  = -std=c11\nGFLAGS  = -g\nOFLAGS  = -O3\nWFLAG1  = -Wall\nWFLAG2  = -Wextra\nWFLAG3  = -Werror\nWFLAG4  = -Wstrict-prototypes\nWFLAG5  = -Wmissing-prototypes\nWFLAGS  = ${WFLAG1} ${WFLAG2} ${WFLAG3} ${WFLAG4} ${WFLAG5}\nUFLAGS  = # Set on command line only\nCFLAGS  = ${SFLAGS} ${GFLAGS} ${OFLAGS} ${WFLAGS} ${UFLAGS}\nLDFLAGS =\nLDLIBS  =\nall:    ${PROGRAM}\n${PROGRAM}: ${FILES.o}\n    ${CC} -o $@ ${CFLAGS} ${FILES.o} ${LDFLAGS} ${LDLIBS}\nprog1.o: ${FILES.h}\nfile1.o: ${FILES.h}\nfile2.o: ${FILES.h}\n# If it exists, prog1.dSYM is a directory on macOS\nDEBRIS = a.out core *~ *.dSYM\nRM_FR  = rm -fr\nclean:\n    ${RM_FR} ${FILES.o} ${PROGRAM} ${DEBRIS}"
  },
  {
    "url": "https://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files",
    "body": "/* Standard prologue */\n#if defined(DEFINE_VARIABLES) && !defined(FILE2C_H_DEFINITIONS)\n#undef FILE2C_H_INCLUDED\n#endif\n#ifndef FILE2C_H_INCLUDED\n#define FILE2C_H_INCLUDED\n#include \"external.h\"   /* Support macros EXTERN, INITIALIZE */\n#include \"file1c.h\"     /* Type definition for struct oddball */\n#if !defined(DEFINE_VARIABLES) || !defined(FILE2C_H_DEFINITIONS)\n/* Global variable declarations / definitions */\nEXTERN int global_variable INITIALIZE(37);\nEXTERN struct oddball oddball_struct INITIALIZE({ 41, 43 });\n#endif /* !DEFINE_VARIABLES || !FILE2C_H_DEFINITIONS */\n/* Standard epilogue */\n#ifdef DEFINE_VARIABLES\n#define FILE2C_H_DEFINITIONS\n#endif /* DEFINE_VARIABLES */\n#endif /* FILE2C_H_INCLUDED */"
  },
  {
    "url": "https://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files",
    "body": "/* Standard prologue */\n#if defined(DEFINE_VARIABLES) && !defined(FILE2D_H_DEFINITIONS)\n#undef FILE2D_H_INCLUDED\n#endif\n#ifndef FILE2D_H_INCLUDED\n#define FILE2D_H_INCLUDED\n#include \"external.h\"   /* Support macros EXTERN, INITIALIZE */\n#include \"file1c.h\"     /* Type definition for struct oddball */\n#if !defined(DEFINE_VARIABLES) || !defined(FILE2D_H_DEFINITIONS)\n/* Global variable declarations / definitions */\nEXTERN int global_variable INITIALIZE(37);\nEXTERN struct oddball oddball_struct INITIALIZE({ 41, 43 });\n#endif /* !DEFINE_VARIABLES || !FILE2D_H_DEFINITIONS */\n/* Standard epilogue */\n#ifdef DEFINE_VARIABLES\n#define FILE2D_H_DEFINITIONS\n#undef DEFINE_VARIABLES\n#endif /* DEFINE_VARIABLES */\n#endif /* FILE2D_H_INCLUDED */"
  },
  {
    "url": "https://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files",
    "body": "/*\n** This header must not contain header guards (like <assert.h> must not).\n** Each time it is included, the macro HEADER_DEFINING_VARIABLES should\n** be defined with the name (in quotes - or possibly angle brackets) of\n** the header to be included that defines variables when the macro\n** DEFINE_VARIABLES is defined.  See also: external.h (which uses\n** DEFINE_VARIABLES and defines macros EXTERN and INITIALIZE\n** appropriately).\n**\n** #define HEADER_DEFINING_VARIABLES \"file2c.h\"\n** #include \"externdef.h\"\n*/\n#if defined(HEADER_DEFINING_VARIABLES)\n#define DEFINE_VARIABLES\n#include HEADER_DEFINING_VARIABLES\n#undef DEFINE_VARIABLES\n#undef HEADER_DEFINING_VARIABLES\n#endif /* HEADER_DEFINING_VARIABLES */"
  },
  {
    "url": "https://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files",
    "body": "/* Standard prologue */\n#if defined(DEFINE_VARIABLES) && !defined(FILE8C_H_DEFINITIONS)\n#undef FILE8C_H_INCLUDED\n#endif\n#ifndef FILE8C_H_INCLUDED\n#define FILE8C_H_INCLUDED\n#include \"external.h\"   /* Support macros EXTERN, INITIALIZE */\n#include \"file2d.h\"     /* struct oddball */\n#if !defined(DEFINE_VARIABLES) || !defined(FILE8C_H_DEFINITIONS)\n/* Global variable declarations / definitions */\nEXTERN struct oddball another INITIALIZE({ 14, 34 });\n#endif /* !DEFINE_VARIABLES || !FILE8C_H_DEFINITIONS */\n/* Standard epilogue */\n#ifdef DEFINE_VARIABLES\n#define FILE8C_H_DEFINITIONS\n#endif /* DEFINE_VARIABLES */\n#endif /* FILE8C_H_INCLUDED */"
  },
  {
    "url": "https://stackoverflow.com/questions/40354978/why-does-c-code-for-testing-the-collatz-conjecture-run-faster-than-hand-writte",
    "body": "# starting with YMM0 = [ n_d, n_c, n_b, n_a ]  (64-bit elements)\n# ymm4 = _mm256_set1_epi64x(1):  increment vector\n# ymm5 = all-zeros:  count vector\n.inner_loop:\n  vpaddq    ymm1, ymm0, xmm0\n  vpaddq    ymm1, ymm1, xmm0\n  vpaddq    ymm1, ymm1, set1_epi64(1)     # ymm1= 3*n + 1.  Maybe could do this more efficiently?\n  vpsllq    ymm3, ymm0, 63                # shift bit 1 to the sign bit\n  vpsrlq    ymm0, ymm0, 1                 # n /= 2\n  # FP blend between integer insns may cost extra bypass latency, but integer blends don't have 1 bit controlling a whole qword.\n  vpblendvpd ymm0, ymm0, ymm1, ymm3       # variable blend controlled by the sign bit of each 64-bit element.  I might have the source operands backwards, I always have to look this up.\n  # ymm0 = updated n  in each element.\n  vpcmpeqq ymm1, ymm0, set1_epi64(1)\n  vpandn   ymm4, ymm1, ymm4         # zero out elements of ymm4 where the compare was true\n  vpaddq   ymm5, ymm5, ymm4         # count++ in elements where n has never been == 1\n  vptest   ymm4, ymm4\n  jnz  .inner_loop\n  # Fall through when all the n values have reached 1 at some point, and our increment vector is all-zero\n  vextracti128 ymm0, ymm5, 1\n  vpmaxuq .... oops, requires AVX-512\n  # delay doing a horizontal max until the very end.  But you need some way to record max and maxi."
  },
  {
    "url": "https://stackoverflow.com/questions/402283/stdwstring-vs-stdstring",
    "body": "#include <cstring>\n#include <iostream>\nint main()\n{\n\tconst char text[] = \"olé\";\n\tstd::cout << \"sizeof(char)    : \" << sizeof(char) << \"\\n\";\n\tstd::cout << \"text            : \" << text << \"\\n\";\n\tstd::cout << \"sizeof(text)    : \" << sizeof(text) << \"\\n\";\n\tstd::cout << \"strlen(text)    : \" << strlen(text) << \"\\n\";\n\tstd::cout << \"text(ordinals)  :\";\n\tfor(size_t i = 0, iMax = strlen(text); i < iMax; ++i)\n\t{\n\t\tunsigned char c = static_cast<unsigned_char>(text[i]);\n\t\tstd::cout << \" \" << static_cast<unsigned int>(c);\n\t}\n\tstd::cout << \"\\n\\n\";\n\t// - - -\n\tconst wchar_t wtext[] = L\"olé\" ;\n\tstd::cout << \"sizeof(wchar_t) : \" << sizeof(wchar_t) << \"\\n\";\n\t//std::cout << \"wtext           : \" << wtext << \"\\n\"; <- error\n\tstd::cout << \"wtext           : UNABLE TO CONVERT NATIVELY.\" << \"\\n\";\n\tstd::wcout << L\"wtext           : \" << wtext << \"\\n\";\n\tstd::cout << \"sizeof(wtext)   : \" << sizeof(wtext) << \"\\n\";\n\tstd::cout << \"wcslen(wtext)   : \" << wcslen(wtext) << \"\\n\";\n\tstd::cout << \"wtext(ordinals) :\";\n\tfor(size_t i = 0, iMax = wcslen(wtext); i < iMax; ++i)\n\t{\n\t\tunsigned short wc = static_cast<unsigned short>(wtext[i]);\n\t\tstd::cout << \" \" << static_cast<unsigned int>(wc);\n\t}\n\tstd::cout << \"\\n\\n\";\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/1711990/what-is-this-weird-colon-member-syntax-in-the-constructor",
    "body": "c++\nclass MyClass {\npublic:\n  // Reference member, has to be Initialized in Member Initializer List\n  int &i;\n  int b;\n  // Non static const member, must be Initialized in Member Initializer List\n  const int k;\n  // Constructor’s parameter name b is same as class data member\n  // Other way is to use this->b to refer to data member\n  MyClass(int a, int b, int c) : i(a), b(b), k(c) {\n    // Without Member Initializer\n    // this->b = b;\n  }\n};\nclass MyClass2 : public MyClass {\npublic:\n  int p;\n  int q;\n  MyClass2(int x, int y, int z, int l, int m) : MyClass(x, y, z), p(l), q(m) {}\n};\nint main() {\n  int x = 10;\n  int y = 20;\n  int z = 30;\n  MyClass obj(x, y, z);\n  int l = 40;\n  int m = 50;\n  MyClass2 obj2(x, y, z, l, m);\n  return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/2808398/easily-measure-elapsed-time",
    "body": "template <class DT = std::chrono::milliseconds,\n          class ClockT = std::chrono::steady_clock>\nclass Timer\n{\n    using timep_t = typename ClockT::time_point;\n    timep_t _start = ClockT::now(), _end = {};\npublic:\n    void tick() {\n        _end = timep_t{};\n        _start = ClockT::now();\n    }\n\n    void tock() { _end = ClockT::now(); }\n\n    template <class T = DT>\n    auto duration() const {\n        gsl_Expects(_end != timep_t{} && \"toc before reporting\");\n        return std::chrono::duration_cast<T>(_end - _start);\n    }\n};"
  },
  {
    "url": "https://stackoverflow.com/questions/22387586/measuring-execution-time-of-a-function-in-c",
    "body": "#include <chrono>\n/* Only needed for the sake of this example. */\n#include <iostream>\n#include <thread>\n\nvoid long_operation()\n{\n    /* Simulating a long, heavy operation. */\n    using namespace std::chrono_literals;\n    std::this_thread::sleep_for(150ms);\n}\nint main()\n{\n    using std::chrono::high_resolution_clock;\n    using std::chrono::duration_cast;\n    using std::chrono::duration;\n    using std::chrono::milliseconds;\n    auto t1 = high_resolution_clock::now();\n    long_operation();\n    auto t2 = high_resolution_clock::now();\n    /* Getting number of milliseconds as an integer. */\n    auto ms_int = duration_cast<milliseconds>(t2 - t1);\n    /* Getting number of milliseconds as a double. */\n    duration<double, std::milli> ms_double = t2 - t1;\n    std::cout << ms_int.count() << \"ms\\n\";\n    std::cout << ms_double.count() << \"ms\\n\";\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/3899870/how-to-print-a-stack-trace-whenever-a-certain-function-is-called",
    "body": "#include <execinfo.h>  // for backtrace\n#include <dlfcn.h>     // for dladdr\n#include <cxxabi.h>    // for __cxa_demangle\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <iostream>\n// This function produces a stack backtrace with demangled function & method names.\nstd::string backtrace(int skip = 1)\n{\n\tvoid *callstack[128];\n\tconst int nMaxFrames = sizeof(callstack) / sizeof(callstack[0]);\n\tchar buf[1024];\n\tint nFrames = backtrace(callstack, nMaxFrames);\n\tchar **symbols = backtrace_symbols(callstack, nFrames);\n\tstd::ostringstream trace_buf;\n\tfor (int i = skip; i < nFrames; i++) {\n\t\tDl_info info;\n\t\tif (dladdr(callstack[i], &info)) {\n\t\t\tchar *demangled = NULL;\n\t\t\tint status;\n\t\t\tdemangled = abi::__cxa_demangle(info.dli_sname, NULL, 0, &status);\n            std::snprintf(\n\t\t\t    buf,\n\t\t\t    sizeof(buf),\n\t\t\t    \"%-3d %*p %s + %zd\\n\",\n                i,\n                (int)(2 + sizeof(void*) * 2),\n                callstack[i],\n                status == 0 ? demangled : info.dli_sname,\n                (char *)callstack[i] - (char *)info.dli_saddr\n            );\n\t\t\tfree(demangled);\n\t\t} else {\n            std::snprintf(buf, sizeof(buf), \"%-3d %*p\\n\",\n                i, (int)(2 + sizeof(void*) * 2), callstack[i]);\n\t\t}\n\t\ttrace_buf << buf;\n        std::snprintf(buf, sizeof(buf), \"%s\\n\", symbols[i]);\n\t\ttrace_buf << buf;\n\t}\n\tfree(symbols);\n\tif (nFrames == nMaxFrames)\n\t\ttrace_buf << \"[truncated]\\n\";\n\treturn trace_buf.str();\n}\nvoid my_func_2(void) {\n    std::cout << backtrace() << std::endl;\n}\nvoid my_func_1(double f) {\n    (void)f;\n    my_func_2();\n}\nvoid my_func_1(int i) {\n    (void)i;\n    my_func_2();\n}\nint main() {\n    my_func_1(1);\n    my_func_1(2.0);\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/3899870/how-to-print-a-stack-trace-whenever-a-certain-function-is-called",
    "body": "1             0x40130a my_func_2() + 41\n./glibc_ldl.out(_Z9my_func_2v+0x29) [0x40130a]\n2             0x40139e my_func_1(int) + 16\n./glibc_ldl.out(_Z9my_func_1i+0x10) [0x40139e]\n3             0x4013b3 main + 18\n./glibc_ldl.out(main+0x12) [0x4013b3]\n4       0x7f7594552b97 __libc_start_main + 231\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xe7) [0x7f7594552b97]\n5             0x400f3a _start + 42\n./glibc_ldl.out(_start+0x2a) [0x400f3a]\n1             0x40130a my_func_2() + 41\n./glibc_ldl.out(_Z9my_func_2v+0x29) [0x40130a]\n2             0x40138b my_func_1(double) + 18\n./glibc_ldl.out(_Z9my_func_1d+0x12) [0x40138b]\n3             0x4013c8 main + 39\n./glibc_ldl.out(main+0x27) [0x4013c8]\n4       0x7f7594552b97 __libc_start_main + 231\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xe7) [0x7f7594552b97]\n5             0x400f3a _start + 42\n./glibc_ldl.out(_start+0x2a) [0x400f3a]"
  },
  {
    "url": "https://stackoverflow.com/questions/3899870/how-to-print-a-stack-trace-whenever-a-certain-function-is-called",
    "body": "Temporary breakpoint 1 at 0x11a7: file main.cpp, line 21.\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\nTemporary breakpoint 1, main (argc=1, argv=0x7fffffffc3e8) at main.cpp:21\nwarning: Source file is more recent than executable.\n21          if (argc > 1) {\nBreakpoint 2 at 0x555555555151: file gdb/mystacktrace.h, line 1.\n#0  print_stacktrace () at gdb/mystacktrace.h:1\n#1  0x0000555555555161 in my_func_2 () at main.cpp:6\n#2  0x0000555555555191 in my_func_1 (i=1) at main.cpp:16\n#3  0x00005555555551ec in main (argc=1, argv=0x7fffffffc3e8) at main.cpp:27\n[Inferior 1 (process 165453) exited normally]"
  },
  {
    "url": "https://stackoverflow.com/questions/3899870/how-to-print-a-stack-trace-whenever-a-certain-function-is-called",
    "body": "#define UNW_LOCAL_ONLY\n#include <cxxabi.h>\n#include <libunwind.h>\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\nvoid backtrace() {\n  unw_cursor_t cursor;\n  unw_context_t context;\n  // Initialize cursor to current frame for local unwinding.\n  unw_getcontext(&context);\n  unw_init_local(&cursor, &context);\n  // Unwind frames one by one, going up the frame stack.\n  while (unw_step(&cursor) > 0) {\n    unw_word_t offset, pc;\n    unw_get_reg(&cursor, UNW_REG_IP, &pc);\n    if (pc == 0) {\n      break;\n    }\n    std::printf(\"0x%lx:\", pc);\n    char sym[256];\n    if (unw_get_proc_name(&cursor, sym, sizeof(sym), &offset) == 0) {\n      char* nameptr = sym;\n      int status;\n      char* demangled = abi::__cxa_demangle(sym, nullptr, nullptr, &status);\n      if (status == 0) {\n        nameptr = demangled;\n      }\n      std::printf(\" (%s+0x%lx)\\n\", nameptr, offset);\n      std::free(demangled);\n    } else {\n      std::printf(\" -- error: unable to obtain symbol name for this frame\\n\");\n    }\n  }\n}\nvoid my_func_2(void) {\n    backtrace();\n    std::cout << std::endl; // line 43\n}\nvoid my_func_1(double f) {\n    (void)f;\n    my_func_2();\n}\nvoid my_func_1(int i) {\n    (void)i;\n    my_func_2();\n}  // line 54\nint main() {\n    my_func_1(1);\n    my_func_1(2.0);\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/3899870/how-to-print-a-stack-trace-whenever-a-certain-function-is-called",
    "body": "0: 0x402b72 stacktrace[abi:cxx11]() at /home/ciro/test/dwfl.cpp:65\n1: 0x402cda my_func_2() at /home/ciro/test/dwfl.cpp:100\n2: 0x402d76 my_func_1(int) at /home/ciro/test/dwfl.cpp:111\n3: 0x402dd1 main at /home/ciro/test/dwfl.cpp:122\n4: 0x7ff227ea0d8f __libc_start_call_main at ../sysdeps/nptl/libc_start_call_main.h:58\n5: 0x7ff227ea0e3f __libc_start_main@@GLIBC_2.34 at ../csu/libc-start.c:392\n6: 0x402534 _start at ../csu/libc-start.c:-1\n0: 0x402b72 stacktrace[abi:cxx11]() at /home/ciro/test/dwfl.cpp:65\n1: 0x402cda my_func_2() at /home/ciro/test/dwfl.cpp:100\n2: 0x402d5f my_func_1(double) at /home/ciro/test/dwfl.cpp:106\n3: 0x402de2 main at /home/ciro/test/dwfl.cpp:123\n4: 0x7ff227ea0d8f __libc_start_call_main at ../sysdeps/nptl/libc_start_call_main.h:58\n5: 0x7ff227ea0e3f __libc_start_main@@GLIBC_2.34 at ../csu/libc-start.c:392\n6: 0x402534 _start at ../csu/libc-start.c:-1"
  },
  {
    "url": "https://stackoverflow.com/questions/15752659/thread-pooling-in-c11",
    "body": "c++\nclass ThreadPool {\npublic:\n    void Start();\n    void QueueJob(const std::function<void()>& job);\n    void Stop();\n    bool busy();\nprivate:\n    void ThreadLoop();\n    bool should_terminate = false;           // Tells threads to stop looking for jobs\n    std::mutex queue_mutex;                  // Prevents data races to the job queue\n    std::condition_variable mutex_condition; // Allows threads to wait on new jobs or termination\n    std::vector<std::thread> threads;\n    std::queue<std::function<void()>> jobs;\n};"
  },
  {
    "url": "https://stackoverflow.com/questions/5162580/what-happens-when-a-computer-program-runs",
    "body": "+---------+\n|  stack  |  function-local variables, return addresses, return values, etc.\n|         |  often grows downward, commonly accessed via \"push\" and \"pop\" (but can be\n|         |  accessed randomly, as well; disassemble a program to see)\n+---------+\n| shared  |  mapped shared libraries (C libraries, math libs, etc.)\n|  libs   |\n+---------+\n|  hole   |  unused memory allocated between the heap and stack \"chunks\", spans the\n|         |  difference between your max and min memory, minus the other totals\n+---------+\n|  heap   |  dynamic, random-access storage, allocated with 'malloc' and the like.\n+---------+\n|   bss   |  Uninitialized global variables; must be in read-write memory area\n+---------+\n|  data   |  data segment, for globals and static variables that are initialized\n|         |  (can further be split up into read-only and read-write areas, with\n|         |  read-only areas being stored elsewhere in ROM on some systems)\n+---------+\n|  text   |  program code, this is the actual executable code that is running.\n+---------+"
  },
  {
    "url": "https://stackoverflow.com/questions/5162580/what-happens-when-a-computer-program-runs",
    "body": "+-----------+ top of memory\n| extended  | above the high memory area, and up to your total memory; needed drivers to\n|           | be able to access it.\n+-----------+ 0x110000\n|  high     | just over 1MB->1MB+64KB, used by 286s and above.\n+-----------+ 0x100000\n|  upper    | upper memory area, from 640kb->1MB, had mapped memory for video devices, the\n|           | DOS \"transient\" area, etc. some was often free, and could be used for drivers\n+-----------+ 0xA0000\n| USER PROC | user process address space, from the end of DOS up to 640KB\n+-----------+\n|command.com| DOS command interpreter\n+-----------+\n|    DOS    | DOS permanent area, kept as small as possible, provided routines for display,\n|  kernel   | *basic* hardware access, etc.\n+-----------+ 0x600\n| BIOS data | BIOS data area, contained simple hardware descriptions, etc.\n+-----------+ 0x400\n| interrupt | the interrupt vector table, starting from 0 and going to 1k, contained\n|  vector   | the addresses of routines called when interrupts occurred.  e.g.\n|  table    | interrupt 0x21 checked the address at 0x21*4 and far-jumped to that\n|           | location to service the interrupt.\n+-----------+ 0x0"
  },
  {
    "url": "https://stackoverflow.com/questions/2351148/explicit-template-instantiation-when-is-it-used",
    "body": "Disassembly of section .text._ZN10MyTemplateIiE1fEi:\n0000000000000000 <MyTemplate<int>::f(int)>:\n   0:   f3 0f 1e fa             endbr64\n   4:   55                      push   %rbp\n   5:   48 89 e5                mov    %rsp,%rbp\n   8:   48 89 7d f8             mov    %rdi,-0x8(%rbp)\n   c:   89 75 f4                mov    %esi,-0xc(%rbp)\n   f:   8b 45 f4                mov    -0xc(%rbp),%eax\n  12:   83 c0 01                add    $0x1,%eax\n  15:   5d                      pop    %rbp\n  16:   c3                      retq"
  },
  {
    "url": "https://stackoverflow.com/questions/2351148/explicit-template-instantiation-when-is-it-used",
    "body": "# List all weak symbols with size only, no address.\nfind . -name '*.o' | xargs -I{} nm -C --size-sort --radix d '{}' |\n  grep ' W ' > nm.log\n# Sort by symbol size.\nsort -k1 -n nm.log -o nm.sort.log\n# Get a repetition count.\nuniq -c nm.sort.log > nm.uniq.log\n# Find the most repeated/largest objects.\nsort -k1,2 -n nm.uniq.log -o nm.uniq.sort.log\n# Find the objects that would give you the most gain after refactor.\n# This gain is calculated as \"(n_occurences - 1) * size\" which is\n# the size you would gain for keeping just a single instance.\n# If you are going to refactor anything, you should start with the ones\n# at the bottom of this list.\nawk '{gain = ($1 - 1) * $2; print gain, $0}' nm.uniq.sort.log |\n  sort -k1 -n > nm.gains.log\n# Total gain if you refactored everything.\nawk 'START{sum=0}{sum += $1}END{print sum}' nm.gains.log\n# Total size. The closer total gain above is to total size, the more\n# you would gain from the refactor.\nawk 'START{sum=0}{sum += $1}END{print sum}' nm.log"
  },
  {
    "url": "https://stackoverflow.com/questions/2940367/what-is-more-efficient-using-pow-to-square-or-just-multiply-it-with-itself",
    "body": "c++\n#include <cmath>\n#include <chrono>\n#include <iostream>\n#include <random>\nusing Moment = std::chrono::high_resolution_clock::time_point;\nusing FloatSecs = std::chrono::duration<double>;\ninline Moment now()\n{\n    return std::chrono::high_resolution_clock::now();\n}\n#define TEST(num, expression) \\\ndouble test##num(double b, long loops) \\\n{ \\\n    double x = 0.0; \\\n\\\n    auto startTime = now(); \\\n    for (long i=0; i<loops; ++i) \\\n    { \\\n        x += expression; \\\n        b += 1.0; \\\n    } \\\n    auto elapsed = now() - startTime; \\\n    auto seconds = std::chrono::duration_cast<FloatSecs>(elapsed); \\\n    std::cout << seconds.count() << \"\\t\"; \\\n    return x; \\\n}\nTEST(2, b*b)\nTEST(3, b*b*b)\nTEST(4, b*b*b*b)\nTEST(5, b*b*b*b*b)\ntemplate <int exponent>\ndouble testCppPow(double base, long loops)\n{\n    double x = 0.0;\n    auto startTime = now();\n    for (long i=0; i<loops; ++i)\n    {\n        x += std::pow(base, exponent);\n        base += 1.0;\n    }\n    auto elapsed = now() - startTime;\n    auto seconds = std::chrono::duration_cast<FloatSecs>(elapsed); \\\n    std::cout << seconds.count() << \"\\t\"; \\\n    return x;\n}\ndouble testCPow(double base, double exponent, long loops)\n{\n    double x = 0.0;\n    auto startTime = now();\n    for (long i=0; i<loops; ++i)\n    {\n        x += ::pow(base, exponent);\n        base += 1.0;\n    }\n    auto elapsed = now() - startTime;\n    auto seconds = std::chrono::duration_cast<FloatSecs>(elapsed); \\\n    std::cout << seconds.count() << \"\\t\"; \\\n    return x;\n}\nint main()\n{\n    using std::cout;\n    long loops = 100000000l;\n    double x = 0;\n    std::random_device rd;\n    std::default_random_engine re(rd());\n    std::uniform_real_distribution<double> dist(1.1, 1.2);\n    cout << \"exp\\tc++ pow\\tc pow\\tx*x*x...\";\n    cout << \"\\n2\\t\";\n    double b = dist(re);\n    x += testCppPow<2>(b, loops);\n    x += testCPow(b, 2.0, loops);\n    x += test2(b, loops);\n    cout << \"\\n3\\t\";\n    b = dist(re);\n    x += testCppPow<3>(b, loops);\n    x += testCPow(b, 3.0, loops);\n    x += test3(b, loops);\n    cout << \"\\n4\\t\";\n    b = dist(re);\n    x += testCppPow<4>(b, loops);\n    x += testCPow(b, 4.0, loops);\n    x += test4(b, loops);\n    cout << \"\\n5\\t\";\n    b = dist(re);\n    x += testCppPow<5>(b, loops);\n    x += testCPow(b, 5.0, loops);\n    x += test5(b, loops);\n    std::cout << \"\\n\" << x << \"\\n\";\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/62928396/what-is-a-niebloid",
    "body": "namespace mystd\n{\n\tclass B{};\n\tclass A{};\n\ttemplate<typename T>\n\tvoid swap(T &a, T &b)\n\t{\n\t\tstd::cout << \"mystd::swap\\n\";\n\t}\n}\nnamespace sx\n{\n\tnamespace impl {\n        // our functor, the niebloid\n\t\tstruct __swap {\n\t\t\ttemplate<typename R, typename = std::enable_if_t< std::is_same<R, mystd::A>::value >  >\n\t\t\tvoid operator()(R &a, R &b) const\n\t\t\t{\n\t\t\t\tstd::cout << \"in sx::swap()\\n\";\n\t\t\t\t// swap(a, b);\n\t\t\t}\n\t\t};\n\t}\n\tinline constexpr impl::__swap swap{};\n}\nint main()\n{\n\tmystd::B a, b;\n\tswap(a, b); // calls mystd::swap()\n\tusing namespace sx;\n\tmystd::A c, d;\n\tswap(c, d); // No ADL!, calls sx::swap!\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/675039/how-can-i-create-a-directory-tree-in-c-on-linux",
    "body": "/*\n@(#)File:           mkpath.c\n@(#)Purpose:        Create all directories in path\n@(#)Author:         J Leffler\n@(#)Copyright:      (C) JLSS 1990-2020\n@(#)Derivation:     mkpath.c 1.16 2020/06/19 15:08:10\n*/\n/*TABSTOP=4*/\n#include \"posixver.h\"\n#include \"mkpath.h\"\n#include \"emalloc.h\"\n#include <errno.h>\n#include <string.h>\n/* \"sysstat.h\" == <sys/stat.h> with fixup for (old) Windows - inc mode_t */\n#include \"sysstat.h\"\ntypedef struct stat Stat;\nstatic int do_mkdir(const char *path, mode_t mode)\n{\n    Stat            st;\n    int             status = 0;\n    if (stat(path, &st) != 0)\n    {\n        /* Directory does not exist. EEXIST for race condition */\n        if (mkdir(path, mode) != 0 && errno != EEXIST)\n            status = -1;\n    }\n    else if (!S_ISDIR(st.st_mode))\n    {\n        errno = ENOTDIR;\n        status = -1;\n    }\n    return(status);\n}\n/**\n** mkpath - ensure all directories in path exist\n** Algorithm takes the pessimistic view and works top-down to ensure\n** each directory in path exists, rather than optimistically creating\n** the last element and working backwards.\n*/\nint mkpath(const char *path, mode_t mode)\n{\n    char           *pp;\n    char           *sp;\n    int             status;\n    char           *copypath = STRDUP(path);\n    status = 0;\n    pp = copypath;\n    while (status == 0 && (sp = strchr(pp, '/')) != 0)\n    {\n        if (sp != pp)\n        {\n            /* Neither root nor double slash in path */\n            *sp = '\\0';\n            status = do_mkdir(copypath, mode);\n            *sp = '/';\n        }\n        pp = sp + 1;\n    }\n    if (status == 0)\n        status = do_mkdir(path, mode);\n    FREE(copypath);\n    return (status);\n}\n#ifdef TEST\n#include <stdio.h>\n#include <unistd.h>\n/*\n** Stress test with parallel running of mkpath() function.\n** Before the EEXIST test, code would fail.\n** With the EEXIST test, code does not fail.\n**\n** Test shell script\n** PREFIX=mkpath.$$\n** NAME=./$PREFIX/sa/32/ad/13/23/13/12/13/sd/ds/ww/qq/ss/dd/zz/xx/dd/rr/ff/ff/ss/ss/ss/ss/ss/ss/ss/ss\n** : ${MKPATH:=mkpath}\n** ./$MKPATH $NAME &\n** [...repeat a dozen times or so...]\n** ./$MKPATH $NAME &\n** wait\n** rm -fr ./$PREFIX/\n*/\nint main(int argc, char **argv)\n{\n    int             i;\n    for (i = 1; i < argc; i++)\n    {\n        for (int j = 0; j < 20; j++)\n        {\n            if (fork() == 0)\n            {\n                int rc = mkpath(argv[i], 0777);\n                if (rc != 0)\n                    fprintf(stderr, \"%d: failed to create (%d: %s): %s\\n\",\n                            (int)getpid(), errno, strerror(errno), argv[i]);\n                exit(rc == 0 ? EXIT_SUCCESS : EXIT_FAILURE);\n            }\n        }\n        int status;\n        int fail = 0;\n        while (wait(&status) != -1)\n        {\n            if (WEXITSTATUS(status) != 0)\n                fail = 1;\n        }\n        if (fail == 0)\n            printf(\"created: %s\\n\", argv[i]);\n    }\n    return(0);\n}\n#endif /* TEST */"
  },
  {
    "url": "https://stackoverflow.com/questions/5815675/what-is-sock-dgram-and-sock-stream",
    "body": "╔═══════════╦══════════════════════════╗\n║           ║       Socket Type        ║\n║ Address   ╟────────────┬─────────────╢\n║ Family    ║ SOCK_DGRAM │ SOCK_STREAM ║\n╠═══════════╬════════════╪═════════════╣\n║ IPX/SPX   ║ SPX        │ IPX         ║\n║ NetBIOS   ║ NetBIOS    │ n/a         ║\n║ IPv4      ║ UDP        │ TCP         ║\n║ AppleTalk ║ DDP        │ ADSP        ║\n║ IPv6      ║ UDP        │ TCP         ║\n║ IrDA      ║ IrLMP      │ IrTTP       ║\n║ Bluetooth ║ ?          │ RFCOMM      ║\n╚═══════════╩════════════╧═════════════╝"
  },
  {
    "url": "https://stackoverflow.com/questions/5815675/what-is-sock-dgram-and-sock-stream",
    "body": "╔═══════════╦══════════════════════════════════════════════════════╗\n║           ║                      Socket Type                     ║\n║ Address   ╟────────────┬─────────────┬──────────┬────────────────╢\n║ Family    ║ SOCK_DGRAM │ SOCK_STREAM │ SOCK_RDM │ SOCK_SEQPACKET ║\n╠═══════════╬════════════╪═════════════╪══════════╪════════════════╣\n║ IPX/SPX   ║ SPX        │ IPX         │ ?        │ ?              ║\n║ NetBIOS   ║ NetBIOS    │ n/a         │ ?        │ ?              ║\n║ IPv4      ║ UDP        │ TCP         │ ?        │ SCTP           ║\n║ AppleTalk ║ DDP        │ ADSP        │ ?        │ ?              ║\n║ IPv6      ║ UDP        │ TCP         │ ?        │ SCTP           ║\n║ IrDA      ║ IrLMP      │ IrTTP       │ ?        │ ?              ║\n║ Bluetooth ║ ?          │ RFCOMM      │ ?        │ ?              ║\n╚═══════════╩════════════╧═════════════╧══════════╧════════════════╝"
  },
  {
    "url": "https://stackoverflow.com/questions/59637731/subtracting-packed-8-bit-integers-in-an-64-bit-integer-by-1-in-parallel-swar-wi",
    "body": "Throughput Analysis Report\n--------------------------\nBlock Throughput: 4.96 Cycles       Throughput Bottleneck: Backend\nLoop Count:  26\nPort Binding In Cycles Per Iteration:\n--------------------------------------------------------------------------------------------------\n|  Port  |   0   -  DV   |   1   |   2   -  D    |   3   -  D    |   4   |   5   |   6   |   7   |\n--------------------------------------------------------------------------------------------------\n| Cycles |  1.5     0.0  |  1.5  |  0.0     0.0  |  0.0     0.0  |  0.0  |  1.5  |  1.5  |  0.0  |\n--------------------------------------------------------------------------------------------------"
  },
  {
    "url": "https://stackoverflow.com/questions/9456728/how-to-deal-with-bad-alloc-in-c",
    "body": "lru_cache<widget> widget_cache;\ndouble perform_operation(int widget_id) {\n    std::optional<widget> maybe_widget = widget_cache.find_by_id(widget_id);\n    if (not maybe_widget) {\n        maybe_widget = widget_cache.store(widget_id, load_widget_from_disk(widget_id));\n    }\n    return maybe_widget->frobnicate();\n}\n…\nfor (int num_attempts = 0; num_attempts < MAX_NUM_ATTEMPTS; ++num_attempts) {\n    try {\n        return perform_operation(widget_id);\n    } catch (std::bad_alloc const&) {\n        if (widget_cache.empty()) throw; // memory error elsewhere.\n        widget_cache.remove_oldest();\n    }\n}\n// Handle too many failed attempts here."
  },
  {
    "url": "https://stackoverflow.com/questions/5878775/how-to-find-and-replace-string",
    "body": "void replace_all(\n    std::string& s,\n    std::string const& toReplace,\n    std::string const& replaceWith\n) {\n    std::string buf;\n    std::size_t pos = 0;\n    std::size_t prevPos;\n    // Reserves rough estimate of final size of string.\n    buf.reserve(s.size());\n    while (true) {\n        prevPos = pos;\n        pos = s.find(toReplace, pos);\n        if (pos == std::string::npos)\n            break;\n        buf.append(s, prevPos, pos - prevPos);\n        buf += replaceWith;\n        pos += toReplace.size();\n    }\n    buf.append(s, prevPos, s.size() - prevPos);\n    s.swap(buf);\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/35985960/c-why-is-boosthash-combine-the-best-way-to-combine-hash-values",
    "body": "c++\n#include <limits>\n#include <cstdint>\ntemplate<typename T>\nT xorshift(const T& n,int i){\n  return n^(n>>i);\n}\n// a hash function with another name as to not confuse with std::hash\nuint32_t distribute(const uint32_t& n){\n  uint32_t p = 0x55555555ul; // pattern of alternating 0 and 1\n  uint32_t c = 3423571495ul; // random uneven integer constant;\n  return c*xorshift(p*xorshift(n,16),16);\n}\n// a hash function with another name as to not confuse with std::hash\nuint64_t distribute(const uint64_t& n){\n  uint64_t p = 0x5555555555555555ull; // pattern of alternating 0 and 1\n  uint64_t c = 17316035218449499591ull;// random uneven integer constant;\n  return c*xorshift(p*xorshift(n,32),32);\n}\n// if c++20 rotl is not available:\ntemplate <typename T,typename S>\ntypename std::enable_if<std::is_unsigned<T>::value,T>::type\nconstexpr rotl(const T n, const S i){\n  const T m = (std::numeric_limits<T>::digits-1);\n  const T c = i&m;\n  return (n<<c)|(n>>((T(0)-c)&m)); // this is usually recognized by the compiler to mean rotation, also c++20 now gives us rotl directly\n}\n// call this function with the old seed and the new key to be hashed and combined into the new seed value, respectively the final hash\ntemplate <class T>\ninline size_t hash_combine(std::size_t& seed, const T& v)\n{\n    return rotl(seed,std::numeric_limits<size_t>::digits/3) ^ distribute(std::hash<T>{}(v));\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/776624/whats-faster-iterating-an-stl-vector-with-vectoriterator-or-with-at",
    "body": "iter(std::vector<int, std::allocator<int> >&):\n        mov     rax, QWORD PTR [rdi]\n        mov     rdx, QWORD PTR [rdi+8]\n        cmp     rax, rdx\n        je      .L1\n.L3:                              ; loop body\n        mov     DWORD PTR [rax], 5\n        add     rax, 4\n        cmp     rax, rdx\n        jne     .L3\n.L1:\n        ret\nindex(std::vector<int, std::allocator<int> >&):\n        mov     rax, QWORD PTR [rdi]\n        mov     rdx, QWORD PTR [rdi+8]\n        sub     rdx, rax\n        mov     rcx, rdx\n        shr     rcx, 2\n        je      .L6\n        add     rdx, rax\n.L8:                              ; loop body\n        mov     DWORD PTR [rax], 5\n        add     rax, 4\n        cmp     rdx, rax\n        jne     .L8\n.L6:\n        ret"
  },
  {
    "url": "https://stackoverflow.com/questions/68221024/why-must-i-provide-operator-when-operator-is-enough",
    "body": "c++\n#include <iostream>\n#include <compare>\nclass xyzzy {\npublic:\n    xyzzy(int data) : n(data) { }\n    auto operator<=>(xyzzy const &other) const {\n        // Could probably just use: 'return n <=> other.n;'\n        // but this is from the OPs actual code, so I didn't\n        // want to change it too much (formatting only).\n        if (n < other.n) return std::strong_ordering::less;\n        if (n > other.n) return std::strong_ordering::greater;\n        return std::strong_ordering::equal;\n    }\n    //auto operator==(xyzzy const &other) const {\n    //    return n == other.n;\n    //}\n    //bool operator==(xyzzy const &) const = default;\nprivate:\n    int n;\n};\nint main() {\n    xyzzy twisty(3);\n    xyzzy passages(3);\n    if (twisty < passages) std::cout << \"less\\n\";\n    if (twisty == passages) std::cout << \"equal\\n\";\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/67595789/what-is-destroying-operator-delete-in-c20",
    "body": "#include <iostream>\n#include <new>\nstruct Foo {\n    ~Foo() {\n        std::cout << \"In Foo::~Foo()\\n\";\n    }\n    void operator delete(void *p) {\n        std::cout << \"In Foo::operator delete(void *)\\n\";\n        ::operator delete(p);\n    }\n};\nstruct Bar {\n    ~Bar() {\n        std::cout << \"In Bar::~Bar()\\n\";\n    }\n    void operator delete(Bar *p, std::destroying_delete_t) {\n        std::cout << \"In Bar::operator delete(Bar *, std::destroying_delete_t)\\n\";\n        p->~Bar();\n        ::operator delete(p);\n    }\n};\nint main() {\n    delete new Foo;\n    delete new Bar;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/67595789/what-is-destroying-operator-delete-in-c20",
    "body": "#include <iostream>\n#include <new>\nstruct Shape {\n    const enum Kinds {\n        TRIANGLE,\n        SQUARE\n    } kind;\n    Shape(Kinds k) : kind(k) {}\n    ~Shape() {\n        std::cout << \"In Shape::~Shape()\\n\";\n    }\n    void operator delete(Shape *, std::destroying_delete_t);\n};\nstruct Triangle : Shape {\n    Triangle() : Shape(TRIANGLE) {}\n    ~Triangle() {\n        std::cout << \"In Triangle::~Triangle()\\n\";\n    }\n};\nstruct Square : Shape {\n    Square() : Shape(SQUARE) {}\n    ~Square() {\n        std::cout << \"In Square::~Square()\\n\";\n    }\n};\nvoid Shape::operator delete(Shape *p, std::destroying_delete_t) {\n    switch(p->kind) {\n    case TRIANGLE:\n        static_cast<Triangle *>(p)->~Triangle();\n        break;\n    case SQUARE:\n        static_cast<Square *>(p)->~Square();\n    }\n    ::operator delete(p);\n}\nint main() {\n    Shape *p = new Triangle;\n    delete p;\n    p = new Square;\n    delete p;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/49397233/how-to-enable-c17-support-in-vscode-c-extension",
    "body": "{\n  \"tasks\": [\n    {\n      \"type\": \"cppbuild\",\n      \"label\": \"C/C++: g++ build active file\",\n      \"command\": \"/usr/bin/g++\",\n      \"args\": [\n        \"-std=c++17\",\n        \"-I\",\n        \"${fileDirname}\",\n        \"-g\",\n        \"${fileDirname}/*.cpp\",\n        \"-o\",\n        \"${workspaceFolder}/out/${fileBasenameNoExtension}.o\"\n      ],\n      \"options\": {\n        \"cwd\": \"${workspaceFolder}\"\n      },\n      \"problemMatcher\": [\"$gcc\"],\n      \"group\": {\n        \"kind\": \"build\",\n        \"isDefault\": true\n      }\n    }\n  ],\n  \"version\": \"2.0.0\"\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/11279715/nullptr-and-checking-if-a-pointer-points-to-a-valid-object",
    "body": "#include <iostream>\n#include <memory>\n\nvoid observe(std::weak_ptr<int> weak)\n{\n    if (auto observe = weak.lock()) {\n        std::cout << \"\\tobserve() able to lock weak_ptr<>, value=\" << *observe << \"\\n\";\n    } else {\n        std::cout << \"\\tobserve() unable to lock weak_ptr<>\\n\";\n    }\n}\n\nint main()\n{\n    std::weak_ptr<int> weak;\n    std::cout << \"weak_ptr<> not yet initialized\\n\";\n    observe(weak);\n\n    {\n        auto shared = std::make_shared<int>(42);\n        weak = shared;\n        std::cout << \"weak_ptr<> initialized with shared_ptr.\\n\";\n        observe(weak);\n    }\n\n    std::cout << \"shared_ptr<> has been destructed due to scope exit.\\n\";\n    observe(weak);\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/6121623/catching-exception-divide-by-zero",
    "body": "c++\n#include <iostream>\n#include <stdexcept>\n// Integer division/remainder, catching divide by zero.\ninline int intDivEx (int numerator, int denominator) {\n    if (denominator == 0)\n        throw std::overflow_error(\"Divide by zero exception\");\n    return numerator / denominator;\n}\ninline int intModEx (int numerator, int denominator) {\n    if (denominator == 0)\n        throw std::overflow_error(\"Divide by zero exception\");\n    return numerator % denominator;\n}\nint main (void) {\n    int i = 42;\n    try {\n        i = intDivEx (10, 0);\n    } catch (std::overflow_error &e) {\n        std::cout << e.what() << \" -> \";\n    }\n    std::cout << i << std::endl;\n    try {\n        i = intDivEx (10, 2);\n    } catch (std::overflow_error &e) {\n        std::cout << e.what() << \" -> \";\n    }\n    std::cout << i << std::endl;\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/58509147/why-does-same-as-concept-check-type-equality-twice",
    "body": "c++\n#include <type_traits>\n#include <iostream>\n#include <concepts>\ntemplate< class T, class U >\nconcept SameHelper = std::is_same_v<T, U>;\ntemplate< class T, class U >\nconcept my_same_as = SameHelper<T, U>;\ntemplate< class T, class U> requires my_same_as<U, T>\nvoid foo(T a, U b) {\n    std::cout << \"Not integral\" << std::endl;\n}\ntemplate< class T, class U> requires (my_same_as<T, U> && std::integral<T>)\nvoid foo(T a, U b) {\n    std::cout << \"Integral\" << std::endl;\n}\nint main() {\n    foo(1, 2);\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/66937947/why-is-unique-ptr-not-equality-comparable-with-nullptr-t-in-c20",
    "body": "> <source>:6:20: note: constraints not satisfied\n> In file included from <source>:1:\n> /…/concepts:72:13:   required for the satisfaction of\n>     'convertible_to<_Tp, typename std::common_reference<_Tp1, _Tp2>::type>'\n>     [with _Tp = const std::unique_ptr<int, std::default_delete<int> >&; _Tp2 = const std::nullptr_t&; _Tp1 = const std::unique_ptr<int, std::default_delete<int> >&]\n> /…/concepts:72:30: note: the expression 'is_convertible_v<_From, _To>\n>     [with _From = const std::unique_ptr<int, std::default_delete<int> >&; _To = std::unique_ptr<int, std::default_delete<int> >]' evaluated to 'false'\n>    72 |     concept convertible_to = is_convertible_v<_From, _To>\n>       |                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n(edited for legibility) [Compiler Explorer link][3].\n[`std::common_reference_with`][4] requires:\n>     template < class T, class U >\n>     concept common_reference_with =\n>       std::same_as<std::common_reference_t<T, U>, std::common_reference_t<U, T>> &&\n>       std::convertible_to<T, std::common_reference_t<T, U>> &&\n>       std::convertible_to<U, std::common_reference_t<T, U>>;\n`std::common_reference_t<const std::unique_ptr<int>&, const std::nullptr_t&>` is `std::unique_ptr<int>` (see [compiler explorer link][5]).\nPutting this together, there is a transitive requirement that `std::convertible_to<const std::unique_ptr<int>&, std::unique_ptr<int>>`, which is equivalent to requiring that `std::unique_ptr<int>` is copy-constructible.\n## Why is the `std::common_reference_t` not a reference?\nWhy is `std::common_reference_t<const std::unique_ptr<T>&, const std::nullptr_t&> = std::unique_ptr<T>` instead of `const std::unique_ptr<T>&`? The documentation for [`std::common_reference_t`][6] for two types (`sizeof...(T)` is two) says:\n>  -  If `T1` and `T2` are both reference types, and the _simple common reference type_ `S` of `T1` and `T2` (as defined below) exists, then the\n> member type type names `S`;\n>  -  Otherwise, if `std::basic_common_reference<std::remove_cvref_t<T1>, std::remove_cvref_t<T2>, T1Q, T2Q>::type` exists, where `TiQ` is a unary\n> alias template such that `TiQ<U>` is `U` with the addition of `Ti`'s cv- and\n> reference qualifiers, then the member type type names that type;\n>  -  Otherwise, if `decltype(false? val<T1>() : val<T2>())`, where val is a function template `template<class T> T val();`, is a valid type, then\n> the member type type names that type;\n>  -  Otherwise, if `std::common_type_t<T1, T2>` is a valid type, then the member type type names that type;\n>  -  Otherwise, there is no member type.\n`const std::unique_ptr<T>&` and `const std::nullptr_t&` don't have a simple common reference type, since the references are not immediately convertible to a common base type (i.e. `false ? crefUPtr : crefNullptrT` is ill-formed). There is no `std::basic_common_reference` specialization for `std::unique_ptr<T>`. The third option also fails, but we trigger `std::common_type_t<const std::unique_ptr<T>&, const std::nullptr_t&>`.\nFor [`std::common_type`][7], `std::common_type<const std::unique_ptr<T>&, const std::nullptr_t&> = std::common_type<std::unique_ptr<T>, std::nullptr_t>`, because:\n> If applying `std::decay` to at least one of `T1` and `T2` produces a\n> different type, the member type names the same type as\n> `std::common_type<std::decay<T1>::type, std::decay<T2>::type>::type`, if\n> it exists; if not, there is no member type.\n`std::common_type<std::unique_ptr<T>, std::nullptr_t>` does in fact exist; it is `std::unique_ptr<T>`. This is why the reference gets stripped.\n---\n# Can we fix the standard to support cases like this?\nThis has turned into [P2404][8], which proposes changes to `std::equality_comparable_with`, `std::totally_ordered_with`, and `std::three_way_comparable_with` to support move-only types.\n## Why do we even have these common-reference requirements?\nIn https://stackoverflow.com/q/61177302/1896169, the [justification given by T.C.][9] (originally sourced from [n3351][10] pages 15-16) for the common-reference requirements on `equality_comparable_with` is:\n> [W]hat does it even mean for two values of different types to be equal? The design says that cross-type equality is defined by mapping them to the common (reference) type (this conversion is required to preserve the value).\nJust requiring the `==` operations that might naively be expected of the concept doesn't work, because:\n> [I]t allows having `t == u` and `t2 == u` but `t != t2`\nSo the common-reference requirements are there for mathematical soundness, simultaneously allowing for a possible implementation of:"
  },
  {
    "url": "https://stackoverflow.com/questions/66937947/why-is-unique-ptr-not-equality-comparable-with-nullptr-t-in-c20",
    "body": "With the C++0X concepts that n3351 supported, this implementation would actually be used as a fallback if there was no heterogeneous `operator==(T, U)`.\nWith C++20 concepts, we require a heterogeneous `operator==(T, U)` to exist, so this implementation will never be used.\nNote that n3351 expresses that this kind of heterogeneous equality is already an extension of equality, which is only rigorously mathematically defined within a single type. Indeed, when we write heterogeneous equality operations, we are pretending that the two types share a common super-type, with the operation happening inside that common type.\n## Can the common-reference requirements support this case?\nPerhaps the common-reference requirements for `std::equality_comparable` are too strict. Importantly, the mathematical requirement is only that there exists a common supertype in which this lifted `operator==` is an equality, but what the common reference requirements require is something stricter, additionally requiring:\n 1. The common supertype must be the one acquired through `std::common_reference_t`.\n 2. We must be able to form a common supertype _reference_ to both types.\nRelaxing the first point is basically just providing an explicit customization point for `std::equality_comparable_with` in which you could explicitly opt-in a pair of types to meet the concept. For the second point, mathematically, a \"reference\" is meaningless. As such, this second point can also be relaxed to allow the common supertype to be implicitly convertible from both types.\n## Can we relax the common-reference requirements to more closely follow the intended common-supertype requirements?\nThis is tricky to get right. Importantly, we actually only care that the common supertype exists, but we never actually need to use it in the code. As such, we do not need to worry about efficiency or even whether the implementation would be impossible when codifying a common supertype conversion.\nThis can be accomplished by changing the `std::common_reference_with` part of `equality_comparable_with`:"
  },
  {
    "url": "https://stackoverflow.com/questions/66937947/why-is-unique-ptr-not-equality-comparable-with-nullptr-t-in-c20",
    "body": "In particular, the change is changing `common_reference_with` to this hypothetical `__CommonSupertypeWith` where `__CommonSupertypeWith` differs by allowing for `std::common_reference_t<T, U>` to produce a reference-stripped version of `T` or `U` and also by trying both `C(T&&)` and `C(const T&)` to create the common reference. For more details, see [P2404][8].\n---\n# How do I work around `std::equality_comparable_with` before this gets merged into the standard?\n## Change which overload you use\nFor all of the uses of `std::equality_comparable_with` (or any of the other `*_with` concepts) in the standard library, there is helpfully a predicate overload which you can pass a function to. That means that you can just pass `std::equal_to()` to the predicate overload and get the desired behavior (**not** `std::ranges::equal_to`, which is constrained, but the unconstrained `std::equal_to`).\nThis doesn't mean that it would be a good idea to not fix `std::equality_comparable_with`, however.\n## Can I extend my own types to meet `std::equality_comparable_with`?\nThe common-reference requirements use `std::common_reference_t`, which has a customization point of [`std::basic_common_reference`][6], for the purpose of:\n> The class template `basic_common_reference` is a customization point that allows users to influence the result of `common_reference` for user-defined types (typically proxy references).\nIt is a horrible hack, but if we write a proxy reference that supports both types we want to compare, we can specialize `std::basic_common_reference` for our types, enabling our types to meet `std::equality_comparable_with`. See also https://stackoverflow.com/q/66944119/1896169 . If you choose to do this, beware; `std::common_reference_t` is not only used by `std::equality_comparable_with` or the other <code><i>comparison_relation</i>_with</code> concepts, you risk causing cascading problems down the road. It is best if you ensure that the common reference is actually a common reference, e.g.:"
  },
  {
    "url": "https://stackoverflow.com/questions/733056/is-there-a-way-to-get-function-name-inside-a-c-function",
    "body": "#include <iostream>\n#include <string_view>\n#include <source_location>\nvoid log(std::string_view message,\n         const std::source_location& location = std::source_location::current()\n) {\n    std::cout << \"info:\"\n              << location.file_name() << \":\"\n              << location.line() << \":\"\n              << location.function_name() << \" \"\n              << message << '\\n';\n}\nint f(int i) {\n    log(\"Hello world!\"); // Line 16\n    return i + 1;\n}\nint f(double i) {\n    log(\"Hello world!\"); // Line 21\n    return i + 1.0;\n}\nint main() {\n    f(1);\n    f(1.0);\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/76552816/why-is-initializing-a-string-to-more-efficient-than-the-default-constructor",
    "body": "// template head etc...\nvoid basic_string</* ... */>::__init(const value_type* __s, size_type __sz)\n{\n    // length and constexpr checks\n    pointer __p;\n    if (__fits_in_sso(__sz))\n    {\n        __set_short_size(__sz); // set size to zero, first byte\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        // not entered\n    }\n    traits_type::copy(std::__to_address(__p), __s, __sz); // copy string, nothing happens\n    traits_type::assign(__p[__sz], value_type()); // add null terminator\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/657155/how-to-enable-shared-from-this-of-both-parent-and-derived",
    "body": "#include <functional>\n#include <iostream>\nclass foo : public enable_shared_from_base<foo> {\n    void foo_do_it()\n    {\n        std::cout << \"foo::do_it\\n\";\n    }\npublic:\n    virtual std::function<void()> get_callback()\n    {\n        return std::bind(&foo::foo_do_it, shared_from_base<foo>());\n    }\n};\nclass bar1 : public foo {\n    void bar1_do_it()\n    {\n        std::cout << \"bar1::do_it\\n\";\n    }\npublic:\n    virtual std::function<void()> get_callback() override\n    {\n        return std::bind(&bar1::bar1_do_it, shared_from_base<bar1>());\n    }\n};"
  },
  {
    "url": "https://stackoverflow.com/questions/11813271/embed-resources-eg-shader-code-images-into-executable-library-with-cmake",
    "body": "# Creates C resources file from files in given directory\nfunction(create_resources dir output)\n\t# Create empty output file\n\tfile(WRITE ${output} \"\")\n\t# Collect input files\n\tfile(GLOB bins ${dir}/*)\n\t# Iterate through input files\n\tforeach(bin ${bins})\n\t\t# Get short filename\n\t\tstring(REGEX MATCH \"([^/]+)$\" filename ${bin})\n\t\t# Replace filename spaces & extension separator for C compatibility\n\t\tstring(REGEX REPLACE \"\\\\.| |-\" \"_\" filename ${filename})\n\t\t# Read hex data from file\n\t\tfile(READ ${bin} filedata HEX)\n\t\t# Convert hex data for C compatibility\n\t\tstring(REGEX REPLACE \"([0-9a-f][0-9a-f])\" \"0x\\\\1,\" filedata ${filedata})\n\t\t# Append data to output file\n\t\tfile(APPEND ${output} \"const unsigned char ${filename}[] = {${filedata}};\\nconst unsigned ${filename}_size = sizeof(${filename});\\n\")\n\tendforeach()\nendfunction()"
  },
  {
    "url": "https://stackoverflow.com/questions/34596768/stdunordered-mapfind-using-a-type-different-than-the-key-type",
    "body": "#include <cstddef>\n#include <functional>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n\nusing namespace std::literals;\n\nstruct string_hash\n{\n    using hash_type = std::hash<std::string_view>;\n    using is_transparent = void;\n\n    std::size_t operator()(const char* str) const        { return hash_type{}(str); }\n    std::size_t operator()(std::string_view str) const   { return hash_type{}(str); }\n    std::size_t operator()(std::string const& str) const { return hash_type{}(str); }\n};\n\nint main()\n{\n    // simple comparison demo\n    std::unordered_map<int,char> example = {{1, 'a'}, {2, 'b'}};\n\n    if (auto search = example.find(2); search != example.end())\n        std::cout << \"Found \" << search->first << \" \" << search->second << '\\n';\n    else\n        std::cout << \"Not found\\n\";\n\n    // C++20 demo: Heterogeneous lookup for unordered containers (transparent hashing)\n    std::unordered_map<std::string, size_t, string_hash, std::equal_to<>> map{{\"one\"s, 1}};\n    std::cout << std::boolalpha\n        << (map.find(\"one\")   != map.end()) << '\\n'\n        << (map.find(\"one\"s)  != map.end()) << '\\n'\n        << (map.find(\"one\"sv) != map.end()) << '\\n';\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/62159885/why-is-an-overloaded-function-with-two-arguments-of-type-double-called-when-pass",
    "body": "func(1, 1);    // perfect match for #1, so #1 is chosen\nfunc(1., 1.);  // perfect match for #2, so #2 is chosen\nfunc(1., 1);   // could call #1 by converting 1st argument to int\n               // (floating-integral conversion)\n               // could call #2 by converting 2nd argument to double\n               // (floating-integral conversion)\n               // error: ambiguous (equal number of conversions needed for both #1 and #2)\nfunc(1ll, 1.); // could call #1 by converting both arguments to ints\n               // (integral conversion for 1st argument, floating-integral conversion for 2nd argument)\n               // could call #2 by converting just 1st argument to double\n               // (floating-integral conversion for 1st argument)\n               // for the 2nd parameter, #2 is ranked as a better choice,\n               // since it has a better implicit conversion sequence for #2\n               // and so #2 is chosen (even though both #1 and #2 are tied for the 1st argument)"
  },
  {
    "url": "https://stackoverflow.com/questions/62159885/why-is-an-overloaded-function-with-two-arguments-of-type-double-called-when-pass",
    "body": "func(1, 1.f);  // could call #1 by converting 2nd argument to int\n               // (floating-integral conversion for 2nd argument)\n               // could call #2 by converting 1st argument to double, and converting 2nd argument to double\n               // (floating-integral conversion for 1st argument, and floating-point promotion for 2nd argument)\n               // could call #3 by converting 1st argument to float\n               // (floating-integral conversion for 1st argument)\n               // error: ambiguous (equal number of conversions needed for #1, #2 and #3)"
  },
  {
    "url": "https://stackoverflow.com/questions/15543571/allocconsole-not-displaying-cout",
    "body": "void CreateConsole()\n{\n\tif (!AllocConsole()) {\n\t\t// Add some error handling here.\n\t\t// You can call GetLastError() to get more info about the error.\n\t\treturn;\n\t}\n\n\t// std::cout, std::clog, std::cerr, std::cin\n\tFILE* fDummy;\n\tfreopen_s(&fDummy, \"CONOUT$\", \"w\", stdout);\n\tfreopen_s(&fDummy, \"CONOUT$\", \"w\", stderr);\n\tfreopen_s(&fDummy, \"CONIN$\", \"r\", stdin);\n\tstd::cout.clear();\n\tstd::clog.clear();\n\tstd::cerr.clear();\n\tstd::cin.clear();\n\t// std::wcout, std::wclog, std::wcerr, std::wcin\n\tHANDLE hConOut = CreateFile(_T(\"CONOUT$\"), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n\tHANDLE hConIn = CreateFile(_T(\"CONIN$\"), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n\tSetStdHandle(STD_OUTPUT_HANDLE, hConOut);\n\tSetStdHandle(STD_ERROR_HANDLE, hConOut);\n\tSetStdHandle(STD_INPUT_HANDLE, hConIn);\n\tstd::wcout.clear();\n\tstd::wclog.clear();\n\tstd::wcerr.clear();\n\tstd::wcin.clear();\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/555505/when-were-the-and-and-or-alternative-tokens-introduced-in-c",
    "body": "Table 2 - Alternative tokens\n    alternative primary | alternative primary | alternative primary\n    --------------------+---------------------+--------------------\n       <%          {    |    and         &&   |    and_eq      &=\n       %>          }    |    bitor       |    |    or_eq       |=\n       <:          [    |    or          ||   |    xor_eq      ^=\n       :>          ]    |    xor         ^    |    not         !\n       %:          #    |    compl       ~    |    not_eq      !=\n       %:%:        ##   |    bitand      &    |"
  },
  {
    "url": "https://stackoverflow.com/questions/59490698/how-can-i-get-the-depth-of-a-multidimensional-stdvector-at-compile-time",
    "body": "#include <iostream>\n#include <vector>\n#include <array>\n#include <type_traits>\nusing std::begin; // import std::begin for handling C-style array with the same ADL idiom as the other types\n// decide whether T is a container type - i define this as anything that has a well formed begin iterator type.\n// we return true/false to determing if T is a container type.\n// we use the type conversion ability of nullptr to std::nullptr_t or void* (prefers std::nullptr_t overload if it exists).\n// use SFINAE to conditionally enable the std::nullptr_t overload.\n// these types might not have a default constructor, so return a pointer to it.\n// base case returns void* which we decay to void to represent not a container.\ntemplate<typename T>\nvoid *_iter_elem(void*) { return nullptr; }\ntemplate<typename T>\ntypename std::iterator_traits<decltype(begin(*(T*)nullptr))>::value_type *_iter_elem(std::nullptr_t) { return nullptr; }\n// this is just a convenience wrapper to make the above user friendly\ntemplate<typename T>\nstruct container_stuff\n{\n    typedef std::remove_pointer_t<decltype(_iter_elem<T>(nullptr))> elem_t;    // the element type if T is a container, otherwise void\n    static inline constexpr bool is_container = !std::is_same_v<elem_t, void>; // true iff T is a container\n};\n// and our old dimension counting logic (now uses std:nullptr_t SFINAE logic)\ntemplate<typename T>\nconstexpr std::size_t _dimensions(void*) { return 0; }\ntemplate<typename T, std::enable_if_t<container_stuff<T>::is_container, int> = 0>\nconstexpr std::size_t _dimensions(std::nullptr_t) { return 1 + _dimensions<typename container_stuff<T>::elem_t>(nullptr); }\n// and our nice little alias\ntemplate<typename T>\ninline constexpr std::size_t dimensions_v = _dimensions<T>(nullptr);\nint main()\n{\n    std::cout << container_stuff<int>::is_container << '\\n';                 // false\n    std::cout << container_stuff<int[6]>::is_container<< '\\n';               // true\n    std::cout << container_stuff<std::vector<int>>::is_container << '\\n';    // true\n    std::cout << container_stuff<std::array<int, 3>>::is_container << '\\n';  // true\n    std::cout << dimensions_v<std::vector<std::array<std::vector<int>, 2>>>; // 3\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/79119461/an-empty-program-that-does-nothing-in-c-needs-a-heap-of-204kb-but-not-in-c",
    "body": "$ gdb -tui ./a.out\n(gdb) layout asm\n(gdb) start\n(fiddling about for a long time)\n(gdb) tui d\n(gdb) bt\n#0  std::atomic<std::shared_ptr<std::chrono::tzdb_list::_Node> >::~atomic (this=0x7ffff7e62810 <std::chrono::tzdb_list::_Node::_S_head_owner>, __in_chrg=<optimized out>)\n    at /usr/src/debug/gcc-14.2.1-3.fc40.x86_64/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/shared_ptr_atomic.h:630\n#1  0x00007ffff7a51e60 in __cxa_finalize (d=0x7ffff7e52200) at cxa_finalize.c:82\n#2  0x00007ffff7cb4947 in __do_global_dtors_aux () from /lib64/libstdc++.so.6\n#3  0x00007fffffffd750 in ?? ()\n#4  0x00007ffff7fc90f2 in _dl_call_fini (closure_map=0x7ffff7f8a000) at dl-call_fini.c:43"
  },
  {
    "url": "https://stackoverflow.com/questions/2027991/list-of-standard-header-files-in-c-and-c",
    "body": "<aio.h>        <libgen.h>       <spawn.h>         <sys/time.h>\n<arpa/inet.h>  <limits.h>       <stdarg.h>        <sys/times.h>\n<assert.h>     <locale.h>       <stdbool.h>       <sys/types.h>\n<complex.h>    <math.h>         <stddef.h>        <sys/uio.h>\n<cpio.h>       <monetary.h>     <stdint.h>        <sys/un.h>\n<ctype.h>      <mqueue.h>       <stdio.h>         <sys/utsname.h>\n<dirent.h>     <ndbm.h>         <stdlib.h>        <sys/wait.h>\n<dlfcn.h>      <net/if.h>       <string.h>        <syslog.h>\n<errno.h>      <netdb.h>        <strings.h>       <tar.h>\n<fcntl.h>      <netinet/in.h>   <stropts.h>       <termios.h>\n<fenv.h>       <netinet/tcp.h>  <sys/ipc.h>       <tgmath.h>\n<float.h>      <nl_types.h>     <sys/mman.h>      <time.h>\n<fmtmsg.h>     <poll.h>         <sys/msg.h>       <trace.h>\n<fnmatch.h>    <pthread.h>      <sys/resource.h>  <ulimit.h>\n<ftw.h>        <pwd.h>          <sys/select.h>    <unistd.h>\n<glob.h>       <regex.h>        <sys/sem.h>       <utime.h>\n<grp.h>        <sched.h>        <sys/shm.h>       <utmpx.h>\n<iconv.h>      <search.h>       <sys/socket.h>    <wchar.h>\n<inttypes.h>   <semaphore.h>    <sys/stat.h>      <wctype.h>\n<iso646.h>     <setjmp.h>       <sys/statvfs.h>   <wordexp.h>\n<langinfo.h>   <signal.h>"
  },
  {
    "url": "https://stackoverflow.com/questions/2027991/list-of-standard-header-files-in-c-and-c",
    "body": "<algorithm>           <initializer_list>  <numeric>           <system_error>\n<array>               <iomanip>           <ostream>           <thread>\n<atomic>              <ios>               <queue>             <tuple>\n<bitset>              <iosfwd>            <random>            <type_traits>\n<chrono>              <iostream>          <ratio>             <typeindex>\n<codecvt>             <istream>           <regex>             <typeinfo>\n<complex>             <iterator>          <scoped_allocator>  <unordered_map>\n<condition_variable>  <limits>            <set>               <unordered_set>\n<deque>               <list>              <sstream>           <utility>\n<exception>           <locale>            <stack>             <valarray>\n<forward_list>        <map>               <stdexcept>         <vector>\n<fstream>             <memory>            <streambuf>\n<functional>          <mutex>             <string>\n<future>              <new>               <strstream>"
  },
  {
    "url": "https://stackoverflow.com/questions/2027991/list-of-standard-header-files-in-c-and-c",
    "body": "<algorithm>           <initializer_list>  <numeric>           <strstream>\n<array>               <iomanip>           <ostream>           <system_error>\n<atomic>              <ios>               <queue>             <thread>\n<bitset>              <iosfwd>            <random>            <tuple>\n<chrono>              <iostream>          <ratio>             <type_traits>\n<codecvt>             <istream>           <regex>             <typeindex>\n<complex>             <iterator>          <scoped_allocator>  <typeinfo>\n<condition_variable>  <limits>            <set>               <unordered_map>\n<deque>               <list>              <shared_mutex>      <unordered_set>\n<exception>           <locale>            <sstream>           <utility>\n<forward_list>        <map>               <stack>             <valarray>\n<fstream>             <memory>            <stdexcept>         <vector>\n<functional>          <mutex>             <streambuf>\n<future>              <new>               <string>"
  },
  {
    "url": "https://stackoverflow.com/questions/2027991/list-of-standard-header-files-in-c-and-c",
    "body": "<algorithm>           <future>            <numeric>           <strstream>\n<any>                 <initializer_list>  <optional>          <system_error>\n<array>               <iomanip>           <ostream>           <thread>\n<atomic>              <ios>               <queue>             <tuple>\n<bitset>              <iosfwd>            <random>            <type_traits>\n<chrono>              <iostream>          <ratio>             <typeindex>\n<codecvt>             <istream>           <regex>             <typeinfo>\n<complex>             <iterator>          <scoped_allocator>  <unordered_map>\n<condition_variable>  <limits>            <set>               <unordered_set>\n<deque>               <list>              <shared_mutex>      <utility>\n<exception>           <locale>            <sstream>           <valarray>\n<execution>           <map>               <stack>             <variant>\n<filesystem>          <memory>            <stdexcept>         <vector>\n<forward_list>        <memory_resource>   <streambuf>\n<fstream>             <mutex>             <string>\n<functional>          <new>               <string_view>"
  },
  {
    "url": "https://stackoverflow.com/questions/2027991/list-of-standard-header-files-in-c-and-c",
    "body": "<algorithm>           <csignal>           <istream>           <span>\n<any>                 <cstdarg>           <iterator>          <sstream>\n<array>               <cstddef>           <latch>             <stack>\n<atomic>              <cstdint>           <limits>            <stacktrace>\n<barrier>             <cstdio>            <list>              <stdexcept>\n<bit>                 <cstdlib>           <locale>            <stop_token>\n<bitset>              <cstring>           <map>               <streambuf>\n<cassert>             <ctime>             <memory>            <string>\n<cctype>              <cuchar>            <memory_resource>   <string_view>\n<cerrno>              <cwchar>            <mutex>             <strstream>\n<cfenv>               <cwctype>           <new>               <syncstream>\n<cfloat>              <deque>             <numbers>           <system_error>\n<charconv>            <exception>         <numeric>           <thread>\n<chrono>              <execution>         <optional>          <tuple>\n<cinttypes>           <filesystem>        <ostream>           <type_traits>\n<climits>             <format>            <queue>             <typeindex>\n<clocale>             <forward_list>      <random>            <typeinfo>\n<cmath>               <fstream>           <ranges>            <unordered_map>\n<codecvt>             <functional>        <ratio>             <unordered_set>\n<compare>             <future>            <regex>             <utility>\n<complex>             <initializer_list>  <scoped_allocator>  <valarray>\n<concepts>            <iomanip>           <semaphore>         <variant>\n<condition_variable>  <ios>               <set>               <vector>\n<coroutine>           <iosfwd>            <shared_mutex>      <version>\n<csetjmp>             <iostream>          <source_location>"
  },
  {
    "url": "https://stackoverflow.com/questions/2027991/list-of-standard-header-files-in-c-and-c",
    "body": "<algorithm>           <cstddef>           <istream>           <span>\n<any>                 <cstdint>           <iterator>          <spanstream>\n<array>               <cstdio>            <latch>             <sstream>\n<atomic>              <cstdlib>           <limits>            <stack>\n<barrier>             <cstring>           <list>              <stacktrace>\n<bit>                 <ctime>             <locale>            <stdexcept>\n<bitset>              <cuchar>            <map>               <stdfloat>\n<cassert>             <cwchar>            <mdspan>            <stop_token>\n<cctype>              <cwctype>           <memory>            <streambuf>\n<cerrno>              <deque>             <memory_resource>   <string>\n<cfenv>               <exception>         <mutex>             <string_view>\n<cfloat>              <execution>         <new>               <strstream>\n<charconv>            <expected>          <numbers>           <syncstream>\n<chrono>              <filesystem>        <numeric>           <system_error>\n<cinttypes>           <flat_map>          <optional>          <thread>\n<climits>             <flat_set>          <ostream>           <tuple>\n<clocale>             <format>            <print>             <type_traits>\n<cmath>               <forward_list>      <queue>             <typeindex>\n<codecvt>             <fstream>           <random>            <typeinfo>\n<compare>             <functional>        <ranges>            <unordered_map>\n<complex>             <future>            <ratio>             <unordered_set>\n<concepts>            <generator>         <regex>             <utility>\n<condition_variable>  <initializer_list>  <scoped_allocator>  <valarray>\n<coroutine>           <iomanip>           <semaphore>         <variant>\n<csetjmp>             <ios>               <set>               <vector>\n<csignal>             <iosfwd>            <shared_mutex>      <version>\n<cstdarg>             <iostream>          <source_location>"
  },
  {
    "url": "https://stackoverflow.com/questions/51031060/are-c17-parallel-algorithms-implemented-already",
    "body": "# Install GCC 9\nsudo add-apt-repository ppa:ubuntu-toolchain-r/test\nsudo apt-get update\nsudo apt-get install gcc-9 g++-9\n# Compile libtbb from source.\nsudo apt-get build-dep libtbb-dev\ngit clone https://github.com/intel/tbb\ncd tbb\ngit checkout 2019_U9\nmake -j `nproc`\nTBB=\"$(pwd)\"\nTBB_RELEASE=\"${TBB}/build/linux_intel64_gcc_cc7.4.0_libc2.27_kernel4.15.0_release\"\n# Use them to compile our test program.\ng++-9 -ggdb3 -O3 -std=c++17 -Wall -Wextra -pedantic -I \"${TBB}/include\" -L\n\"${TBB_RELEASE}\" -Wl,-rpath,\"${TBB_RELEASE}\" -o main.out main.cpp -ltbb\n./main.out"
  },
  {
    "url": "https://stackoverflow.com/questions/51031060/are-c17-parallel-algorithms-implemented-already",
    "body": "#include <algorithm>\n#include <cassert>\n#include <chrono>\n#include <execution>\n#include <random>\n#include <iostream>\n#include <vector>\nint main(int argc, char **argv) {\n    using clk = std::chrono::high_resolution_clock;\n    decltype(clk::now()) start, end;\n    std::vector<unsigned long long> input_parallel, input_serial;\n    unsigned int seed;\n    unsigned long long n;\n    // CLI arguments;\n    std::uniform_int_distribution<uint64_t> zero_ull_max(0);\n    if (argc > 1) {\n        n = std::strtoll(argv[1], NULL, 0);\n    } else {\n        n = 10;\n    }\n    if (argc > 2) {\n        seed = std::stoi(argv[2]);\n    } else {\n        seed = std::random_device()();\n    }\n    std::mt19937 prng(seed);\n    for (unsigned long long i = 0; i < n; ++i) {\n        input_parallel.push_back(zero_ull_max(prng));\n    }\n    input_serial = input_parallel;\n    // Sort and time parallel.\n    start = clk::now();\n    std::sort(std::execution::par_unseq, input_parallel.begin(), input_parallel.end());\n    end = clk::now();\n    std::cout << \"parallel \" << std::chrono::duration<float>(end - start).count() << \" s\" << std::endl;\n    // Sort and time serial.\n    start = clk::now();\n    std::sort(std::execution::seq, input_serial.begin(), input_serial.end());\n    end = clk::now();\n    std::cout << \"serial \" << std::chrono::duration<float>(end - start).count() << \" s\" << std::endl;\n    assert(input_parallel == input_serial);\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/51031060/are-c17-parallel-algorithms-implemented-already",
    "body": "In file included from /usr/include/c++/9/pstl/parallel_backend.h:14,\n                 from /usr/include/c++/9/pstl/algorithm_impl.h:25,\n                 from /usr/include/c++/9/pstl/glue_execution_defs.h:52,\n                 from /usr/include/c++/9/execution:32,\n                 from parallel_sort.cpp:4:\n/usr/include/c++/9/pstl/parallel_backend_tbb.h:19:10: fatal error: tbb/blocked_range.h: No such file or directory\n   19 | #include <tbb/blocked_range.h>\n      |          ^~~~~~~~~~~~~~~~~~~~~\ncompilation terminated."
  },
  {
    "url": "https://stackoverflow.com/questions/983999/simple-3x3-matrix-inverse-code-c",
    "body": "double determinant =    +A(0,0)*(A(1,1)*A(2,2)-A(2,1)*A(1,2))\n                        -A(0,1)*(A(1,0)*A(2,2)-A(1,2)*A(2,0))\n                        +A(0,2)*(A(1,0)*A(2,1)-A(1,1)*A(2,0));\ndouble invdet = 1/determinant;\nresult(0,0) =  (A(1,1)*A(2,2)-A(2,1)*A(1,2))*invdet;\nresult(1,0) = -(A(0,1)*A(2,2)-A(0,2)*A(2,1))*invdet;\nresult(2,0) =  (A(0,1)*A(1,2)-A(0,2)*A(1,1))*invdet;\nresult(0,1) = -(A(1,0)*A(2,2)-A(1,2)*A(2,0))*invdet;\nresult(1,1) =  (A(0,0)*A(2,2)-A(0,2)*A(2,0))*invdet;\nresult(2,1) = -(A(0,0)*A(1,2)-A(1,0)*A(0,2))*invdet;\nresult(0,2) =  (A(1,0)*A(2,1)-A(2,0)*A(1,1))*invdet;\nresult(1,2) = -(A(0,0)*A(2,1)-A(2,0)*A(0,1))*invdet;\nresult(2,2) =  (A(0,0)*A(1,1)-A(1,0)*A(0,1))*invdet;"
  },
  {
    "url": "https://stackoverflow.com/questions/77681881/why-are-all-of-my-this-pointers-the-same-value",
    "body": "#include <iostream>\n#include <vector>\nstruct myclass {\n    myclass() {\n        std::cout << \"Construct: \" << this << std::endl;\n    }\n    myclass(const myclass& other) {\n        std::cout << \"Copy: \" << this << std::endl;\n    }\n    void print() const {\n        std::cout << \"Print: \" << this << std::endl;\n    }\n};\nint main() {\n    std::vector<myclass> v;\n    v.reserve(10);\n    for (uint32_t i = 0; i < 10; i++)\n        v.push_back(myclass());\n    std::cout << \"\\n\";\n    for (auto &x : v)\n        x.print();\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/77681881/why-are-all-of-my-this-pointers-the-same-value",
    "body": "Construct: 0x7fffed870898\nCopy: 0x7fffe5b3de70\nConstruct: 0x7fffed870898\nCopy: 0x7fffe5b3de71\nConstruct: 0x7fffed870898\nCopy: 0x7fffe5b3de72\nConstruct: 0x7fffed870898\nCopy: 0x7fffe5b3de73\nConstruct: 0x7fffed870898\nCopy: 0x7fffe5b3de74\nConstruct: 0x7fffed870898\nCopy: 0x7fffe5b3de75\nConstruct: 0x7fffed870898\nCopy: 0x7fffe5b3de76\nConstruct: 0x7fffed870898\nCopy: 0x7fffe5b3de77\nConstruct: 0x7fffed870898\nCopy: 0x7fffe5b3de78\nConstruct: 0x7fffed870898\nCopy: 0x7fffe5b3de79\nPrint: 0x7fffe5b3de70\nPrint: 0x7fffe5b3de71\nPrint: 0x7fffe5b3de72\nPrint: 0x7fffe5b3de73\nPrint: 0x7fffe5b3de74\nPrint: 0x7fffe5b3de75\nPrint: 0x7fffe5b3de76\nPrint: 0x7fffe5b3de77\nPrint: 0x7fffe5b3de78\nPrint: 0x7fffe5b3de79"
  },
  {
    "url": "https://stackoverflow.com/questions/77681881/why-are-all-of-my-this-pointers-the-same-value",
    "body": "#include <iostream>\n#include <vector>\nstruct myclass {\n    myclass() {\n        std::cout << \"Construct: \" << this << std::endl;\n    }\n    myclass(const myclass& other) {\n        std::cout << \"Copy: \" << this << std::endl;\n    }\n    void print() const {\n        std::cout << \"Print: \" << this << std::endl;\n    }\n};\nint main() {\n    std::vector<myclass> v;\n    v.reserve(10);\n    for (uint32_t i = 0; i < 5; i++)\n        v.push_back(myclass());\n    for (uint32_t i = 0; i < 5; i++)\n        v.emplace_back();\n    std::cout << \"\\n\";\n    for (auto &x : v)\n        x.print();\n\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/77681881/why-are-all-of-my-this-pointers-the-same-value",
    "body": "Construct: 0x7fffc5e7d958\nCopy: 0x7fffbd93fe70\nConstruct: 0x7fffc5e7d958\nCopy: 0x7fffbd93fe71\nConstruct: 0x7fffc5e7d958\nCopy: 0x7fffbd93fe72\nConstruct: 0x7fffc5e7d958\nCopy: 0x7fffbd93fe73\nConstruct: 0x7fffc5e7d958\nCopy: 0x7fffbd93fe74\nConstruct: 0x7fffbd93fe75\nConstruct: 0x7fffbd93fe76\nConstruct: 0x7fffbd93fe77\nConstruct: 0x7fffbd93fe78\nConstruct: 0x7fffbd93fe79\nPrint: 0x7fffbd93fe70\nPrint: 0x7fffbd93fe71\nPrint: 0x7fffbd93fe72\nPrint: 0x7fffbd93fe73\nPrint: 0x7fffbd93fe74\nPrint: 0x7fffbd93fe75\nPrint: 0x7fffbd93fe76\nPrint: 0x7fffbd93fe77\nPrint: 0x7fffbd93fe78\nPrint: 0x7fffbd93fe79"
  },
  {
    "url": "https://stackoverflow.com/questions/68673443/is-there-a-way-to-avoid-implicit-conversion-to-void",
    "body": "#include <iostream>\n#include <string>\n#include <type_traits>\nvoid api(void* p) { // your original API\n    std::cout << \"void* \" << p << '\\n';\n}\ntemplate<class T>\nvoid api_wrapper(T* p) { // your wrapper\n    // let constness fail in the original api instead of in the static_assert:\n    using type = std::remove_const_t<T>*;\n    static_assert(\n        // add your approved types here\n        std::is_convertible_v<type, std::ostream*> ||\n        std::is_convertible_v<type, std::string*>,\n        \"Not an approved type\"\n    );\n    api(p);\n}\nint main() {\n    std::string foo;\n    api_wrapper(&std::cout);\n    api_wrapper(&foo);\n    //api_wrapper(&std::cin); // compile time error \"Not an approved type\"\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/13830158/how-to-write-a-trait-which-checks-whether-a-type-is-iterable",
    "body": "namespace detail\n{\n    // To allow ADL with custom begin/end\n    using std::begin;\n    using std::end;\n    template <typename T>\n    auto is_iterable_impl(int)\n    -> decltype (\n        begin(std::declval<T&>()) != end(std::declval<T&>()), // begin/end and operator !=\n        void(), // Handle evil operator ,\n        ++std::declval<decltype(begin(std::declval<T&>()))&>(), // operator ++\n        void(*begin(std::declval<T&>())), // operator*\n        std::true_type{});\n    template <typename T>\n    std::false_type is_iterable_impl(...);\n}\ntemplate <typename T>\nusing is_iterable = decltype(detail::is_iterable_impl<T>(0));"
  },
  {
    "url": "https://stackoverflow.com/questions/76969417/why-is-char-int-promotion-but-char-short-is-conversion-but-not-promo",
    "body": "// A conversion sequence from char -> int is empty\n// because char -> int is a promotion, and so it doesn't contribute\n// to the conversion sequence.\nvoid f(int);\n// A conversion sequence from char -> short has length 1\n// because char -> short is not a promotion.\nvoid f(short);\nint main() {\n    // Not an ambiguous call; calls f(int), because the conversion sequence\n    // for this call is shorter.\n    // Note that in C, a character literal has type 'int', not 'char', so\n    // it is more symmetrical to favor 'int' whenever possible.\n    f('x');\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/24645880/set-cpu-affinity-when-create-a-thread",
    "body": " // g++ ./test.cpp  -lpthread && ./a.out\n//\n#include <thread>\n#include <vector>\n#include <iostream>\n#include <mutex>\n#include <sched.h>\n#include <pthread.h>\nint main(int argc, const char** argv) {\n  constexpr unsigned num_threads = 4;\n  // A mutex ensures orderly access to std::cout from multiple threads.\n  std::mutex iomutex;\n  std::vector<std::thread> threads(num_threads);\n  for (unsigned i = 0; i < num_threads; ++i) {\n    threads[i] = std::thread([&iomutex, i,&threads] {\n      // Create a cpu_set_t object representing a set of CPUs. Clear it and mark\n      // only CPU i as set.\n      cpu_set_t cpuset;\n      CPU_ZERO(&cpuset);\n      CPU_SET(i, &cpuset);\n      int rc = pthread_setaffinity_np(threads[i].native_handle(),\n                                      sizeof(cpu_set_t), &cpuset);\n      if (rc != 0) {\n        std::cerr << \"Error calling pthread_setaffinity_np: \" << rc << \"\\n\";\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(20));\n      while (1) {\n        {\n          // Use a lexical scope and lock_guard to safely lock the mutex only\n          // for the duration of std::cout usage.\n          std::lock_guard<std::mutex> iolock(iomutex);\n          std::cout << \"Thread #\" << i << \": on CPU \" << sched_getcpu() << \"\\n\";\n        }\n        // Simulate important work done by the tread by sleeping for a bit...\n        std::this_thread::sleep_for(std::chrono::milliseconds(900));\n      }\n    });\n  }\n  for (auto& t : threads) {\n    t.join();\n  }\n  return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/2212776/overload-handling-of-stdendl",
    "body": "#include <iostream>\n#include <sstream>\nclass MyStream: public std::ostream\n{\n    // Write a stream buffer that prefixes each line with Plop\n    class MyStreamBuf: public std::stringbuf\n    {\n        std::ostream&   output;\n        public:\n            MyStreamBuf(std::ostream& str)\n                :output(str)\n            {}\n            ~MyStreamBuf() {\n                if (pbase() != pptr()) {\n                    putOutput();\n                }\n            }\n\n        // When we sync the stream with the output.\n        // 1) Output Plop then the buffer\n        // 2) Reset the buffer\n        // 3) flush the actual output stream we are using.\n        virtual int sync() {\n            putOutput();\n            return 0;\n        }\n        void putOutput() {\n            // Called by destructor.\n            // destructor can not call virtual methods.\n            output << \"[blah]\" << str();\n            str(\"\");\n            output.flush();\n        }\n    };\n    // My Stream just uses a version of my special buffer\n    MyStreamBuf buffer;\n    public:\n        MyStream(std::ostream& str)\n            :std::ostream(&buffer)\n            ,buffer(str)\n        {\n        }\n};\nint main()\n{\n    MyStream myStream(std::cout);\n    myStream << 1 << 2 << 3 << std::endl << 5 << 6 << std::endl << 7 << 8 << std::endl;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/17645167/implementing-sse-4-2s-crc32c-in-software",
    "body": "/* crc32c.c -- compute CRC-32C using the Intel crc32 instruction\n * Copyright (C) 2013, 2021, 2023 Mark Adler\n * Version 1.3  7 Dec 2023  Mark Adler\n */\n/*\n  This software is provided 'as-is', without any express or implied\n  warranty. In no event will the author be held liable for any damages\n  arising from the use of this software.\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n  Mark Adler\n  madler@alumni.caltech.edu\n */\n/* Version History:\n 1.0  10 Feb 2013  First version\n 1.1  31 May 2021  Correct register constraints on assembly instructions\n                   Include pre-computed tables to avoid use of pthreads\n                   Return zero for the CRC when buf is NULL, as initial value\n 1.2   5 Jun 2021  Make tables constant\n 1.3   7 Dec 2023  Improve register constraints for optimization\n */\n// Use hardware CRC instruction on Intel SSE 4.2 processors. This computes a\n// CRC-32C, *not* the CRC-32 used by Ethernet and zip, gzip, etc. A software\n// version is provided as a fall-back, as well as for speed comparisons.\n#include <stddef.h>\n#include <stdint.h>\n// Tables for CRC word-wise calculation, definitions of LONG and SHORT, and CRC\n// shifts by LONG and SHORT bytes.\n#include \"crc32c.h\"\n// Table-driven software version as a fall-back. This is about 15 times slower\n// than using the hardware instructions. This assumes little-endian integers,\n// as is the case on Intel processors that the assembler code here is for.\nstatic uint32_t crc32c_sw(uint32_t crc, void const *buf, size_t len) {\n    if (buf == NULL)\n        return 0;\n    unsigned char const *data = buf;\n    while (len && ((uintptr_t)data & 7) != 0) {\n        crc = (crc >> 8) ^ crc32c_table[0][(crc ^ *data++) & 0xff];\n        len--;\n    }\n    size_t n = len >> 3;\n    for (size_t i = 0; i < n; i++) {\n        uint64_t word = crc ^ ((uint64_t const *)data)[i];\n        crc = crc32c_table[7][word & 0xff] ^\n              crc32c_table[6][(word >> 8) & 0xff] ^\n              crc32c_table[5][(word >> 16) & 0xff] ^\n              crc32c_table[4][(word >> 24) & 0xff] ^\n              crc32c_table[3][(word >> 32) & 0xff] ^\n              crc32c_table[2][(word >> 40) & 0xff] ^\n              crc32c_table[1][(word >> 48) & 0xff] ^\n              crc32c_table[0][word >> 56];\n    }\n    data += n << 3;\n    len &= 7;\n    while (len) {\n        len--;\n        crc = (crc >> 8) ^ crc32c_table[0][(crc ^ *data++) & 0xff];\n    }\n    return crc;\n}\n// Apply the zeros operator table to crc.\nstatic uint32_t crc32c_shift(uint32_t const zeros[][256], uint32_t crc) {\n    return zeros[0][crc & 0xff] ^ zeros[1][(crc >> 8) & 0xff] ^\n           zeros[2][(crc >> 16) & 0xff] ^ zeros[3][crc >> 24];\n}\n// Compute CRC-32C using the Intel hardware instruction. Three crc32q\n// instructions are run in parallel on a single core. This gives a\n// factor-of-three speedup over a single crc32q instruction, since the\n// throughput of that instruction is one cycle, but the latency is three\n// cycles.\nstatic uint32_t crc32c_hw(uint32_t crc, void const *buf, size_t len) {\n    if (buf == NULL)\n        return 0;\n    // Pre-process the crc.\n    uint64_t crc0 = crc ^ 0xffffffff;\n    // Compute the crc for up to seven leading bytes, bringing the data pointer\n    // to an eight-byte boundary.\n    unsigned char const *next = buf;\n    while (len && ((uintptr_t)next & 7) != 0) {\n        __asm__(\"crc32b\\t%1, %0\"\n                : \"+r\"(crc0)\n                : \"m\"(*next));\n        next++;\n        len--;\n    }\n    // Compute the crc on sets of LONG*3 bytes, making use of the three-cycle\n    // latency and one-cycle throughput of a single core.\n    while (len >= LONG*3) {\n        uint64_t crc1 = 0;\n        uint64_t crc2 = 0;\n        unsigned char const *end = next + LONG;\n        do {\n            __asm__(\"crc32q\\t%3, %0\\n\\t\"\n                    \"crc32q\\t%4, %1\\n\\t\"\n                    \"crc32q\\t%5, %2\"\n                    : \"+r\"(crc0), \"+r\"(crc1), \"+r\"(crc2)\n                    : \"m\"(*(uint64_t const *)next),\n                      \"m\"(*(uint64_t const *)(next + LONG)),\n                      \"m\"(*(uint64_t const *)(next + 2*LONG)));\n            next += 8;\n        } while (next < end);\n        crc0 = crc32c_shift(crc32c_long, crc0) ^ crc1;\n        crc0 = crc32c_shift(crc32c_long, crc0) ^ crc2;\n        next += LONG*2;\n        len -= LONG*3;\n    }\n    // Do the same thing, but now on SHORT*3 blocks for the remaining data less\n    // than a LONG*3 block.\n    while (len >= SHORT*3) {\n        uint64_t crc1 = 0;\n        uint64_t crc2 = 0;\n        unsigned char const *end = next + SHORT;\n        do {\n            __asm__(\"crc32q\\t%3, %0\\n\\t\"\n                    \"crc32q\\t%4, %1\\n\\t\"\n                    \"crc32q\\t%5, %2\"\n                    : \"+r\"(crc0), \"+r\"(crc1), \"+r\"(crc2)\n                    : \"m\"(*(uint64_t const *)next),\n                      \"m\"(*(uint64_t const *)(next + SHORT)),\n                      \"m\"(*(uint64_t const *)(next + 2*SHORT)));\n            next += 8;\n        } while (next < end);\n        crc0 = crc32c_shift(crc32c_short, crc0) ^ crc1;\n        crc0 = crc32c_shift(crc32c_short, crc0) ^ crc2;\n        next += SHORT*2;\n        len -= SHORT*3;\n    }\n    // Compute the crc on the remaining eight-byte units less than a SHORT*3\n    // block.\n    unsigned char const *end = next + (len - (len & 7));\n    while (next < end) {\n        __asm__(\"crc32q\\t%1, %0\"\n                : \"+r\"(crc0)\n                : \"m\"(*(uint64_t const *)next));\n        next += 8;\n    }\n    len &= 7;\n    // Compute the crc for up to seven trailing bytes.\n    while (len) {\n        __asm__(\"crc32b\\t%1, %0\"\n                : \"+r\"(crc0)\n                : \"m\"(*next));\n        next++;\n        len--;\n    }\n    // Return the crc, post-processed.\n    return ~(uint32_t)crc0;\n}\n// Check for SSE 4.2. SSE 4.2 was first supported in Nehalem processors\n// introduced in November, 2008. This does not check for the existence of the\n// cpuid instruction itself, which was introduced on the 486SL in 1992, so this\n// will fail on earlier x86 processors. cpuid works on all Pentium and later\n// processors.\n#define SSE42(have) \\\n    do { \\\n        uint32_t eax, ecx; \\\n        eax = 1; \\\n        __asm__(\"cpuid\" \\\n                : \"=c\"(ecx) \\\n                : \"a\"(eax) \\\n                : \"%ebx\", \"%edx\"); \\\n        (have) = (ecx >> 20) & 1; \\\n    } while (0)\n// Compute a CRC-32C. If the crc32 instruction is available, use the hardware\n// version. Otherwise, use the software version.\nuint32_t crc32c(uint32_t crc, void const *buf, size_t len) {\n    int sse42;\n    SSE42(sse42);\n    return sse42 ? crc32c_hw(crc, buf, len) : crc32c_sw(crc, buf, len);\n}\n#ifdef TEST\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#define SIZE (262144*3)\n#define CHUNK SIZE\nint main(int argc, char **argv) {\n    (void)argv;\n    uint32_t crc = 0;\n    char *buf = malloc(SIZE);\n    if (buf == NULL) {\n        fputs(\"out of memory\", stderr);\n        return 1;\n    }\n    ssize_t got;\n    while ((got = read(0, buf, SIZE)) > 0) {\n        size_t off = 0;\n        do {\n            size_t n = (size_t)got - off;\n            if (n > CHUNK)\n                n = CHUNK;\n            crc = argc > 1 ? crc32c_sw(crc, buf + off, n) :\n                             crc32c(crc, buf + off, n);\n            off += n;\n        } while (off < (size_t)got);\n    }\n    free(buf);\n    if (got == -1) {\n        fputs(\"read error\\n\", stderr);\n        return 1;\n    }\n    printf(\"%08x\\n\", crc);\n    return 0;\n}\n#endif /* TEST */"
  },
  {
    "url": "https://stackoverflow.com/questions/17645167/implementing-sse-4-2s-crc32c-in-software",
    "body": "// Generate crc32c.h for crc32c.c.\n#include <stdio.h>\n#include <stdint.h>\n#define LONG 8192\n#define SHORT 256\n// Print a 2-D table of four-byte constants in hex.\nstatic void print_table(uint32_t *tab, size_t rows, size_t cols, char *name) {\n    printf(\"static uint32_t const %s[][%zu] = {\\n\", name, cols);\n    size_t end = rows * cols;\n    size_t k = 0;\n    for (;;) {\n        fputs(\"   {\", stdout);\n        size_t n = 0, j = 0;\n        for (;;) {\n            printf(\"0x%08x\", tab[k + n]);\n            if (++n == cols)\n                break;\n            putchar(',');\n            if (++j == 6) {\n                fputs(\"\\n   \", stdout);\n                j = 0;\n            }\n            putchar(' ');\n        }\n        k += cols;\n        if (k == end)\n            break;\n        puts(\"},\");\n    }\n    puts(\"}\\n};\");\n}\n/* CRC-32C (iSCSI) polynomial in reversed bit order. */\n#define POLY 0x82f63b78\nstatic void crc32c_word_table(void) {\n    uint32_t table[8][256];\n    // Generate byte-wise table.\n    for (unsigned n = 0; n < 256; n++) {\n        uint32_t crc = ~n;\n        for (unsigned k = 0; k < 8; k++)\n            crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;\n        table[0][n] = ~crc;\n    }\n    // Use byte-wise table to generate word-wise table.\n    for (unsigned n = 0; n < 256; n++) {\n        uint32_t crc = ~table[0][n];\n        for (unsigned k = 1; k < 8; k++) {\n            crc = table[0][crc & 0xff] ^ (crc >> 8);\n            table[k][n] = ~crc;\n        }\n    }\n    // Print table.\n    print_table(table[0], 8, 256, \"crc32c_table\");\n}\n// Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC\n// polynomial. For speed, this requires that a not be zero.\nstatic uint32_t multmodp(uint32_t a, uint32_t b) {\n    uint32_t prod = 0;\n    for (;;) {\n        if (a & 0x80000000) {\n            prod ^= b;\n            if ((a & 0x7fffffff) == 0)\n                break;\n        }\n        a <<= 1;\n        b = b & 1 ? (b >> 1) ^ POLY : b >> 1;\n    }\n    return prod;\n}\n/* Take a length and build four lookup tables for applying the zeros operator\n   for that length, byte-by-byte, on the operand. */\nstatic void crc32c_zero_table(size_t len, char *name) {\n    // Generate operator for len zeros.\n    uint32_t op = 0x80000000;               // 1 (x^0)\n    uint32_t sq = op >> 4;                  // x^4\n    while (len) {\n        sq = multmodp(sq, sq);              // x^2^(k+3), k == len bit position\n        if (len & 1)\n            op = multmodp(sq, op);\n        len >>= 1;\n    }\n    // Generate table to update each byte of a CRC using op.\n    uint32_t table[4][256];\n    for (unsigned n = 0; n < 256; n++) {\n        table[0][n] = multmodp(op, n);\n        table[1][n] = multmodp(op, n << 8);\n        table[2][n] = multmodp(op, n << 16);\n        table[3][n] = multmodp(op, n << 24);\n    }\n    // Print the table to stdout.\n    print_table(table[0], 4, 256, name);\n}\nint main(void) {\n    puts(\n\"// crc32c.h\\n\"\n\"// Tables and constants for crc32c.c software and hardware calculations.\\n\"\n\"\\n\"\n\"// Table for a 64-bits-at-a-time software CRC-32C calculation. This table\\n\"\n\"// has built into it the pre and post bit inversion of the CRC.\"\n    );\n    crc32c_word_table();\n    puts(\n\"\\n// Block sizes for three-way parallel crc computation.  LONG and SHORT\\n\"\n\"// must both be powers of two.\"\n        );\n    printf(\"#define LONG %d\\n\", LONG);\n    printf(\"#define SHORT %d\\n\", SHORT);\n    puts(\n\"\\n// Table to shift a CRC-32C by LONG bytes.\"\n    );\n    crc32c_zero_table(8192, \"crc32c_long\");\n    puts(\n\"\\n// Table to shift a CRC-32C by SHORT bytes.\"\n    );\n    crc32c_zero_table(256, \"crc32c_short\");\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/12560291/set-back-default-floating-point-print-precision-in-c",
    "body": "c++\n#include <ios>\n#include <iostream>\n#include <iomanip>\nint main (void) {\n    double pi = 3.141592653590;\n    std::streamsize ss = std::cout.precision();\n    std::cout << \"Initial precision = \" << ss << '\\n';\n    std::cout << \"Value = \" << pi << '\\n';\n    std::cout.precision (10);\n    std::cout << \"Longer value = \" << pi << '\\n';\n    std::cout.precision (ss);\n    std::cout << \"Original value = \" << pi << '\\n';\n    std::cout << \"Longer and original value = \"\n        << std::setprecision(10) << pi << ' '\n        << std::setprecision(ss) << pi << '\\n';\n    std::cout << \"Original value = \" << pi << '\\n';\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/62910867/how-to-run-tests-and-debug-google-test-project-in-vs-code",
    "body": "cmake_minimum_required(VERSION 3.12) # version can be different\nset(GOOGLETEST_VERSION 1.15.2)\nproject(my_cpp_project) #name of your project\nenable_testing() #to  discover tests in test explorer\nadd_subdirectory(googletest) # add googletest subdirectory\ninclude_directories(googletest/include) # this is so we can #include <gtest/gtest.h>\nadd_executable(mytests mytests.cpp) # add this executable\ntarget_link_libraries(mytests PRIVATE gtest) # link google test to this executable\ninclude(GoogleTest)\ngtest_discover_tests(mytests) # discovers tests by asking the compiled test executable to enumerate its tests"
  },
  {
    "url": "https://stackoverflow.com/questions/57621168/what-are-the-mechanics-of-coroutines-in-c20",
    "body": "struct Promise\n{\n    Promise() : val (-1), done (false) {}\n    std::experimental::coroutines_v1::suspend_never initial_suspend() { return {}; }\n    std::experimental::coroutines_v1::suspend_always final_suspend() {\n        this->done = true;\n        return {};\n    }\n    Future get_return_object();\n    void unhandled_exception() { abort(); }\n    void return_value(int val) {\n        this->val = val;\n    }\n\n    int val;\n    bool done;\n};\nFuture Promise::get_return_object()\n{\n    return Future { Handle::from_promise(*this) };\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/57621168/what-are-the-mechanics-of-coroutines-in-c20",
    "body": "template <typename _Promise = void>\nclass coroutine_handle;\ntemplate <>\nclass coroutine_handle<void> {\npublic:\n    void operator()() { resume(); }\n    //resumes a suspended coroutine\n    void resume();\n    //destroys a suspended coroutine\n    void destroy();\n    //determines whether the coroutine is finished\n    bool done() const;\n};\ntemplate <Promise>\nclass coroutine_handle : public coroutine_handle<void>\n{\n    //gets the promise from the handle\n    Promise& promise() const;\n    //gets the handle from the promise\n    static coroutine_handle from_promise(Promise& promise) no_except;\n};"
  },
  {
    "url": "https://stackoverflow.com/questions/57621168/what-are-the-mechanics-of-coroutines-in-c20",
    "body": "#include <experimental/coroutine>\n#include <iostream>\nstruct Promise;\nclass Future;\nusing Handle = std::experimental::coroutines_v1::coroutine_handle<Promise>;\nstruct Promise\n{\n    Promise() : val (-1), done (false) {}\n    std::experimental::coroutines_v1::suspend_never initial_suspend() { return {}; }\n    std::experimental::coroutines_v1::suspend_always final_suspend() {\n        this->done = true;\n        return {};\n    }\n    Future get_return_object();\n    void unhandled_exception() { abort(); }\n    void return_value(int val) {\n        this->val = val;\n    }\n\n    int val;\n    bool done;\n};\nclass [[nodiscard]] Future\n{\npublic:\n    explicit Future(Handle handle)\n        : m_handle (handle)\n    {}\n    ~Future() {\n        if (m_handle) {\n            m_handle.destroy();\n        }\n    }\n    using promise_type = Promise;\n    int operator()();\nprivate:\n    Handle m_handle;\n};\nFuture Promise::get_return_object()\n{\n    return Future { Handle::from_promise(*this) };\n}\nint Future::operator()()\n{\n    if (m_handle && m_handle.promise().done) {\n        return m_handle.promise().val;\n    } else {\n        return -1;\n    }\n}\n//The Co-routine\nFuture f()\n{\n    co_return 42;\n}\nint main()\n{\n    Future myFuture = f();\n    std::cout << \"The value of myFuture is \" << myFuture() << std::endl;\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/54524947/crash-with-icc-can-the-compiler-invent-writes-where-none-existed-in-the-abstrac",
    "body": "..B1.15:                        # Preds ..B1.15 ..B1.14                //do{\n        vmovdqu   ymm2, YMMWORD PTR [rsi+r8]                    #6.13   // load from str2\n        vpcmpeqb  ymm3, ymm0, YMMWORD PTR [rdi+r8]              #5.24   // compare vs. str1\n        vpblendvb ymm4, ymm2, ymm1, ymm3                        #6.13   // blend\n        vmovdqu   YMMWORD PTR [r8+rsi], ymm4                    #6.13   // store to str2\n        add       r8, 32                                        #4.5    // i+=32\n        cmp       r8, rax                                       #4.5\n        jb        ..B1.15       # Prob 82%                      #4.5   // }while(i<len);"
  },
  {
    "url": "https://stackoverflow.com/questions/76381239/is-there-a-faster-algorithm-for-maxctzx-ctzy",
    "body": "pub fn naive(x: u64, y: u64) -> u32 {\n    x.trailing_zeros().max(y.trailing_zeros())\n}\npub fn sum_minus_min(x: u64, y: u64) -> u32 {\n    x.trailing_zeros() + y.trailing_zeros() - (x | y).trailing_zeros()\n}\npub fn nielsen(x: u64, y: u64) -> u32 {\n    let x_lsb = x & x.wrapping_neg();\n    let y_lsb = y & y.wrapping_neg();\n    let xy_lsb = x_lsb | y_lsb;\n    let lsb = xy_lsb & xy_lsb.wrapping_neg();\n    let xy_max_lsb = if xy_lsb == lsb { lsb } else { xy_lsb ^ lsb };\n    xy_max_lsb.trailing_zeros()\n}\npub fn timmermans(x: u64, y: u64) -> u32 {\n    let loxs = !x & x.wrapping_sub(1);\n    let loys = !y & y.wrapping_sub(1);\n    return (loxs | loys).count_ones();\n}\npub fn kealey(x: u64, y: u64) -> u32 {\n    ((x | x.wrapping_neg()) & (y | y.wrapping_neg())).trailing_zeros()\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/76381239/is-there-a-faster-algorithm-for-maxctzx-ctzy",
    "body": "example::naive:\n        tzcnt   rcx, rdi\n        tzcnt   rax, rsi\n        cmp     ecx, eax\n        cmova   eax, ecx\n        ret\nexample::sum_minus_min:\n        tzcnt   rcx, rdi\n        tzcnt   rax, rsi\n        add     eax, ecx\n        or      rsi, rdi\n        tzcnt   rcx, rsi\n        sub     eax, ecx\n        ret\nexample::nielsen:\n        blsi    rax, rdi\n        blsi    rcx, rsi\n        or      rcx, rax\n        blsi    rax, rcx\n        xor     edx, edx\n        cmp     rcx, rax\n        cmovne  rdx, rcx\n        xor     rdx, rax\n        tzcnt   rax, rdx\n        ret\nexample::timmermans:\n        lea     rax, [rdi - 1]\n        andn    rax, rdi, rax\n        lea     rcx, [rsi - 1]\n        andn    rcx, rsi, rcx\n        or      rcx, rax\n        xor     eax, eax\n        popcnt  rax, rcx\n        ret\nexample::kealey:\n        mov     rax, rdi\n        neg     rax\n        or      rax, rdi\n        mov     rcx, rsi\n        neg     rcx\n        or      rcx, rsi\n        and     rcx, rax\n        tzcnt   rax, rcx\n        ret"
  },
  {
    "url": "https://stackoverflow.com/questions/76381239/is-there-a-faster-algorithm-for-maxctzx-ctzy",
    "body": "use criterion::{black_box, criterion_group, criterion_main, Criterion};\nconst NUMBERS: [u64; 32] = [\n    ...\n];\nfn bench<F>(func: F)\nwhere\n    F: Fn(u64, u64) -> u32,\n{\n    for x in NUMBERS {\n        for y in NUMBERS {\n            black_box(func(x, y));\n        }\n    }\n}\nfn compare(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"ctz_max\");\n    group.bench_function(\"naive\", |b| b.iter(|| bench(naive)));\n    group.bench_function(\"sum_minus_min\", |b| b.iter(|| bench(sum_minus_min)));\n    group.bench_function(\"nielsen\", |b| b.iter(|| bench(nielsen)));\n    group.bench_function(\"timmermans\", |b| b.iter(|| bench(timmermans)));\n    group.bench_function(\"kealey\", |b| b.iter(|| bench(kealey)));\n}\ncriterion_group!(benches, compare);\ncriterion_main!(benches);"
  },
  {
    "url": "https://stackoverflow.com/questions/15869066/inserting-into-an-unordered-set-with-custom-hash-function",
    "body": "#include <string>\n#include <unordered_set>\n#include <list>\nusing namespace std;\nstruct Interval {\n  unsigned int b;\n  unsigned int e;\n  bool updated;   //true if concat.  initially false\n  int patternIndex;  //pattern index. valid for single pattern\n  int proteinIndex;   //protein index.  for retrieving the pattern\n};\nbool operator == (Interval const& lhs, Interval const& rhs)\n{\n    return (lhs.b == rhs.b) && (lhs.e == rhs.e) && (lhs.proteinIndex == rhs.proteinIndex);\n}\nstruct Hash {\n   size_t operator()(const Interval &interval) const {\n     string temp = to_string(interval.b) + to_string(interval.e) + to_string(interval.proteinIndex);\n     return (temp.length());\n   }\n};\nint main()\n{\n   unordered_set<Interval, Hash> test;\n\n  list<Interval> concat;\n  for(list<Interval>::iterator i = concat.begin(); i != concat.end(); ++i){\n    test.insert(*i);\n  }\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/35518611/difference-between-queues-emplace-and-push",
    "body": "#include <iostream>\n#include <stack>\nusing namespace std;\nstruct Point_3D\n{\n    int x, y, z;\n    Point_3D(int x = 0, int y = 0, int z = 0)\n    {\n        this->x = x, this->y = y, this->z = z;\n    }\n};\nint main()\n{\n    stack<Point_3D> multiverse;\n    // First, Object of that(multiverse) class has to be created, then it's added to the stack/queue\n    Point_3D pt {32, -2452};\n    multiverse.push(pt);\n    // Here, no need to create object, emplace will do the honors\n    multiverse.emplace(32, -2452);\n    multiverse.emplace(455, -3);\n    multiverse.emplace(129, 4, -67);\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/16533156/how-to-create-a-custom-clock-for-use-in-stdchrono-functions",
    "body": "struct My_Clock;\ntemplate <class Duration>\nusing My_time = std::chrono::time_point<My_Clock, Duration>;\nstruct My_Clock\n{\n    typedef std::chrono::seconds              duration;\n    typedef duration::rep                     rep;\n    typedef duration::period                  period;\n    typedef std::chrono::time_point<My_Clock> time_point;\n    static const bool is_steady =             false;\n    static\n    time_point\n    now() noexcept;\n    template <class Duration>\n    static\n    auto\n    from_sys(std::chrono::sys_time<Duration> const& tp) noexcept;\n    template <class Duration>\n    static\n    auto\n    to_sys(My_time<Duration> const& tp) noexcept;\n};\ntemplate <class Duration>\nauto\nMy_Clock::from_sys(std::chrono::sys_time<Duration> const& tp) noexcept\n{\n    using namespace std::chrono;\n    return My_time{tp - sys_days{July/13/1988}};\n}\ntemplate <class Duration>\nauto\nMy_Clock::to_sys(My_time<Duration> const& tp) noexcept\n{\n    using namespace std::chrono;\n    return sys_time{tp - clock_cast<My_Clock>(sys_days{})};\n}\nMy_Clock::time_point\nMy_Clock::now() noexcept\n{\n    using namespace std::chrono;\n    return floor<duration>(clock_cast<My_Clock>(system_clock::now()));\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/6497374/emacs-cc-mode-indentation-problem-with-c0x-enum-class",
    "body": "(defun inside-class-enum-p (pos)\n  \"Checks if POS is within the braces of a C++ \\\"enum class\\\".\"\n  (ignore-errors\n    (save-excursion\n      (goto-char pos)\n      (up-list -1)\n      (backward-sexp 1)\n      (looking-back \"enum[ \\t]+class[ \\t]+[^}]+\"))))\n(defun align-enum-class (langelem)\n  (if (inside-class-enum-p (c-langelem-pos langelem))\n      0\n    (c-lineup-topmost-intro-cont langelem)))\n(defun align-enum-class-closing-brace (langelem)\n  (if (inside-class-enum-p (c-langelem-pos langelem))\n      '-\n    '+))\n(defun fix-enum-class ()\n  \"Setup `c++-mode' to better handle \\\"class enum\\\".\"\n  (add-to-list 'c-offsets-alist '(topmost-intro-cont . align-enum-class))\n  (add-to-list 'c-offsets-alist\n               '(statement-cont . align-enum-class-closing-brace)))\n(add-hook 'c++-mode-hook 'fix-enum-class)"
  },
  {
    "url": "https://stackoverflow.com/questions/72030595/which-gcc-optimization-flags-affect-binary-size-the-most",
    "body": "# GCC -O0 -mcpu=cortex-m7 -mthumb\nfoo(std::vector<int, std::allocator<int> >&):\n        push    {r4, r7, lr}             @ non-leaf function requires saving LR (the return address) as well as some call-preserved registers\n        sub     sp, sp, #12\n        add     r7, sp, #0              @ Use r7 as a frame pointer.  -O0 defaults to -fno-omit-frame-pointer\n        str     r0, [r7, #4]            @ spill the incoming register arg to the stack\n        movs    r1, #0                  @ 2nd arg for operator[]\n        ldr     r0, [r7, #4]            @ reload the pointer to the control block as the first arg\n        bl      std::vector<int, std::allocator<int> >::operator[](unsigned int)\n        mov     r3, r0                  @ useless copy, but hey we told GCC not to spend any time optimizing.\n        ldr     r4, [r3]                @ deref the reference (pointer) it returned, into a call-preserved register that will survive across the next call\n        movs    r1, #1                  @ arg for the v[1]  operator[]\n        ldr     r0, [r7, #4]\n        bl      std::vector<int, std::allocator<int> >::operator[](unsigned int)\n        mov     r3, r0\n        ldr     r3, [r3]                @ deref the returned reference\n        add     r3, r3, r4              @ v[1] + v[0]\n        mov     r0, r3                  @ and copy into the return value reg because GCC didn't bother to add into it directly\n        adds    r7, r7, #12             @ tear down the stack frame\n        mov     sp, r7\n        pop     {r4, r7, pc}            @ and return by popping saved-LR into PC\n@ and there's an actual implementation of the operator[] function\n@ it's 15 instructions long.\n@ But only one instance of this is needed for each type your program uses (vector<int>, vector<char*>, vector<my_foo>, etc.)\n@ so it doesn't add up as much as each call-site\nstd::vector<int, std::allocator<int> >::operator[](unsigned int):\n        push    {r7}\n        sub     sp, sp, #12\n  ..."
  },
  {
    "url": "https://stackoverflow.com/questions/30573481/how-to-write-a-makefile-with-separate-source-and-header-directories",
    "body": "SRC_DIR := src\nOBJ_DIR := obj\nBIN_DIR := bin\nEXE := $(BIN_DIR)/hellomake\nSRC := $(wildcard $(SRC_DIR)/*.c)\nOBJ := $(SRC:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)\nCPPFLAGS := -Iinclude -MMD -MP\nCFLAGS   := -Wall\nLDFLAGS  := -Llib\nLDLIBS   := -lm\n.PHONY: all clean\nall: $(EXE)\n$(EXE): $(OBJ) | $(BIN_DIR)\n\t$(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@\n$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c | $(OBJ_DIR)\n\t$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@\n$(BIN_DIR) $(OBJ_DIR):\n\tmkdir -p $@\nclean:\n\t@$(RM) -rv $(BIN_DIR) $(OBJ_DIR)\n-include $(OBJ:.o=.d)"
  },
  {
    "url": "https://stackoverflow.com/questions/67270447/visual-studio-code-lldb-on-macos-error-when-starting-debugging-session",
    "body": "{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n      {\n        \"name\": \"clang++ - Build and debug active file\",\n        \"type\": \"lldb\",\n        \"request\": \"launch\",\n        \"program\": \"${fileDirname}/${fileBasenameNoExtension}\",\n        \"args\": [],\n        \"cwd\": \"${workspaceFolder}\",\n        \"preLaunchTask\": \"clang++ build active file\"\n      }\n    ]\n  }"
  },
  {
    "url": "https://stackoverflow.com/questions/70117922/passing-a-c-style-array-to-spant",
    "body": "prog.cc:18:25: error: no matching function for call to 'my_size(std::array<int, 5>&)'\n   18 |     std::cout << my_size(arr) << my_size(vec) << my_size(il) << my_size(c_arr);\n      |                  ~~~~~~~^~~~~\nprog.cc:7:8: note: candidate: 'template<class T> size_t my_size(std::span<_Type, 18446744073709551615>)'\n    7 | size_t my_size(std::span<T> s)\n      |        ^~~~~~~\nprog.cc:7:8: note:   template argument deduction/substitution failed:\nprog.cc:18:25: note:   'std::array<int, 5>' is not derived from 'std::span<_Type, 18446744073709551615>'\n   18 |     std::cout << my_size(arr) << my_size(vec) << my_size(il) << my_size(c_arr);\n      |                  ~~~~~~~^~~~~"
  },
  {
    "url": "https://stackoverflow.com/questions/47203255/convert-stdvariant-to-another-stdvariant-with-super-set-of-types",
    "body": "namespace impl\n{\ntemplate <class... Args>\nstruct variant_cast_proxy_lref\n{\n    std::variant<Args...>& v;\n    template <class... ToArgs>\n    constexpr operator std::variant<ToArgs...>() &&\n    {\n        return std::visit(\n            [](auto&& arg) -> std::variant<ToArgs...>\n            {\n                return std::forward<decltype(arg)>(arg);\n            },\n            v);\n    }\n};\ntemplate <class... Args>\nstruct variant_cast_proxy_constlref\n{\n    const std::variant<Args...>& v;\n    template <class... ToArgs>\n    constexpr operator std::variant<ToArgs...>() &&\n    {\n        return std::visit(\n            [](auto&& arg) -> std::variant<ToArgs...>\n            {\n                return std::forward<decltype(arg)>(arg);\n            },\n            v);\n    }\n};\ntemplate <class... Args>\nstruct variant_cast_proxy_rref\n{\n    std::variant<Args...>&& v;\n    template <class... ToArgs>\n    constexpr operator std::variant<ToArgs...>()&&\n    {\n        return std::visit(\n            [](auto&& arg) -> std::variant<ToArgs...>\n            {\n                return std::forward<decltype(arg)>(arg);\n            },\n            std::move(v));\n    }\n};\n} // namespace impl"
  },
  {
    "url": "https://stackoverflow.com/questions/79524869/whats-the-point-of-deleted-virtual-functions",
    "body": "struct A\n{\n    virtual void foo(int) = delete;\n    virtual void foo(double);\n    virtual void foo(const char*);\n};\nstruct B : A\n{\n    void foo(int) override = delete;\n    void foo(double) override;\n};\nstruct C : A\n{\n    void foo(int); // error, redeclaring a deleted virtual function without delete\n};\nint main() {\n    B b;\n    A& a = b;\n    a.foo(1); // error, calling deleted function\n    a.foo(1.); // B::foo(double)\n    a.foo(\"1\"); // A::foo(const char*)\n    b.foo(1); // error, calling deleted function\n    b.foo(1.); // B::foo(double)\n    b.foo(\"1\"); // error, A::foo(const char*) is shadowed by B::foo declarations\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/66335672/make-integer-sequence-unique-at-compile-time",
    "body": "#include <type_traits>\nnamespace detail\n{\ntemplate<class, auto... Ns>\nstruct uniq_impl;\ntemplate<template<auto...> class T, auto... Ms, auto N, auto... Ns>\nstruct uniq_impl<T<Ms...>, N, Ns...> : std::conditional_t<\n    (... || (N == Ms)),\n    uniq_impl<T<Ms...>, Ns...>,\n    uniq_impl<T<Ms..., N>, Ns...>>\n{\n};\ntemplate<template<auto...> class T, auto... Ms>\nstruct uniq_impl<T<Ms...>>\n{\n    using type = T<Ms...>;\n};\n} // namespace detail\ntemplate<int... Ns>\nclass seq\n{\n};\ntemplate<int... Ns>\nusing uniq = detail::uniq_impl<seq<>, Ns...>;\nstatic_assert(std::is_same_v<typename uniq<1,2,2,2,3,3,3>::type, seq<1, 2, 3>>);"
  },
  {
    "url": "https://stackoverflow.com/questions/66335672/make-integer-sequence-unique-at-compile-time",
    "body": "#include <boost/mp11/algorithm.hpp>\nnamespace detail\n{\ntemplate<template<auto...> class T, auto... Ns>\nclass uniq_impl\n{\n    static boost::mp11::mp_list<std::integral_constant<decltype(Ns), Ns>...> types();\n    template <class L>\n    static boost::mp11::mp_unique<L> transform(L);\n    template<class... Ts, auto... Ms>\n    static T<Ms...> values(boost::mp11::mp_list<std::integral_constant<Ts, Ms>...>);\npublic:\n    using type = decltype(values(transform(types())));\n};\n} // namespace detail\ntemplate<int... Ns>\nclass seq\n{\n};\ntemplate<int... Ns>\nusing uniq = detail::uniq_impl<seq, Ns...>;\nstatic_assert(std::is_same_v<typename uniq<1,2,2,2,3,3,3>::type, seq<1, 2, 3>>);"
  },
  {
    "url": "https://stackoverflow.com/questions/276102/catching-all-unhandled-c-exceptions",
    "body": "#include <iostream>\n#include <exception>\n#include <stdexcept>\nstruct FooException: std::runtime_error {\n    FooException(const std::string& what): std::runtime_error(what) {}\n};\nint main() {\n    std::set_terminate([]() {\n        try {\n            std::rethrow_exception(std::current_exception());\n        } catch (const FooException& e) {\n            std::cerr << \"Unhandled FooException: \" << e.what() << std::endl;\n        } catch (const std::exception& e) {\n            std::cerr << \"Unhandled exception: \" << e.what() << std::endl;\n        } catch (...) {\n            std::cerr << \"Unhandled exception of unknown type\" << std::endl;\n        }\n        std::abort();\n    });\n    throw FooException(\"Bad things have happened.\");\n    // throw std::runtime_error(\"Bad things have happened.\");\n    // throw 9001;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/58808030/range-view-to-stdvector",
    "body": "C++\nnamespace detail {\n    // Type acts as a tag to find the correct operator| overload\n    template <typename C>\n    struct to_helper {\n    };\n\n    // This actually does the work\n    template <typename Container, rng::range R>\n    requires std::convertible_to<rng::range_value_t<R>, typename Container::value_type>\n    Container operator|(R&& r, to_helper<Container>) {\n        return Container{r.begin(), r.end()};\n    }\n}\n// Couldn't find an concept for container, however a\n// container is a range, but not a view.\ntemplate <rng::range Container>\nrequires (!rng::view<Container>)\nauto to() {\n    return detail::to_helper<Container>{};\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/77712908/why-performance-for-this-index-of-max-function-over-many-arrays-of-256-bytes-is",
    "body": "int loop_vc_nested_noselect(const std::array<uint8_t, H*W> &img, const std::array<Vec32uc, 8> &idx) {\n  int sum = 0;\n  for (int i=0; i<H*W; i+=W) {\n    __m256i tmpidx = _mm256_loadu_si256((__m256i*)&idx[0]);\n    __m256i tmp = _mm256_loadu_si256((__m256i*)&img[i]);\n    Vec16us vMaxlo = _mm256_unpacklo_epi8(tmpidx, tmp);\n    Vec16us vMaxhi = _mm256_unpackhi_epi8(tmpidx, tmp);\n    for (int j=1; j<8; j++) {\n      Vec32uc vCurr, iCurr;\n      iCurr.load(&idx[j]);  // these get hoisted out of the outer loop and reused across img iters\n      vCurr.load(&img[i+j*32]);\n      Vec16us lo = _mm256_unpacklo_epi8(iCurr, vCurr);\n      Vec16us hi = _mm256_unpackhi_epi8(iCurr, vCurr);\n      vMaxlo = max(vMaxlo, lo);\n      vMaxhi = max(vMaxhi, hi);\n          // vMax = max(vMax, max(lo,hi));  // GCC was optimizing to two dep chains anyway, and that's better on big-cores that can do more than 1 load+shuffle+max per clock\n    }\n    Vec16us vMax = max(vMaxlo, vMaxhi);\n    // silly GCC uses vpextrw even though we're already truncating narrower\n    auto maxidx = (uint8_t)horizontal_max(vMax); // retrieve the payload from the bottom of the max\n    // TODO: use phminposuw like the last part of maxpos_u8_noscan_unpack\n    // with indices loaded and inverted once, outside the outer loop.  (Manually unrolled if compilers don't do that for you)\n    sum += maxidx;\n  }\n  return sum;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/77712908/why-performance-for-this-index-of-max-function-over-many-arrays-of-256-bytes-is",
    "body": ".L7:\n        vpunpcklbw      ymm11, ymm7, YMMWORD PTR [rax+32]\n        vpunpckhbw      ymm10, ymm7, YMMWORD PTR [rax+32]\n        add     rax, 256\n        vpunpcklbw      ymm0, ymm8, YMMWORD PTR [rax-256]\n        vpunpckhbw      ymm9, ymm8, YMMWORD PTR [rax-256]\n        vpmaxuw ymm0, ymm0, ymm11\n        vpmaxuw ymm9, ymm9, ymm10\n        vpunpcklbw      ymm11, ymm6, YMMWORD PTR [rax-192]\n        vpunpckhbw      ymm10, ymm6, YMMWORD PTR [rax-192]\n        vpmaxuw ymm0, ymm0, ymm11\n        vpunpcklbw      ymm11, ymm5, YMMWORD PTR [rax-160]\n        vpmaxuw ymm9, ymm9, ymm10\n        vpunpckhbw      ymm10, ymm5, YMMWORD PTR [rax-160]\n        vpmaxuw ymm0, ymm0, ymm11\n..."
  },
  {
    "url": "https://stackoverflow.com/questions/77712908/why-performance-for-this-index-of-max-function-over-many-arrays-of-256-bytes-is",
    "body": "int loop_vc_nested(const std::array<uint8_t, H*W> &img, const std::array<Vec32uc, 8> &idx) {\n  int sum = 0;\n  Vec32uc vMax, iMax, vCurr, iCurr;\n  for (int i=0; i<H*W; i+=W) {\n    iMax.load(&idx[0]);\n    vMax.load(&img[i]);\n    for (int j=1; j<8; j++) {\n      iCurr.load(&idx[j]);  // these get hoisted out of the outer loop and reused across img iters\n      vCurr.load(&img[i+j*32]);\n      // unsigned > isn't available until AVX-512.  VCL uses !(a == max(a,b))\n      // GCC XORs the compare result, clang uses max and a==min(a,b)\n      iMax = select(vCurr > vMax, iCurr, iMax);\n      // scanning backwards from the end with a==max(a,b), we could still find the earliest max\n      vMax = max(vMax, vCurr);\n    }\n#if 1\n   Vec32uc vMaxAll{horizontal_max(vMax)};\n   //size_t maxidx = horizontal_find_first(vMax == vMaxAll); // total disaster on clang: non-inlined BSF wrapper forces vector spill/reload of the idx vectors\n   size_t maxidx = _tzcnt_u32(to_bits(vMax == vMaxAll));\n#else\n    size_t maxidx = maxpos_u8_noscan_unpack(vMax);\n#endif\n    sum += iMax[maxidx];\n  }\n  return sum;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/77712908/why-performance-for-this-index-of-max-function-over-many-arrays-of-256-bytes-is",
    "body": "# GCC13.2 -O3 -march=alderlake for the version of your source above\nloop_vc_nested(std::array<unsigned char, 208896ul> const&, std::array<Vec32uc, 8ul> const&):\n        push    rbp\n        mov     rax, rdi\n        xor     ecx, ecx\n        vpcmpeqd        ymm1, ymm1, ymm1   # set1(-1)\n        mov     rbp, rsp\n        and     rsp, -32                   # align the stack for the store that we index with movzx\n        vmovdqu ymm9, YMMWORD PTR [rsi+32] # idx[32..63]\n        vmovdqu ymm8, YMMWORD PTR [rsi]    # idx[0..31]\n        ...        # and all 8 vectors of idx\n        lea     rsi, [rdi+208896]         # img.end()\n.L2:\n        vmovdqu ymm0, YMMWORD PTR [rax+32]\n        vpmaxub ymm11, ymm0, YMMWORD PTR [rax]\n        add     rax, 256\n        vpmaxub ymm10, ymm11, YMMWORD PTR [rax-192]\n        vpcmpeqb        ymm0, ymm11, YMMWORD PTR [rax-256]\n        vpcmpeqb        ymm11, ymm11, ymm10\n        vpxor   ymm0, ymm0, ymm1\n        vpxor   ymm11, ymm11, ymm1\n        vpblendvb       ymm0, ymm8, ymm9, ymm0\n        vpblendvb       ymm0, ymm0, ymm7, ymm11\n        vpmaxub ymm11, ymm10, YMMWORD PTR [rax-160]\n        vpcmpeqb        ymm10, ymm10, ymm11\n        vpxor   ymm10, ymm10, ymm1\n        vpblendvb       ymm0, ymm0, ymm6, ymm10\n        vpmaxub ymm10, ymm11, YMMWORD PTR [rax-128]\n        vpcmpeqb        ymm11, ymm11, ymm10\n        vpxor   ymm11, ymm11, ymm1\n        vpblendvb       ymm0, ymm0, ymm5, ymm11\n        vpmaxub ymm11, ymm10, YMMWORD PTR [rax-96]\n        vpcmpeqb        ymm10, ymm10, ymm11\n        vpxor   ymm10, ymm10, ymm1\n        vpblendvb       ymm0, ymm0, ymm4, ymm10\n        vpmaxub ymm10, ymm11, YMMWORD PTR [rax-64]\n        vpcmpeqb        ymm11, ymm11, ymm10\n        vpxor   ymm11, ymm11, ymm1\n        vpblendvb       ymm0, ymm0, ymm3, ymm11\n        vpmaxub ymm11, ymm10, YMMWORD PTR [rax-32]\n        vpcmpeqb        ymm10, ymm10, ymm11\n        vpxor   ymm10, ymm10, ymm1\n        vpblendvb       ymm0, ymm0, ymm2, ymm10\n ## end of unrolled inner loop\n        vextracti128    xmm10, ymm11, 0x1   # start of horizontal_max\n        vpmaxub xmm12, xmm11, xmm10\n        vmovdqa YMMWORD PTR [rsp-32], ymm0   # store iMax\n        vpunpckhqdq     xmm10, xmm12, xmm12\n    ...\n        vpmaxub xmm10, xmm10, xmm12       # end of horizontal_max\n        vpbroadcastb    ymm10, xmm10\n        vpcmpeqb        ymm10, ymm10, ymm11\n        vpmovmskb       edx, ymm10\n        tzcnt   edx, edx        # your actual original used BSF, much worse on AMD\n        and     edx, 31         # this isn't in the source anywhere!\n        movzx   edx, BYTE PTR [rsp-32+rdx]\n        add     ecx, edx        # sum +=\n        cmp     rsi, rax\n        jne     .L2         }while(ptr != endptr);\n        mov     eax, ecx\n        vzeroupper\n        ret"
  },
  {
    "url": "https://stackoverflow.com/questions/72405122/creating-an-iterator-with-c20-concepts-for-custom-container",
    "body": "struct end_of_stream_t {};\nconstexpr end_of_stream_t end_of_stream{};\nstruct my_input_iterator {\n  // N.B. Not a complete implementation, just demonstrating sentinels.\n  some_stream_type* data_stream;\n  bool operator==(end_of_stream_t) const { return data_stream->empty(); }\n};\ntemplate<std::input_iterator Ite, std::sentinel_for<Ite> Sen>\nvoid my_algorithm(Ite begin, Sen end) {\n  while(begin != end) {\n    //...\n  }\n}\nvoid foo(some_stream_type& stream) {\n  my_algorithm(my_input_iterator{&stream}, end_of_stream);\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/16077299/how-to-print-current-time-with-milliseconds-using-c-c11",
    "body": "c++\nstd::string getCurrentTimestamp()\n{\n    using std::chrono::system_clock;\n    auto currentTime = std::chrono::system_clock::now();\n    char buffer[80];\n\n    auto transformed = currentTime.time_since_epoch().count() / 1000000;\n\n    auto millis = transformed % 1000;\n\n    std::time_t tt;\n    tt = system_clock::to_time_t ( currentTime );\n    auto timeinfo = localtime (&tt);\n    strftime (buffer,80,\"%F %H:%M:%S\",timeinfo);\n    sprintf(buffer, \"%s:%03d\",buffer,(int)millis);\n\n    return std::string(buffer);\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/54831971/range-based-for-loop-with-special-case-for-the-first-item",
    "body": "#include <iostream>\n#include <vector>\n\ntemplate<typename BeginIt, typename EndIt, typename FirstFun, typename OthersFun>\nvoid for_first_then_each(BeginIt begin, EndIt end, FirstFun firstFun, OthersFun othersFun) {\n    if(begin == end) return;\n    firstFun(*begin);\n    for(auto it = std::next(begin); it != end; ++it) {\n        othersFun(*it);\n    };\n}\nint main() {\n    std::vector<int> v = {0, 1, 2, 3};\n    for_first_then_each(v.begin(), v.end(),\n        [](auto first) { std::cout << first + 42 << '\\n'; },\n        [](auto other) { std::cout << other - 42 << '\\n'; }\n    );\n    // Outputs 42, -41, -40, -39\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/64211652/stdfmod-abysmal-double-precision",
    "body": "#include <cmath>\n#include <iomanip>\n#include <iostream>\nint main() {\n    double a = 1001.0, b = 0.0001;\n    std::cout << std::setprecision(32) << std::left;\n    std::cout << std::setw(16) << \"a:\" << a << \"\\n\";\n    std::cout << std::setw(16) << \"b:\" << b << \"\\n\";\n    std::cout << std::setw(16) << \"fmod:\" << fmod(a, b) << \"\\n\";\n    std::cout << std::setw(16) << \"remainder:\" << remainder(a, b) << \"\\n\";\n    std::cout << std::setw(16) << \"floor a/b:\" << floor(a/b) << \"\\n\";\n    std::cout << std::setw(16) << \"actual:\" << a-floor(a/b)*b << \"\\n\";\n    std::cout << std::setw(16) << \"a/b:\" << a / b << \"\\n\";\n    std::cout << std::setw(16) << \"floor 10009999:\" << floor(10009999.99999999952) << \"\\n\";\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/12160765/if-else-at-compile-time-in-c",
    "body": "#include <cassert>\n#include <type_traits>\ntemplate<typename T>\nclass MyClass {\n    public:\n        MyClass() : myVar{0} {}\n        void modifyIfNotConst() {\n            if constexpr(!isconst) {\n                myVar = 1;\n            }\n        }\n        T myVar;\n    protected:\n        static constexpr bool isconst = std::is_const<T>::value;\n};\nint main() {\n    MyClass<double> x;\n    MyClass<const double> y;\n    x.modifyIfNotConst();\n    y.modifyIfNotConst();\n    assert(x.myVar == 1);\n    assert(y.myVar == 0);\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/65120716/integer-literal-for-fixed-width-integer-types",
    "body": "c++\nnamespace std::inline literals::inline integer_literals {\n  constexpr uint64_t operator \"\"u64 (unsigned long long arg);\n  constexpr uint32_t operator \"\"u32 (unsigned long long arg);\n  constexpr uint16_t operator \"\"u16 (unsigned long long arg);\n  constexpr uint8_t operator \"\"u8 (unsigned long long arg);\n  constexpr int64_t operator \"\"i64 (unsigned long long arg);\n  constexpr int32_t operator \"\"i32 (unsigned long long arg);\n  constexpr int16_t operator \"\"i16 (unsigned long long arg);\n  constexpr int8_t operator \"\"i8 (unsigned long long arg);\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/65120716/integer-literal-for-fixed-width-integer-types",
    "body": "c++\nnamespace std::inline literals::inline integer_literals {\n  constexpr uint_least64_t operator \"\"u64 (unsigned long long arg);\n  constexpr uint_least32_t operator \"\"u32 (unsigned long long arg);\n  constexpr uint_least16_t operator \"\"u16 (unsigned long long arg);\n  constexpr uint_least8_t operator \"\"u8 (unsigned long long arg);\n  constexpr int_least64_t operator \"\"i64 (unsigned long long arg);\n  constexpr int_least32_t operator \"\"i32 (unsigned long long arg);\n  constexpr int_least16_t operator \"\"i16 (unsigned long long arg);\n  constexpr int_least8_t operator \"\"i8 (unsigned long long arg);\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/72505009/why-cant-i-initialize-this-stdvector-with-an-l-value",
    "body": "struct Custom\n{\n  Custom(std::size_t)\n  {\n\n  }\n};\nint main()\n{\n//-----------v---->constant expression\n    Custom c{3}; //no warning/error here as there is no narrowing conversion\n\n    int i = 3;  //not a constant expressoion\n//-----------v---->not a constant expression and so we get warning/error\n    Custom d{i}; //warning here of narrowing conversion here\n\n    constexpr int j = 3; //constant expression\n//-----------v------>no warning here as j is a constant expression and so there is no narrowing conversion\n    Custom e{j};\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/75741488/why-is-my-struct-destructed-twice-with-stdvariant-and-stdmonostate",
    "body": "#include <iostream>\n#include <variant>\nstruct A\n{\n    A()                    { std::cout << \"Constructing A\\n\"; }\n    A(A const&)            { std::cout << \"Copy constructing A\\n\"; }\n    A(A&&)                 { std::cout << \"Move constructing A\\n\"; }\n    A& operator=(A const&) { std::cout << \"Copy assigning A\\n\"; return *this; }\n    A& operator=(A&&)      { std::cout << \"Move assigning A\\n\"; return *this; }\n    ~A()                   { std::cout << \"Destructing A\\n\"; }\n};\nstruct B\n{\n};\nint main()\n{\n    std::variant<std::monostate, A, B> ab;\n    ab = A();\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/73557662/how-can-i-achieve-multiple-conditional-inheritance",
    "body": "#include <concepts>\n#include <cstdint>\ntemplate <std::integral auto, class...>\nstruct inherit_mask {};\ntemplate <auto flags, class Base, class... Bases>\n  requires((flags & 1) == 1)\nstruct inherit_mask<flags, Base, Bases...>\n    : Base, inherit_mask<(flags >> 1), Bases...> {};\ntemplate <auto flags, class Base, class... Bases>\nstruct inherit_mask<flags, Base, Bases...>\n    : inherit_mask<(flags >> 1), Bases...> {};\nstruct A { void a() {} };\nstruct B { void b() {} };\nstruct C { void c() {} };\nstruct D { void d() {} };\ntemplate <std::uint8_t flags>\nusing build = inherit_mask<flags, A, B, C, D>;\nusing foo = build<0b0101>;\nstatic_assert(std::derived_from<foo, A>);\nstatic_assert(not std::derived_from<foo, B>);\nstatic_assert(std::derived_from<foo, C>);\nstatic_assert(not std::derived_from<foo, D>);"
  },
  {
    "url": "https://stackoverflow.com/questions/77813605/transparent-search-for-a-stdmap-with-a-stdpair-as-a-key",
    "body": "struct pair_less {\n    // important for transparent comparison, see std::map:find documentation\n    using is_transparent = std::true_type;\n    template <typename T, typename U>\n      requires pair_less_than_comparable<T, U> // C++20, see below\n    bool operator()(const T& a, const U& b) const {\n        if (a.first < b.first) return true;\n        if (b.first < a.first) return false;\n        return a.second < b.second;\n    }\n};\nint main() {\n    std::map<std::pair<std::string, std::string>, int, pair_less> m { /* ... */ };\n    // ...\n    std::string a = \"a\", b = \"b\";\n    // now works and creates no copies\n    auto pos = m.find(std::make_pair(std::ref(a), std::ref(b)));\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/68675303/how-to-create-a-function-that-forwards-its-arguments-to-fmtformat-keeping-the",
    "body": "template <std::size_t N>\nstruct static_string {\n    char str[N] {};\n    constexpr static_string(const char (&s)[N]) {\n        std::ranges::copy(s, str);\n    }\n};\ntemplate <static_string s>\nstruct format_string {\n    static constexpr const char* string = s.str;\n};\ntemplate <static_string s>\nconstexpr auto operator\"\"_fmt() {\n    return format_string<s>{};\n}\ntemplate <typename F, typename... Args>\nauto my_print(F, Args&&... args) {\n    return std::format(F::string, std::forward<Args>(args)...);\n}\n// used like\nmy_print(\"string: {}\"_fmt, 42);"
  },
  {
    "url": "https://stackoverflow.com/questions/71112750/create-a-vector-of-pairs-from-a-single-vector-in-c",
    "body": "#include <range/v3/range/conversion.hpp>\n#include <range/v3/view/transform.hpp>\n#include <range/v3/view/chunk.hpp>\nusing namespace ranges;\nusing namespace ranges::views;\nint main() {\n    std::vector<int> origin {1, 2, 3, 4, 5, 6, 7, 8};\n    std::vector<std::pair<int, int>> goal {{1, 2}, {3, 4}, {5, 6}, {7, 8}};\n    auto constexpr makePairFromRangeOf2 = [](auto two){\n        return std::make_pair(two.front(), two.back());\n    };\n    auto result = origin | chunk(2)\n                         | transform(makePairFromRangeOf2)\n                         | to_vector;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/49710006/fast-color-quantization-in-opencv",
    "body": "#include \"diplib.h\"\n#include \"dipviewer.h\"\n#include \"diplib/simple_file_io.h\"\n#include \"diplib/histogram.h\"\n#include \"diplib/segmentation.h\"\n#include \"diplib/lookup_table.h\"\nint main() {\n   dip::Image input = dip::ImageRead( \"/Users/cris/dip/images/flamingo.tif\" );\n   input.SetColorSpace( \"RGB\" ); // This image is linear RGB, not sRGB as assumed when reading RGB TIFFs.\n   // Compute the color histogram.\n   dip::Histogram hist( input, {}, { dip::Histogram::Configuration( 0.0, 255.0, 64 ) } );\n   // Cluster the histogram, the output histogram has a label assigned to each bin.\n   // Each label corresponds to one of the clusters.\n   dip::uint nClusters = 8;\n   dip::Image histImage = hist.GetImage(); // Copy with shared data\n   dip::Image tmp;\n   dip::CoordinateArray centers = dip::MinimumVariancePartitioning( histImage, tmp, nClusters );\n   histImage.Copy( tmp ); // Copy 32-bit label image into 64-bit histogram image.\n   // Find the cluster label for each pixel in the input image.\n   dip::Image labels = hist.ReverseLookup( input );\n   // The `centers` array contains histogram coordinates for each of the centers.\n   // We need to convert these coordinates to RGB values by multiplying by 4 (=256/64).\n   // `centers[ii]` corresponds to label `ii+1`.\n   dip::Image lutImage( { nClusters + 1 }, 3, dip::DT_UINT8 );\n   lutImage.At( 0 ) = 0; // label 0 doesn't exist\n   for( dip::uint ii = 0; ii < nClusters; ++ii ) {\n      lutImage.At( ii + 1 ) = { centers[ ii ][ 0 ] * 4, centers[ ii ][ 1 ] * 4, centers[ ii ][ 2 ] * 4 };\n   }\n   // Finally, we apply our look-up table mapping, painting each label in the image with\n   // its corresponding RGB color.\n   dip::LookupTable lut( lutImage );\n   dip::Image output = lut.Apply( labels );\n   output.SetColorSpace( \"RGB\" );\n   // Display\n   dip::viewer::ShowSimple( input, \"input image\" );\n   dip::viewer::ShowSimple( output, \"output image\" );\n   dip::viewer::Spin();\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/24559909/sending-string-over-udp-in-c",
    "body": "#include <sys/types.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <memory.h>\n#include <ifaddrs.h>\n#include <net/if.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <iostream>\nint resolvehelper(const char* hostname, int family, const char* service, sockaddr_storage* pAddr)\n{\n    int result;\n    addrinfo* result_list = NULL;\n    addrinfo hints = {};\n    hints.ai_family = family;\n    hints.ai_socktype = SOCK_DGRAM; // without this flag, getaddrinfo will return 3x the number of addresses (one for each socket type).\n    result = getaddrinfo(hostname, service, &hints, &result_list);\n    if (result == 0)\n    {\n        //ASSERT(result_list->ai_addrlen <= sizeof(sockaddr_in));\n        memcpy(pAddr, result_list->ai_addr, result_list->ai_addrlen);\n        freeaddrinfo(result_list);\n    }\n    return result;\n}\nint main()\n{\n    int result = 0;\n    int sock = socket(AF_INET, SOCK_DGRAM, 0);\n    char szIP[100];\n    sockaddr_in addrListen = {}; // zero-int, sin_port is 0, which picks a random port for bind.\n    addrListen.sin_family = AF_INET;\n    result = bind(sock, (sockaddr*)&addrListen, sizeof(addrListen));\n    if (result == -1)\n    {\n       int lasterror = errno;\n       std::cout << \"error: \" << lasterror;\n       exit(1);\n    }\n    sockaddr_storage addrDest = {};\n    result = resolvehelper(\"192.168.0.4\", AF_INET, \"9000\", &addrDest);\n    if (result != 0)\n    {\n       int lasterror = errno;\n       std::cout << \"error: \" << lasterror;\n       exit(1);\n    }\n    const char* msg = \"Jane Doe\";\n    size_t msg_length = strlen(msg);\n    result = sendto(sock, msg, msg_length, 0, (sockaddr*)&addrDest, sizeof(addrDest));\n    std::cout << result << \" bytes sent\" << std::endl;\n\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/60646412/what-is-the-usecase-for-explicit-bool",
    "body": "template <typename T1, typename T2>\nstruct pair {\n    template <typename U1=T1, typename U2=T2,\n        std::enable_if_t<\n            std::is_constructible_v<T1, U1> &&\n            std::is_constructible_v<T2, U2> &&\n            std::is_convertible_v<U1, T1> &&\n            std::is_convertible_v<U2, T2>\n        , int> = 0>\n    constexpr pair(U1&&, U2&& );\n\n    template <typename U1=T1, typename U2=T2,\n        std::enable_if_t<\n            std::is_constructible_v<T1, U1> &&\n            std::is_constructible_v<T2, U2> &&\n            !(std::is_convertible_v<U1, T1> &&\n              std::is_convertible_v<U2, T2>)\n        , int> = 0>\n    explicit constexpr pair(U1&&, U2&& );\n};"
  },
  {
    "url": "https://stackoverflow.com/questions/55920103/why-is-the-alignment-the-same-on-32-bit-and-64-bit-systems",
    "body": "_tmp$ = -8                                          ; size = 8\nvoid foo_align8(void) PROC                       ; foo_align8, COMDAT\n        push    ebp\n        mov     ebp, esp\n        and     esp, -8                             ; fffffff8H  align the stack\n        sub     esp, 8                                  ; and reserve 8 bytes\n        lea     eax, DWORD PTR _tmp$[esp+8]             ; get a pointer to those 8 bytes\n        push    eax                                     ; pass the pointer as an arg\n        call    void extfunc(__int64 *)           ; extfunc\n        add     esp, 4\n        mov     esp, ebp\n        pop     ebp\n        ret     0"
  },
  {
    "url": "https://stackoverflow.com/questions/55920103/why-is-the-alignment-the-same-on-32-bit-and-64-bit-systems",
    "body": "_tmp$ = -8                                          ; size = 8\nvoid foo_noalign(void) PROC                                ; foo_noalign, COMDAT\n        sub     esp, 8                             ; reserve 8 bytes\n        lea     eax, DWORD PTR _tmp$[esp+8]        ; \"calculate\" a pointer to it\n        push    eax                                ; pass the pointer as a function arg\n        call    void extfunc(__int64 *)           ; extfunc\n        add     esp, 12                             ; 0000000cH\n        ret     0"
  },
  {
    "url": "https://stackoverflow.com/questions/60169819/modern-approach-to-making-stdvector-allocate-aligned-memory",
    "body": "c++\n#include <limits>\n#include <new>\n/**\n * Returns aligned pointers when allocations are requested. Default alignment\n * is 64B = 512b, sufficient for AVX-512 and most cache line sizes.\n *\n * @tparam ALIGNMENT_IN_BYTES Must be a positive power of 2.\n */\ntemplate<typename    ElementType,\n         std::size_t ALIGNMENT_IN_BYTES = 64>\nclass AlignedAllocator\n{\nprivate:\n    static_assert(\n        ALIGNMENT_IN_BYTES >= alignof( ElementType ),\n        \"Beware that types like int have minimum alignment requirements \"\n        \"or access will result in crashes.\"\n    );\npublic:\n    using value_type = ElementType;\n    static std::align_val_t constexpr ALIGNMENT{ ALIGNMENT_IN_BYTES };\n    /**\n     * This is only necessary because AlignedAllocator has a second template\n     * argument for the alignment that will make the default\n     * std::allocator_traits implementation fail during compilation.\n     * @see https://stackoverflow.com/a/48062758/2191065\n     */\n    template<class OtherElementType>\n    struct rebind\n    {\n        using other = AlignedAllocator<OtherElementType, ALIGNMENT_IN_BYTES>;\n    };\npublic:\n    constexpr AlignedAllocator() noexcept = default;\n    constexpr AlignedAllocator( const AlignedAllocator& ) noexcept = default;\n    template<typename U>\n    constexpr AlignedAllocator( AlignedAllocator<U, ALIGNMENT_IN_BYTES> const& ) noexcept\n    {}\n    [[nodiscard]] ElementType*\n    allocate( std::size_t nElementsToAllocate )\n    {\n        if ( nElementsToAllocate\n             > std::numeric_limits<std::size_t>::max() / sizeof( ElementType ) ) {\n            throw std::bad_array_new_length();\n        }\n        auto const nBytesToAllocate = nElementsToAllocate * sizeof( ElementType );\n        return reinterpret_cast<ElementType*>(\n            ::operator new[]( nBytesToAllocate, ALIGNMENT ) );\n    }\n    void\n    deallocate(                  ElementType* allocatedPointer,\n                [[maybe_unused]] std::size_t  nBytesAllocated )\n    {\n        /* According to the C++20 draft n4868 § 17.6.3.3, the delete operator\n         * must be called with the same alignment argument as the new expression.\n         * The size argument can be omitted but if present must also be equal to\n         * the one used in new. */\n        ::operator delete[]( allocatedPointer, ALIGNMENT );\n    }\n};"
  },
  {
    "url": "https://stackoverflow.com/questions/60169819/modern-approach-to-making-stdvector-allocate-aligned-memory",
    "body": "c++\n#include <iostream>\n#include <stdexcept>\n#include <vector>\ntemplate<typename T, std::size_t ALIGNMENT_IN_BYTES = 64>\nusing AlignedVector = std::vector<T, AlignedAllocator<T, ALIGNMENT_IN_BYTES> >;\nint\nmain()\n{\n    AlignedVector<int, 1024> buffer( 3333 );\n    if ( reinterpret_cast<std::uintptr_t>( buffer.data() ) % 1024 != 0 ) {\n        std::cerr << \"Vector buffer is not aligned!\\n\";\n        throw std::logic_error( \"Faulty implementation!\" );\n    }\n    std::cout << \"Successfully allocated an aligned std::vector.\\n\";\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/63411054/how-can-you-quickly-compute-the-integer-logarithm-for-any-base",
    "body": "constexpr unsigned log2floor(uint64_t x) {\n    // implementation for C++17 using clang or gcc\n    return x ? 63 - __builtin_clzll(x) : 0;\n    // implementation using the new C++20 <bit> header\n    return x ? 63 - std::countl_zero(x) : 0;\n}\nconstexpr unsigned log10floor(unsigned x) {\n    constexpr unsigned char guesses[32] = {\n        0, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 5, 5, 5,\n        6, 6, 6, 6, 7, 7, 7, 8, 8, 8,\n        9, 9\n    };\n    constexpr uint64_t powers[11] = {\n        1, 10, 100, 1000, 10000, 100000, 1000000,\n        10000000, 100000000, 1000000000, 10000000000\n    };\n    unsigned guess = guesses[log2floor(x)];\n    return guess + (x >= powers[guess + 1]);\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/63411054/how-can-you-quickly-compute-the-integer-logarithm-for-any-base",
    "body": "#include <limits>\n#include <array>\ntemplate <typename Uint, size_t BASE>\nconstexpr std::array<uint8_t, std::numeric_limits<Uint>::digits> makeGuessTable()\n{\n    decltype(makeGuessTable<Uint, BASE>()) result{};\n    for (size_t i = 0; i < result.size(); ++i) {\n        Uint pow2 = static_cast<Uint>(Uint{1} << i);\n        result.data[i] = logFloor_naive(pow2, BASE);\n    }\n    return result;\n}\n// The maximum possible exponent for a given base that can still be represented\n// by a given integer type.\n// Example: maxExp<uint8_t, 10> = 2, because 10^2 is representable by an 8-bit unsigned\n// integer but 10^3 isn't.\ntemplate <typename Uint, unsigned BASE>\nconstexpr Uint maxExp = logFloor_naive<Uint>(static_cast<Uint>(~Uint{0u}), BASE);\n// the size of the table is maxPow<Uint, BASE> + 2 because we need to store the maximum power\n// +1 because we need to contain it, we are dealing with a size, not an index\n// +1 again because for narrow integers, we access guess+1\ntemplate <typename Uint, size_t BASE>\nconstexpr std::array<uint64_t, maxExp<Uint, BASE> + 2> makePowerTable()\n{\n    decltype(makePowerTable<Uint, BASE>()) result{};\n    uint64_t x = 1;\n    for (size_t i = 0; i < result.size(); ++i, x *= BASE) {\n        result.data[i] = x;\n    }\n    return result;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/63411054/how-can-you-quickly-compute-the-integer-logarithm-for-any-base",
    "body": "// If our base is a power of 2, we can convert between the\n// logarithms of different bases without losing any precision.\nconstexpr bool isPow2or0(uint64_t val) {\n    return (val & (val - 1)) == 0;\n}\ntemplate <size_t BASE = 10, typename Uint>\nconstexpr Uint logFloor(Uint val) {\n    if constexpr (isPow2or0(BASE)) {\n        return log2floor(val) / log2floor(BASE);\n    }\n    else {\n        constexpr auto guesses = makeGuessTable<Uint, BASE>();\n        constexpr auto powers = makePowerTable<Uint, BASE>();\n        uint8_t guess = guesses[log2floor(val)];\n\n        // Accessing guess + 1 isn't always safe for 64-bit integers.\n        // This is why we need this condition. See below for more details.\n        if constexpr (sizeof(Uint) < sizeof(uint64_t)\n            || guesses.back() + 2 < powers.size()) {\n            return guess + (val >= powers[guess + 1]);\n        }\n        else {\n            return guess + (val / BASE >= powers[guess]);\n        }\n    }\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/21446292/using-opencv-output-as-webcam",
    "body": "import cv2\nimport time\nimport pyfakewebcam\nimport numpy as np\nIMG_W = 1280\nIMG_H = 720\ncam = cv2.VideoCapture(0)\ncam.set(cv2.CAP_PROP_FRAME_WIDTH, IMG_W)\ncam.set(cv2.CAP_PROP_FRAME_HEIGHT, IMG_H)\nfake1 = pyfakewebcam.FakeWebcam('/dev/video1', IMG_W, IMG_H)\nfake2 = pyfakewebcam.FakeWebcam('/dev/video2', IMG_W, IMG_H)\nwhile True:\n    ret, frame = cam.read()\n    flipped = cv2.flip(frame, 1)\n    # Mirror effect\n    frame[0 : IMG_H, IMG_W//2 : IMG_W] = flipped[0 : IMG_H, IMG_W//2 : IMG_W]\n    fake1.schedule_frame(frame)\n    fake2.schedule_frame(flipped)\n    time.sleep(1/15.0)"
  },
  {
    "url": "https://stackoverflow.com/questions/5895792/why-is-using-a-stdmultiset-as-a-priority-queue-faster-than-using-a-stdpriori",
    "body": "#include <set>\n#include <type_traits>\n#include <vector>\n#include <chrono>\n#include <queue>\n#include <map>\n#include <iostream>\ntemplate<typename T>\nstruct Point {\n    static_assert(std::is_integral<T>::value || std::is_floating_point<T>::value, \"Incompatible type\");\n    using Type = T;\n    T x;\n    T y;\n};\ntemplate<typename T>\nstruct Node {\n    using Type = T;\n    Node<T> * left;\n    Node<T> * right;\n    T data;\n};\ntemplate <typename T>\nstruct NodePriority {\n    using Type = T;\n    using DataType = typename T::Type;\n    Node<T> * node = nullptr;\n    DataType priority = static_cast<DataType>(0);\n    bool operator < (const NodePriority<T> & n1) const noexcept {\n        return priority > n1.priority;\n    }\n    bool operator > (const NodePriority<T> & n1) const noexcept {\n        return priority < n1.priority;\n    }\n};\n// descending order by default\ntemplate <typename T>\nusing PriorityQueueList = std::priority_queue<T>;\n// greater used because of ascending order by default\ntemplate <typename T>\nusing MultisetList = std::multiset<T, std::greater<T>>;\n// greater used because of ascending order by default\ntemplate <typename T>\nusing MultimapList = std::multimap<typename T::DataType, T, std::greater<typename T::DataType>>;\nstruct Inner {\n    template<template <typename> class C, typename T>\n    static void Operate(C<T> & list, std::size_t priority);\n    template<typename T>\n    static void Operate(PriorityQueueList<T> & list, std::size_t priority) {\n        if (list.size() % 2 == 0) {\n            auto el = std::move(list.top());\n            el.priority = priority;\n            list.push(std::move(el));\n        }\n        else {\n            list.pop();\n        }\n    }\n    template<typename T>\n    static void Operate(MultisetList<T> & list, std::size_t priority) {\n        if (list.size() % 2 == 0) {\n            auto el = std::move(*list.begin());\n            el.priority = priority;\n            list.insert(std::move(el));\n        }\n        else {\n            list.erase(list.begin());\n        }\n    }\n    template<typename T>\n    static void Operate(MultimapList<T> & list, std::size_t priority) {\n        if (list.size() % 2 == 0) {\n            auto el = std::move(*list.begin());\n            auto & elFirst = const_cast<int&>(el.first);\n            elFirst = priority;\n            el.second.priority = priority;\n            list.insert(std::move(el));\n        }\n        else {\n            list.erase(list.begin());\n        }\n    }\n};\ntemplate<typename T>\nvoid doOperationOnPriorityList(T & list) {\n    for (std::size_t pos = 0, len = list.size(); pos < len; ++pos) {\n        // move top element and update priority\n        auto priority = std::rand() % 10;\n        Inner::Operate(list, priority);\n    }\n}\ntemplate<typename T>\nvoid measureOperationTime(T & list, std::size_t runsCount) {\n    std::chrono::system_clock::time_point t1, t2;\n    std::uint64_t totalTime(0);\n    for (std::size_t i = 0; i < runsCount; ++i) {\n        t1 = std::chrono::system_clock::now();\n        doOperationOnPriorityList(list);\n        t2 = std::chrono::system_clock::now();\n        auto castedTime = std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1).count();\n        std::cout << \"Run \" << i << \" time: \" << castedTime << \"\\n\";\n        totalTime += castedTime;\n    }\n    std::cout << \"Average time is: \" << totalTime / runsCount << \" ms\" << std::endl;\n}\nint main() {\n    // consts\n    const int kNodesCount = 10'000'000;\n    const int kRunsCount = 10;\n    // prepare data\n    PriorityQueueList<NodePriority<Point<int>>> neighboursList1;\n    MultisetList<NodePriority<Point<int>>> neighboursList2;\n    MultimapList<NodePriority<Point<int>>> neighboursList3;\n    std::vector<Node<Point<int>>> nodes;\n    nodes.reserve(kNodesCount);\n    for (auto i = 0; i < kNodesCount; ++i) {\n        nodes.emplace_back(decltype(nodes)::value_type{ nullptr, nullptr, { 0,0 } });\n        auto priority = std::rand() % 10;\n        neighboursList1.emplace(decltype(neighboursList1)::value_type{ &nodes.back(), priority });\n        neighboursList2.emplace(decltype(neighboursList2)::value_type{ &nodes.back(), priority });\n        neighboursList3.emplace(decltype(neighboursList3)::value_type{ priority, { &nodes.back(), priority } });\n    }\n    // do operation on data\n    std::cout << \"\\nPriority queue\\n\";\n    measureOperationTime(neighboursList1, kRunsCount);\n    std::cout << \"\\nMultiset\\n\";\n    measureOperationTime(neighboursList2, kRunsCount);\n    std::cout << \"\\nMultimap\\n\";\n    measureOperationTime(neighboursList3, kRunsCount);\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/5895792/why-is-using-a-stdmultiset-as-a-priority-queue-faster-than-using-a-stdpriori",
    "body": "Priority queue\nRun 0 time: 764\nRun 1 time: 933\nRun 2 time: 920\nRun 3 time: 813\nRun 4 time: 991\nRun 5 time: 862\nRun 6 time: 902\nRun 7 time: 1277\nRun 8 time: 774\nRun 9 time: 771\nAverage time is: 900 ms\nMultiset\nRun 0 time: 2235\nRun 1 time: 1811\nRun 2 time: 1755\nRun 3 time: 1535\nRun 4 time: 1475\nRun 5 time: 1388\nRun 6 time: 1482\nRun 7 time: 1431\nRun 8 time: 1347\nRun 9 time: 1347\nAverage time is: 1580 ms\nMultimap\nRun 0 time: 2197\nRun 1 time: 1885\nRun 2 time: 1725\nRun 3 time: 1671\nRun 4 time: 1500\nRun 5 time: 1403\nRun 6 time: 1411\nRun 7 time: 1420\nRun 8 time: 1409\nRun 9 time: 1362\nAverage time is: 1598 ms"
  },
  {
    "url": "https://stackoverflow.com/questions/5895792/why-is-using-a-stdmultiset-as-a-priority-queue-faster-than-using-a-stdpriori",
    "body": "Priority queue\nRun 0 time: 775\nRun 1 time: 995\nRun 2 time: 901\nRun 3 time: 807\nRun 4 time: 930\nRun 5 time: 765\nRun 6 time: 799\nRun 7 time: 1151\nRun 8 time: 760\nRun 9 time: 780\nAverage time is: 866 ms\nMultiset\nRun 0 time: 2280\nRun 1 time: 1942\nRun 2 time: 1607\nRun 3 time: 1344\nRun 4 time: 1319\nRun 5 time: 1210\nRun 6 time: 1129\nRun 7 time: 1156\nRun 8 time: 1244\nRun 9 time: 992\nAverage time is: 1422 ms\nMultimap\nRun 0 time: 2530\nRun 1 time: 1958\nRun 2 time: 1670\nRun 3 time: 1390\nRun 4 time: 1391\nRun 5 time: 1235\nRun 6 time: 1088\nRun 7 time: 1198\nRun 8 time: 1071\nRun 9 time: 963\nAverage time is: 1449 ms"
  },
  {
    "url": "https://stackoverflow.com/questions/58581500/how-to-fix-debugger-in-vscode-if-you-have-makefile-project-on-c",
    "body": "{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n\n        {\n            \"name\": \"Pusk\", //I named it Pusk because i can\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/Pusk\", //path to your programs exe and exe name\n            \"args\": [],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${workspaceFolder}\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"MIMode\": \"gdb\",\n            \"setupCommands\": [\n                {\n                    \"description\": \"Enable pretty-printing for gdb\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                }\n            ]\n        }\n    ]\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/58581500/how-to-fix-debugger-in-vscode-if-you-have-makefile-project-on-c",
    "body": "{\n    // See https://go.microsoft.com/fwlink/?LinkId=733558\n    // for the documentation about the tasks.json format\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n      {\n        \"label\": \"Build\",\n        \"type\": \"shell\",\n        \"command\": \"make\", //its like writing in console make //btw you can others commands like clean make build etc\n        \"group\": {\n          \"kind\": \"build\",\n          \"isDefault\": true\n        },\n        \"problemMatcher\": {\n          \"owner\": \"cpp\",\n          \"fileLocation\": [\"relative\", \"${workspaceFolder}\"],\n          \"pattern\": {\n            \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\",\n            \"file\": 1,\n            \"line\": 2,\n            \"column\": 3,\n            \"severity\": 4,\n            \"message\": 5\n          }\n        }\n      }\n    ]\n  }"
  },
  {
    "url": "https://stackoverflow.com/questions/3484260/opengl-line-width",
    "body": "vec4 pos;\nif (tri_i == 0 || tri_i == 1 || tri_i == 3)\n{\n    vec2 v_pred  = normalize(va[1].xy - va[0].xy);\n    vec2 v_miter = normalize(nv_line + vec2(-v_pred.y, v_pred.x));\n    pos = va[1];\n    pos.xy += v_miter * u_thickness * (tri_i == 1 ? -0.5 : 0.5) / dot(v_miter, nv_line);\n}\nelse\n{\n    vec2 v_succ  = normalize(va[3].xy - va[2].xy);\n    vec2 v_miter = normalize(nv_line + vec2(-v_succ.y, v_succ.x));\n    pos = va[2];\n    pos.xy += v_miter * u_thickness * (tri_i == 5 ? 0.5 : -0.5) / dot(v_miter, nv_line);\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/3484260/opengl-line-width",
    "body": "#include <vector>\n#include <string>\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <gl/gl_glew.h>\n#include <GLFW/glfw3.h>\nstd::string vertShader = R\"(\n#version 460\nlayout(std430, binding = 0) buffer TVertex\n{\n   vec4 vertex[];\n};\nuniform mat4  u_mvp;\nuniform vec2  u_resolution;\nuniform float u_thickness;\nvoid main()\n{\n    int line_i = gl_VertexID / 6;\n    int tri_i  = gl_VertexID % 6;\n    vec4 va[4];\n    for (int i=0; i<4; ++i)\n    {\n        va[i] = u_mvp * vertex[line_i+i];\n        va[i].xyz /= va[i].w;\n        va[i].xy = (va[i].xy + 1.0) * 0.5 * u_resolution;\n    }\n    vec2 v_line  = normalize(va[2].xy - va[1].xy);\n    vec2 nv_line = vec2(-v_line.y, v_line.x);\n    vec4 pos;\n    if (tri_i == 0 || tri_i == 1 || tri_i == 3)\n    {\n        vec2 v_pred  = normalize(va[1].xy - va[0].xy);\n        vec2 v_miter = normalize(nv_line + vec2(-v_pred.y, v_pred.x));\n        pos = va[1];\n        pos.xy += v_miter * u_thickness * (tri_i == 1 ? -0.5 : 0.5) / dot(v_miter, nv_line);\n    }\n    else\n    {\n        vec2 v_succ  = normalize(va[3].xy - va[2].xy);\n        vec2 v_miter = normalize(nv_line + vec2(-v_succ.y, v_succ.x));\n        pos = va[2];\n        pos.xy += v_miter * u_thickness * (tri_i == 5 ? 0.5 : -0.5) / dot(v_miter, nv_line);\n    }\n    pos.xy = pos.xy / u_resolution * 2.0 - 1.0;\n    pos.xyz *= pos.w;\n    gl_Position = pos;\n}\n)\";\nstd::string fragShader = R\"(\n#version 460\nout vec4 fragColor;\nvoid main()\n{\n    fragColor = vec4(1.0);\n}\n)\";\nGLuint CreateSSBO(std::vector<glm::vec4> &varray)\n{\n    GLuint ssbo;\n    glGenBuffers(1, &ssbo);\n    glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssbo );\n    glBufferData(GL_SHADER_STORAGE_BUFFER, varray.size()*sizeof(*varray.data()), varray.data(), GL_STATIC_DRAW);\n    return ssbo;\n}\nint main(void)\n{\n    if ( glfwInit() == 0 )\n        return 0;\n    GLFWwindow *window = glfwCreateWindow( 800, 600, \"GLFW OGL window\", nullptr, nullptr );\n    if ( window == nullptr )\n    {\n        glfwTerminate();\n        retturn 0;\n    }\n    glfwMakeContextCurrent(window);\n    if ( glewInit() != GLEW_OK )\n        return 0;\n    GLuint program  = CreateProgram(vertShader, fragShader);\n    GLint  loc_mvp  = glGetUniformLocation(program, \"u_mvp\");\n    GLint  loc_res  = glGetUniformLocation(program, \"u_resolution\");\n    GLint  loc_thi  = glGetUniformLocation(program, \"u_thickness\");\n    glUseProgram(program);\n    glUniform1f(loc_thi, 20.0);\n    GLushort pattern = 0x18ff;\n    GLfloat  factor  = 2.0f;\n    glm::vec4 p0(-1.0f, -1.0f, 0.0f, 1.0f);\n    glm::vec4 p1(1.0f, -1.0f, 0.0f, 1.0f);\n    glm::vec4 p2(1.0f, 1.0f, 0.0f, 1.0f);\n    glm::vec4 p3(-1.0f, 1.0f, 0.0f, 1.0f);\n    std::vector<glm::vec4> varray1{ p3, p0, p1, p2, p3, p0, p1 };\n    GLuint ssbo1 = CreateSSBO(varray1);\n    std::vector<glm::vec4> varray2;\n    for (int u=-8; u <= 368; u += 8)\n    {\n        double a = u*M_PI/180.0;\n        double c = cos(a), s = sin(a);\n        varray2.emplace_back(glm::vec4((float)c, (float)s, 0.0f, 1.0f));\n    }\n    GLuint ssbo2 = CreateSSBO(varray2);\n    GLuint vao;\n    glGenVertexArrays(1, &vao);\n    glBindVertexArray(vao);\n    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n    //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);\n    glm::mat4(project);\n    int vpSize[2]{0, 0};\n    while (!glfwWindowShouldClose(window))\n    {\n        int w, h;\n        glfwGetFramebufferSize(window, &w, &h);\n        if (w != vpSize[0] ||  h != vpSize[1])\n        {\n            vpSize[0] = w; vpSize[1] = h;\n            glViewport(0, 0, vpSize[0], vpSize[1]);\n            float aspect = (float)w/(float)h;\n            project = glm::ortho(-aspect, aspect, -1.0f, 1.0f, -10.0f, 10.0f);\n            glUniform2f(loc_res, (float)w, (float)h);\n        }\n        glClear(GL_COLOR_BUFFER_BIT);\n        glm::mat4 modelview1( 1.0f );\n        modelview1 = glm::translate(modelview1, glm::vec3(-0.6f, 0.0f, 0.0f) );\n        modelview1 = glm::scale(modelview1, glm::vec3(0.5f, 0.5f, 1.0f) );\n        glm::mat4 mvp1 = project * modelview1;\n        glUniformMatrix4fv(loc_mvp, 1, GL_FALSE, glm::value_ptr(mvp1));\n        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, ssbo1);\n        GLsizei N1 = (GLsizei)varray1.size()-2;\n        glDrawArrays(GL_TRIANGLES, 0, 6*(N1-1));\n        glm::mat4 modelview2( 1.0f );\n        modelview2 = glm::translate(modelview2, glm::vec3(0.6f, 0.0f, 0.0f) );\n        modelview2 = glm::scale(modelview2, glm::vec3(0.5f, 0.5f, 1.0f) );\n        glm::mat4 mvp2 = project * modelview2;\n        glUniformMatrix4fv(loc_mvp, 1, GL_FALSE, glm::value_ptr(mvp2));\n        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, ssbo2);\n        GLsizei N2 = (GLsizei)varray2.size()-2;\n        glDrawArrays(GL_TRIANGLES, 0, 6*(N2-1));\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n    glfwTerminate();\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/57458423/vs-code-not-recognizing-includes-from-includepath-during-build-intellisense-is",
    "body": "{\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"type\": \"cppbuild\",\n      \"label\": \"C/C++: g++-9 build active file ver(1)\",\n      \"command\": \"/usr/bin/g++-9\",\n      \"args\": [\n        \"-std=c++17\",\n        \"-I${workspaceFolder}/../..\",\n        \"-g\",\n        \"${workspaceFolder}/*.cpp\",\n        \"-o\",\n        \"${fileDirname}/${fileBasenameNoExtension}\"\n      ],\n      \"options\": {\n        \"cwd\": \"${fileDirname}\"\n      },\n      \"problemMatcher\": [\n        \"$gcc\"\n      ],\n      \"group\": {\n        \"kind\": \"build\",\n        \"isDefault\": true\n      },\n      \"detail\": \"compiler: /usr/bin/g++-9\"\n    }\n  ]\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/33304351/sdl2-fast-pixel-manipulation",
    "body": "c++\n// g++ main.cpp `pkg-config --cflags --libs sdl2`\n#include <SDL.h>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <chrono>\nvoid UpdateFrameTiming( std::ostream& os = std::cout, float period = 2.0f )\n{\n    static unsigned int frames = 0;\n    frames++;\n    static auto start = std::chrono::steady_clock::now();\n    auto end = std::chrono::steady_clock::now();\n    auto seconds = std::chrono::duration< float >( end - start ).count();\n    if( seconds >= period )\n    {\n        os\n            << frames << \" frames in \"\n            << std::setprecision( 1 ) << std::fixed << seconds << \" seconds = \"\n            << std::setprecision( 1 ) << std::fixed << frames / seconds << \" FPS (\"\n            << std::setprecision( 3 ) << std::fixed << seconds / frames * 1000.0 << \" ms/frame)\\n\";\n        frames = 0;\n        start = end;\n    }\n}\nint main( int, char** )\n{\n    SDL_Init( SDL_INIT_EVERYTHING );\n    SDL_Window* window = SDL_CreateWindow( \"SDL\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 600, 600, SDL_WINDOW_SHOWN );\n    SDL_Renderer* renderer = SDL_CreateRenderer( window, -1, SDL_RENDERER_ACCELERATED );\n    SDL_SetHint( SDL_HINT_RENDER_SCALE_QUALITY, \"1\" );\n\n    // dump renderer info\n    SDL_RendererInfo info;\n    SDL_GetRendererInfo( renderer, &info );\n    std::cout << \"Renderer name: \" << info.name << '\\n';\n    std::cout << \"Texture formats: \" << '\\n';\n    for( Uint32 i = 0; i < info.num_texture_formats; i++ )\n    {\n        std::cout << SDL_GetPixelFormatName( info.texture_formats[i] ) << '\\n';\n    }\n    // create texture\n    const unsigned int texWidth = 1024;\n    const unsigned int texHeight = 1024;\n    SDL_Texture* texture = SDL_CreateTexture( renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING, texWidth, texHeight );\n    std::vector< unsigned char > pixels( texWidth * texHeight * 4, 0 );\n    bool useLocktexture = false;\n    // main loop\n    bool running = true;\n    while( running )\n    {\n        SDL_SetRenderDrawColor( renderer, 0, 0, 0, SDL_ALPHA_OPAQUE );\n        SDL_RenderClear( renderer );\n        // handle events\n        SDL_Event ev;\n        while( SDL_PollEvent( &ev ) )\n        {\n            if( ( SDL_QUIT == ev.type ) ||\n                ( SDL_KEYDOWN == ev.type && SDL_SCANCODE_ESCAPE == ev.key.keysym.scancode ) )\n            {\n                running = false;\n                break;\n            }\n            if( SDL_KEYDOWN == ev.type && SDL_SCANCODE_L == ev.key.keysym.scancode )\n            {\n                useLocktexture = !useLocktexture;\n                std::cout << \"Using \" << ( useLocktexture ? \"SDL_LockTexture() + std::copy_n()\" : \"SDL_UpdateTexture()\" ) << '\\n';\n            }\n        }\n\n        // splat down some random pixels\n        for( unsigned int i = 0; i < 1000; i++ )\n        {\n            const unsigned int x = rand() % texWidth;\n            const unsigned int y = rand() % texHeight;\n            const unsigned int offset = ( texWidth * y * 4 ) + x * 4;\n            pixels[ offset + 0 ] = rand() % 256;        // b\n            pixels[ offset + 1 ] = rand() % 256;        // g\n            pixels[ offset + 2 ] = rand() % 256;        // r\n            pixels[ offset + 3 ] = SDL_ALPHA_OPAQUE;    // a\n        }\n        // update texture\n        if( useLocktexture )\n        {\n            unsigned char* lockedPixels = nullptr;\n            int pitch = 0;\n            SDL_LockTexture( texture, nullptr, reinterpret_cast< void** >( &lockedPixels ), &pitch );\n            std::copy_n( pixels.data(), pixels.size(), lockedPixels );\n            SDL_UnlockTexture( texture );\n        }\n        else\n        {\n            SDL_UpdateTexture( texture, nullptr, pixels.data(), texWidth * 4 );\n        }\n        SDL_RenderCopy( renderer, texture, nullptr, nullptr );\n        SDL_RenderPresent( renderer );\n\n        UpdateFrameTiming();\n    }\n    SDL_DestroyRenderer( renderer );\n    SDL_DestroyWindow( window );\n    SDL_Quit();\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/67908591/how-to-convert-boostasioawaitable-to-stdfuture",
    "body": "#include <boost/asio/io_context.hpp>\n#include <boost/asio/co_spawn.hpp>\n#include <boost/asio/use_future.hpp>\n#include <iostream>\n#include <future>\n#include <thread>\n#include <chrono>\nusing boost::asio::awaitable;\nusing boost::asio::co_spawn;\nusing boost::asio::io_context;\nusing boost::asio::use_future;\nawaitable<void> foo() {\n  // Simulate foo taking a while to run\n  std::this_thread::sleep_for(std::chrono::seconds(1));\n  std::cout << \"foo\\n\";\n  co_return;\n}\nint main() {\n  try {\n    io_context context;\n    std::future<void> fut = co_spawn(context, foo(), use_future);\n    std::thread waiter([fut=std::move(fut)](){\n        std::cout << \"AAA\\n\";\n        fut.wait();\n        std::cout << \"BBB\\n\";\n    });\n    context.run();\n    waiter.join();\n\n  } catch(const std::exception &ex) {\n    std::cerr << ex.what() << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/4291526/how-do-i-link-a-rc-resource-file-when-compiling-a-win32-app-with-gcc-through",
    "body": "{\n\t\"version\": \"2.0.0\",\n\t\"tasks\": [\n\t\t{\n\t\t\t\"type\": \"cppbuild\",\n\t\t\t\"label\": \"C/C++: cl.exe build active file\",\n\t\t\t\"command\": \"cl.exe\",\n\t\t\t\"args\": [\n\t\t\t\t\"/Zi\",\n\t\t\t\t\"/EHsc\",\n\t\t\t\t\"/Fe:\",\n\t\t\t\t\"${fileDirname}\\\\${fileBasenameNoExtension}.exe\",\n\t\t\t\t\"${file}\",\n\t\t\t\t\"/link /SUBSYSTEM:WINDOWS ${fileDirname}\\\\${fileBasenameNoExtension}.res\",\n\t\t\t],\n\t\t\t\"options\": {\n\t\t\t\t\"cwd\": \"${workspaceFolder}\"\n\t\t\t},\n\t\t\t\"problemMatcher\": [\n\t\t\t\t\"$msCompile\"\n\t\t\t],\n\t\t\t\"group\": {\n\t\t\t\t\"kind\": \"build\",\n\t\t\t\t\"isDefault\": true\n\t\t\t},\n\t\t\t\"detail\": \"compiler: cl.exe\"\n\t\t}\n\t]\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/2821012/how-to-write-curiously-recurring-templates-with-more-than-2-layers-of-inheritanc",
    "body": "template <typename LowestDerivedClass> class A {\npublic:\n  LowestDerivedClass &get() {\n    return *static_cast<LowestDerivedClass *>(this);\n  }\n  void print() {\n    cout << \"A\";\n  }\n};\ntemplate <typename LowestDerivedClass>\nclass Bbase : public A<LowestDerivedClass> {\npublic:\n  void print() {\n    cout << \"B\";\n    this->A<LowestDerivedClass>::print();\n  }\n};\nclass B : public Bbase<B> {};\nclass C : public Bbase<C> {\npublic:\n  void print() {\n    cout << \"C\";\n    this->Bbase<C>::print();\n  }\n};\nint main() {\n  C c;\n  c.print();\n  cout << endl;\n  B b;\n  b.print();\n  cout << endl;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/54632242/deleting-raw-pointers-from-stdvector",
    "body": "c++\ntemplate<class InputIt, class UnaryPredicate, class UnaryDeleter>\nInputIt delete_if(InputIt begin, InputIt end, UnaryPredicate p, UnaryDeleter d)\n{\n    auto const to_be_removed = std::stable_partition(begin, end, std::not_fn(p));\n    std::for_each(to_be_removed, end, [d](auto p) { d(p) ; delete p; });\n    return to_be_removed;\n}\ntemplate<class Container, class UnaryPredicate, class UnaryDeleter>\nauto delete_if(Container& c, UnaryPredicate p, UnaryDeleter d)\n{\n    using std::begin, std::end;\n    return c.erase(delete_if(begin(c), end(c), p, d), end(c));\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/4283731/plotting-package-for-c",
    "body": "#include <vector>\n    #include <cmath>\n    #include <boost/tuple/tuple.hpp>\n    #include \"gnuplot-iostream.h\"\n    int main() {\n    \tGnuplot gp;\n    \tstd::vector<boost::tuple<double, double, double, double> > pts_A;\n    \tstd::vector<double> pts_B_x;\n    \tstd::vector<double> pts_B_y;\n    \tstd::vector<double> pts_B_dx;\n    \tstd::vector<double> pts_B_dy;\n       \tfor(double alpha=0; alpha<1; alpha+=1.0/24.0) {\n    \t\tdouble theta = alpha*2.0*3.14159;\n    \t\tpts_A.push_back(boost::make_tuple(\n    \t\t\t cos(theta),\n    \t\t\t sin(theta),\n    \t\t\t-cos(theta)*0.1,\n    \t\t\t-sin(theta)*0.1\n    \t\t));\n\n    \t\tpts_B_x .push_back( cos(theta)*0.8);\n    \t\tpts_B_y .push_back( sin(theta)*0.8);\n    \t\tpts_B_dx.push_back( sin(theta)*0.1);\n    \t\tpts_B_dy.push_back(-cos(theta)*0.1);\n    \t}\n    \tgp << \"set xrange [-2:2]\\nset yrange [-2:2]\\n\";\n    \tgp << \"plot '-' with vectors title 'pts_A', '-' with vectors title 'pts_B'\\n\";\n    \tgp.send1d(pts_A);\n    \tgp.send1d(boost::make_tuple(pts_B_x, pts_B_y, pts_B_dx, pts_B_dy));\n    } // very simple tool right???"
  },
  {
    "url": "https://stackoverflow.com/questions/4283731/plotting-package-for-c",
    "body": "#include <stdlib.h>\n    #include <stdio.h>\n    #include <string.h>\n    #include \"engine.h\"\n    #define  BUFSIZE 256\n\n    int main()\n\n    {\n    \tEngine *ep;\n    \tmxArray *T = NULL, *result = NULL;\n    \tchar buffer[BUFSIZE+1];\n    \tdouble time[10] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0 };\n    \tif (!(ep = engOpen(\"\"))) {\n    \t\tfprintf(stderr, \"\\nCan't start MATLAB engine\\n\");\n    \t\treturn EXIT_FAILURE;\n    \t}\n    \tT = mxCreateDoubleMatrix(1, 10, mxREAL);\n    \tmemcpy((void *)mxGetPr(T), (void *)time, sizeof(time));\n    \tengPutVariable(ep, \"T\", T);\n        engEvalString(ep, \"D = .5.*(-9.8).*T.^2;\");\n    \tengEvalString(ep, \"plot(T,D);\");\n    \tengEvalString(ep, \"title('Position vs. Time for a falling object');\");\n    \tengEvalString(ep, \"xlabel('Time (seconds)');\");\n    \tengEvalString(ep, \"ylabel('Position (meters)');\");\n\n    \tprintf(\"Hit return to continue\\n\\n\");\n    \tfgetc(stdin);\n\n    \tprintf(\"Done for Part I.\\n\");\n    \tmxDestroyArray(T);\n    \tengEvalString(ep, \"close;\");\n\n    \tbuffer[BUFSIZE] = '\\0';\n    \tengOutputBuffer(ep, buffer, BUFSIZE);\n    \twhile (result == NULL) {\n    \t    char str[BUFSIZE+1];\n    \t    printf(\"Enter a MATLAB command to evaluate.  This command should\\n\");\n    \t    printf(\"create a variable X.  This program will then determine\\n\");\n    \t    printf(\"what kind of variable you created.\\n\");\n    \t    printf(\"For example: X = 1:5\\n\");\n    \t    printf(\">> \");\n\n    \t    fgets(str, BUFSIZE, stdin);\n    \t    engEvalString(ep, str);\n    \t    printf(\"%s\", buffer);\n    \t    printf(\"\\nRetrieving X...\\n\");\n    \t    if ((result = engGetVariable(ep,\"X\")) == NULL)\n    \t      printf(\"Oops! You didn't create a variable X.\\n\\n\");\n    \t    else {\n    \t\tprintf(\"X is class %s\\t\\n\", mxGetClassName(result));\n    \t    }\n    \t}\n    \tprintf(\"Done!\\n\");\n    \tmxDestroyArray(result);\n    \tengClose(ep);\n\n    \treturn EXIT_SUCCESS;\n    }"
  },
  {
    "url": "https://stackoverflow.com/questions/62409409/how-to-make-stdfilesystemdirectory-iterator-to-list-filenames-in-order",
    "body": "#include <iostream>\n#include <filesystem>\n#include <set>\n//--------------------------------------------------------------------------//\nusing namespace std;\nnamespace fs = std::filesystem;\n//--------------------------------------------------------------------------//\nint main() {\n  string path_name = \"/bin\";\n  //--- filenames are unique so we can use a set\n  set<fs::path> sorted_by_name;\n  for (auto &entry : fs::directory_iterator(path_name))\n    sorted_by_name.insert(entry.path());\n  //--- print the files sorted by filename\n  for (auto &filename : sorted_by_name)\n    cout << filename.c_str() << endl;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/62409409/how-to-make-stdfilesystemdirectory-iterator-to-list-filenames-in-order",
    "body": "#include <iostream>\n#include <filesystem>\n#include <chrono>\n#include <map>\n//--------------------------------------------------------------------------//\nusing namespace std;\n//--------------------------------------------------------------------------//\n//--- helper function convert timepoint to usable timestamp\ntemplate <typename TP>\ntime_t to_time_t(TP tp) {\n  using namespace chrono;\n  auto sctp = time_point_cast<system_clock::duration>(tp - TP::clock::now() + system_clock::now());\n  return system_clock::to_time_t(sctp);\n}\n//--------------------------------------------------------------------------//\nnamespace fs = std::filesystem;\nint main()\n{\n  string path_name = \"/bin\";\n  map<time_t, fs::directory_entry> sort_by_time;\n  //--- sort the files in the map by time\n  for (auto &entry : fs::directory_iterator(path_name))\n    if (entry.is_regular_file()) {\n      auto time = to_time_t(entry.last_write_time());\n      sort_by_time[time] = entry;\n    }\n  //--- print the files sorted by time\n  for (auto const &[time, entry] : sort_by_time) {\n    string timestamp = asctime(std::localtime(&time));\n    timestamp.pop_back(); // remove automatic linebreak\n    cout << timestamp << \"\\t \" << entry.path().c_str() << endl;\n  }\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/62409409/how-to-make-stdfilesystemdirectory-iterator-to-list-filenames-in-order",
    "body": "#include <iostream>\n#include <filesystem>\n#include <map>\n#include <cmath>\n//--------------------------------------------------------------------------//\nusing namespace std;\nnamespace fs = std::filesystem;\n//--------------------------------------------------------------------------//\n//--- helper function convert the filesize into something meaningful\nstruct HumanReadable { uintmax_t size {}; };\ntemplate <typename Os> Os& operator<< (Os& os, HumanReadable hr) {\n    int i{};\n    double mantissa = hr.size;\n    for (; mantissa >= 1024.; ++i) {\n        mantissa /= 1024.;\n    }\n    mantissa = std::ceil(mantissa * 10.) / 10.;\n    os << mantissa << \"BKMGTPE\"[i];\n    return i == 0 ? os : os << \"B (\" << hr.size << ')';\n}\n//--------------------------------------------------------------------------//\nint main() {\n  string path_name = \"/bin\";\n  map<uintmax_t, fs::directory_entry> sort_by_size;\n  //--- sort the files in the map by size\n  for (auto &entry : fs::directory_iterator(path_name))\n    if (entry.is_regular_file()) {\n      auto size = entry.file_size();\n      sort_by_size[size] = entry;\n    }\n  //--- print the files sorted by size\n  for (auto const &[size, entry] : sort_by_size)\n    cout << HumanReadable{size} << \"\\t \" << entry.path().c_str() << endl;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/59764049/set-operation-in-cupdate-existing-value",
    "body": "#include<iostream>\n#include<set>\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream &out, const std::set<T> &values)\n{\n  const char *sep = \"{ \";\n  for (const T &value : values) { out << sep << value; sep = \", \"; }\n  return out << \" }\";\n}\nint main()\n{\n  std::set<int> test{ 11, 12, 13, 14, 15 };\n  std::cout << \"test: \" << test << '\\n';\n  const int sub = 10;\n  std::set<int>::iterator iter = test.begin();\n  while (iter != test.end()) {\n    const int value = *iter;\n    iter = test.erase(iter);\n    test.insert(value - sub);\n  }\n  std::cout << \"test: \" << test << '\\n';\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/59764049/set-operation-in-cupdate-existing-value",
    "body": "#include<iostream>\n#include<set>\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream &out, const std::set<T> &values)\n{\n  const char *sep = \"{ \";\n  for (const T &value : values) { out << sep << value; sep = \", \"; }\n  return out << \" }\";\n}\nint main()\n{\n  std::set<int> test{ 11, 12, 13, 14, 15 };\n  std::cout << \"test: \" << test << '\\n';\n  const int add = 10;\n  std::set<int>::iterator iter = test.begin();\n  int n = 7;\n  while (iter != test.end()) {\n    if (n-- > 0) {\n      const int value = *iter;\n      iter = test.erase(iter);\n      test.insert(value + add);\n    } else ++iter;\n  }\n  std::cout << \"test: \" << test << '\\n';\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/39821367/very-fast-approximate-logarithm-natural-log-function-in-c",
    "body": "#include <cmath>\n#include <cstdint>\n#include <cstring>\nfloat __int_as_float (int32_t a) { float r; memcpy (&r, &a, sizeof r); return r;}\nint32_t __float_as_int (float a) { int32_t r; memcpy (&r, &a, sizeof r); return r;}\n/* compute natural logarithm, maximum error 0.85089 ulps */\nfloat my_logf (float a)\n{\n    float i, m, r, s, t;\n    int e;\n#if PORTABLE\n    m = frexpf (a, &e);\n    if (m < 0.666666667f) {\n        m = m + m;\n        e = e - 1;\n    }\n    i = (float)e;\n#else // PORTABLE\n    i = 0.0f;\n    if (a < 1.175494351e-38f){ // 0x1.0p-126\n        a = a * 8388608.0f; // 0x1.0p+23\n        i = -23.0f;\n    }\n    e = (__float_as_int (a) - __float_as_int (0.666666667f)) & 0xff800000;\n    m = __int_as_float (__float_as_int (a) - e);\n    i = fmaf ((float)e, 1.19209290e-7f, i); // 0x1.0p-23\n#endif // PORTABLE\n    /* m in [2/3, 4/3] */\n    m = m - 1.0f;\n    s = m * m;\n    /* Compute log1p(m) for m in [-1/3, 1/3] */\n    r =             -0.130310059f;  // -0x1.0ae000p-3\n    t =              0.140869141f;  //  0x1.208000p-3\n    r = fmaf (r, s, -0.121483512f); // -0x1.f198b2p-4\n    t = fmaf (t, s,  0.139814854f); //  0x1.1e5740p-3\n    r = fmaf (r, s, -0.166846126f); // -0x1.55b36cp-3\n    t = fmaf (t, s,  0.200120345f); //  0x1.99d8b2p-3\n    r = fmaf (r, s, -0.249996200f); // -0x1.fffe02p-3\n    r = fmaf (t, m, r);\n    r = fmaf (r, m,  0.333331972f); //  0x1.5554fap-2\n    r = fmaf (r, m, -0.500000000f); // -0x1.000000p-1\n    r = fmaf (r, s, m);\n    r = fmaf (i,  0.693147182f, r); //  0x1.62e430p-1 // log(2)\n    if (!((a > 0.0f) && (a < INFINITY))) {\n        r = a + a;  // silence NaNs if necessary\n        if (a  < 0.0f) r = INFINITY - INFINITY; //  NaN\n        if (a == 0.0f) r = -INFINITY;\n    }\n    return r;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/57672568/sdl2-on-raspberry-pi-without-x",
    "body": "    SDL2 Configure Summary:\n    Building Shared Libraries\n    Building Static Libraries\n    Enabled modules : atomic audio video render events joystick haptic sensor power filesystem threads timers file loadso cpuinfo assembly\n    Assembly Math   :\n    Audio drivers   : disk dummy oss alsa(dynamic) pulse(dynamic) sndio(dynamic)\n    Video drivers   : dummy rpi x11(dynamic) kmsdrm(dynamic) opengl opengl_es1 opengl_es2 vulkan wayland(dynamic)\n    X11 libraries   : xcursor xdbe xinerama xinput2 xinput2_multitouch xrandr xscrnsaver xshape xvidmode\n    Input drivers   : linuxev linuxkd\n    Using libsamplerate : YES\n    Using libudev       : YES\n    Using dbus          : YES\n    Using ime           : YES\n    Using ibus          : YES\n    Using fcitx         : YES"
  },
  {
    "url": "https://stackoverflow.com/questions/57672568/sdl2-on-raspberry-pi-without-x",
    "body": "    $ ./a.out\n    Testing video drivers...\n    The path /dev/dri/ cannot be opened or is not available\n    The path /dev/dri/ cannot be opened or is not available\n    SDL_VIDEODRIVER available: x11 wayland KMSDRM RPI dummy\n    SDL_VIDEODRIVER usable   : RPI\n    The path /dev/dri/ cannot be opened or is not available\n    The path /dev/dri/ cannot be opened or is not available\n    SDL_VIDEODRIVER selected : RPI\n    SDL_RENDER_DRIVER available: opengl opengles2 opengles software\n    SDL_RENDER_DRIVER selected : opengles2"
  },
  {
    "url": "https://stackoverflow.com/questions/57672568/sdl2-on-raspberry-pi-without-x",
    "body": "    # no envvars, fails:\n    $ ./a.out\n    Testing video drivers...\n    SDL_VIDEODRIVER available: x11 wayland KMSDRM RPI dummy\n    SDL_VIDEODRIVER usable   : KMSDRM\n    SDL_VIDEODRIVER selected : KMSDRM\n    SDL_CreateWindow(): Could not initialize OpenGL / GLES library\n    # with envvars, succeeds:\n    $ SDL_VIDEO_EGL_DRIVER=libEGL.so SDL_VIDEO_GL_DRIVER=libGLESv2.so ./a.out\n    Testing video drivers...\n    SDL_VIDEODRIVER available: x11 wayland KMSDRM RPI dummy\n    SDL_VIDEODRIVER usable   : KMSDRM\n    SDL_VIDEODRIVER selected : KMSDRM\n    SDL_RENDER_DRIVER available: opengl opengles2 opengles software\n    SDL_RENDER_DRIVER selected : opengl"
  },
  {
    "url": "https://stackoverflow.com/questions/57672568/sdl2-on-raspberry-pi-without-x",
    "body": "c++\n// g++ main.cpp `pkg-config --cflags --libs sdl2`\n#include <SDL.h>\n#include <iostream>\n#include <vector>\nint main( int argc, char** argv )\n{\n    SDL_Init( 0 );\n    std::cout << \"Testing video drivers...\" << '\\n';\n    std::vector< bool > drivers( SDL_GetNumVideoDrivers() );\n    for( int i = 0; i < drivers.size(); ++i )\n    {\n        drivers[ i ] = ( 0 == SDL_VideoInit( SDL_GetVideoDriver( i ) ) );\n        SDL_VideoQuit();\n    }\n    std::cout << \"SDL_VIDEODRIVER available:\";\n    for( int i = 0; i < drivers.size(); ++i )\n    {\n        std::cout << \" \" << SDL_GetVideoDriver( i );\n    }\n    std::cout << '\\n';\n    std::cout << \"SDL_VIDEODRIVER usable   :\";\n    for( int i = 0; i < drivers.size(); ++i )\n    {\n        if( !drivers[ i ] ) continue;\n        std::cout << \" \" << SDL_GetVideoDriver( i );\n    }\n    std::cout << '\\n';\n    if( SDL_Init( SDL_INIT_EVERYTHING ) < 0 )\n    {\n        std::cerr << \"SDL_Init(): \" << SDL_GetError() << '\\n';\n        return EXIT_FAILURE;\n    }\n    std::cout << \"SDL_VIDEODRIVER selected : \" << SDL_GetCurrentVideoDriver() << '\\n';\n    SDL_Window* window = SDL_CreateWindow(\n        \"SDL2\",\n        SDL_WINDOWPOS_UNDEFINED,\n        SDL_WINDOWPOS_UNDEFINED,\n        640,\n        480,\n        SDL_WINDOW_SHOWN );\n    if( nullptr == window )\n    {\n        std::cerr << \"SDL_CreateWindow(): \" << SDL_GetError() << '\\n';\n        return EXIT_FAILURE;\n    }\n    std::cout << \"SDL_RENDER_DRIVER available:\";\n    for( int i = 0; i < SDL_GetNumRenderDrivers(); ++i )\n    {\n        SDL_RendererInfo info;\n        SDL_GetRenderDriverInfo( i, &info );\n        std::cout << \" \" << info.name;\n    }\n    std::cout << '\\n';\n    SDL_Renderer* renderer = SDL_CreateRenderer(\n        window,\n        -1,\n        SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC );\n    if( nullptr == renderer )\n    {\n        std::cerr << \"SDL_CreateRenderer(): \" << SDL_GetError() << '\\n';\n        return EXIT_FAILURE;\n    }\n    SDL_RendererInfo info;\n    SDL_GetRendererInfo( renderer, &info );\n    std::cout << \"SDL_RENDER_DRIVER selected : \" << info.name << '\\n';\n    bool running = true;\n    while( running )\n    {\n        SDL_Event ev;\n        while( SDL_PollEvent( &ev ) )\n        {\n            if( SDL_QUIT == ev.type || SDL_KEYDOWN == ev.type )\n            {\n                running = false;\n            }\n        }\n        static int dir = 1;\n        static int i = 0;\n        i += dir;\n        if( i > 255 ) { i = 255; dir = -1; }\n        if( i < 0 ) { i = 0; dir = 1; }\n        SDL_SetRenderDrawColor( renderer, i, i, i, SDL_ALPHA_OPAQUE );\n        SDL_RenderClear( renderer );\n        SDL_RenderPresent( renderer );\n    }\n    SDL_DestroyRenderer( renderer );\n    SDL_DestroyWindow( window );\n    SDL_Quit();\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/4387288/convert-stdwstring-to-const-char-in-c",
    "body": "#include <cstdlib>\n// ...\nstd::wstring wStr;\nconst wchar_t *input = wStr.c_str();\n// Count required buffer size (plus one for null-terminator).\nsize_t size = (wcslen(input) + 1) * sizeof(wchar_t);\nchar *buffer = new char[size];\n#ifdef __STDC_LIB_EXT1__\n    // wcstombs_s is only guaranteed to be available if __STDC_LIB_EXT1__ is defined\n    size_t convertedSize;\n    std::wcstombs_s(&convertedSize, buffer, size, input, size);\n#else\n    std::wcstombs(buffer, input, size);\n#endif\n/* Use the string stored in \"buffer\" variable */\n// Free allocated memory:\ndelete buffer;"
  },
  {
    "url": "https://stackoverflow.com/questions/78282705/efficient-way-to-find-sum-of-largest-x-elements-in-a-subarray",
    "body": "c++\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <climits>\nstruct Node {\n    int count;\n    long long sum;\n    int left, right;\n};\nstd::vector<Node> tree{{}};\nstd::vector<int> roots{0};\nint minVal = INT_MAX, maxVal = INT_MIN;\nint update(int n, int l, int r, int val) {\n    if (l == r) {\n        tree.push_back({tree[n].count + 1, tree[n].sum + val});\n    } else {\n        int m = std::midpoint(l, r), lc = tree[n].left, rc = tree[n].right;\n        if (val <= m) lc = update(lc, l, m, val);\n        else rc = update(rc, m + 1, r, val);\n        tree.push_back({tree[lc].count + tree[rc].count, tree[lc].sum + tree[rc].sum, lc, rc});\n    }\n    return tree.size() - 1;\n}\nlong long query(int nl, int nr, int l, int r, int x) {\n    if (l == r) return (long long) l * x;\n    int m = std::midpoint(l, r), rightCount = tree[tree[nr].right].count - tree[tree[nl].right].count;\n    if (rightCount < x) return tree[tree[nr].right].sum - tree[tree[nl].right].sum + query(tree[nl].left, tree[nr].left, l, m, x - rightCount);\n    else return query(tree[nl].right, tree[nr].right, m + 1, r, x);\n}\n// Sum of the largest x elements in the subarray [ql, qr] (1-indexed)\nlong long querySumOfLargestX(int ql, int qr, int x) {\n    return query(roots[ql - 1], roots[qr], minVal, maxVal, x);\n}\nint main() {\n    std::cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    int n;\n    std::cin >> n;\n    std::vector<int> nums;\n    nums.reserve(n);\n    for (int i = 0, x; i < n; i++) {\n        std::cin >> x;\n        nums.push_back(x);\n        minVal = std::min(minVal, x);\n        maxVal = std::max(maxVal, x);\n    }\n    for (const int& num : nums)\n        roots.push_back(update(roots.back(), minVal, maxVal, num));\n    int q;\n    std::cin >> q;\n    for (int x, y; q--;) {\n        std::cin >> x >> y;\n        std::cout << querySumOfLargestX(1, y, x) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/64083104/making-python-generator-via-c20-coroutines",
    "body": "#include <coroutine>\n#include <exception>\n#include <string>\n#include <iostream>\nstruct generator_input {};\ntemplate <typename OutputType, typename InputType>\nstruct generator {\n    struct promise_type;\n    using coro_handle = std::coroutine_handle<promise_type>;\n    struct passthru_value\n    {\n        InputType &ret_;\n        bool await_ready() {return true;}\n        void await_suspend(coro_handle) {}\n        InputType &await_resume() { return ret_; }\n    };\n    struct promise_type {\n        OutputType current_value;\n        InputType input_value;\n        auto get_return_object() { return generator{coro_handle::from_promise(*this)}; }\n        auto initial_suspend() { return std::suspend_always{}; }\n        auto final_suspend() { return std::suspend_always{}; }\n        void unhandled_exception() { std::terminate(); }\n        auto yield_value(OutputType value) {\n            current_value = value;\n            return std::suspend_always{};\n        }\n        void return_void() {}\n        auto await_transform(generator_input)\n        {\n            return passthru_value{input_value};\n        }\n    };\n    bool next() { return coro ? (coro.resume(), !coro.done()) : false; }\n    OutputType value() { return coro.promise().current_value; }\n    void send(const InputType &input)\n    {\n        coro.promise().input_value = input;\n    }\n    void send(InputType &&input)\n    {\n        coro.promise().input_value = std::move(input);\n    }\n    generator(generator const & rhs) = delete;\n    generator(generator &&rhs)\n        :coro(rhs.coro)\n    {\n        rhs.coro = nullptr;\n    }\n    ~generator() {\n        if (coro)\n            coro.destroy();\n    }\nprivate:\n    generator(coro_handle h) : coro(h) {}\n    coro_handle coro;\n};\ngenerator<char, std::string> hello(){\n    auto word = co_await generator_input{};\n    for(auto &ch: word){\n        co_yield ch;\n    }\n}\nint main(int, char**)\n{\n    auto test = hello();\n    test.send(\"hello world\");\n    while(test.next())\n    {\n        std::cout << test.value() << ' ';\n    }\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/66261968/how-can-we-calculate-for-every-element-in-an-array-the-number-of-elements-to-t",
    "body": "#include <iostream>\n#include <vector>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n// I know this is kind of messy, but it's the general way to get a C++ indexed\n// multiset without using an external library\ntypedef tree <int, null_type, less_equal <int>, rb_tree_tag,\ntree_order_statistics_node_update> indexed_set;\nint main()\n{\n    int A_size;\n    cin >> A_size;\n    vector <int> A(A_size);\n    for(int i = 0; i < A_size; ++i){\n        cin >> A[i];\n    }\n    // Input Done\n    indexed_set nums;\n    vector <int> X(A_size);\n    for(int i = A_size - 1; i >= 0; --i){\n        // order_of_key returns the first index that A[i] would be at in a sorted list\n        // with the same elements as nums.\n        X[i] = nums.size() - nums.order_of_key(A[i]);\n        nums.insert(A[i]);\n    }\n    for(int item : X){\n        cout << item << \" \";\n    }\n    cout << \"\\n\";\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/32007188/detect-if-struct-has-padding",
    "body": "C++\n#include <array>\n#include <bit>\n#include <cstdint>\ntemplate <typename T>\nconsteval bool HasPadding() {\n  auto bytes = std::array<uint8_t, sizeof(T)>{};\n  const T reference = std::bit_cast<T>(std::array<uint8_t, sizeof(T)>{});\n  for (uint32_t i = 0; i < sizeof(T); ++i) {\n    bytes[i] = 1u;  // Perturb the object representation.\n    const T instance = std::bit_cast<T>(bytes);\n    if (instance == reference) {\n      return true;\n    }\n    bytes[i] = 0u;  // Restore the object representation.\n  }\n  return false;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/57082124/how-to-integrate-clang-tidy-to-cmake-and-gcc",
    "body": "set(ALL_CXX_WARNING_FLAGS --all-warnings -Weverything -Wno-c++98-compat -Wno-c++98-c++11-compat -Wno-c++98-c++11-c++14-compat -Wno-padded -Wno-c++98-compat-pedantic)\nset(CXX_COMPILE_OPTIONS \"-std=c++17;-O3;${ALL_CXX_WARNING_FLAGS}\" CACHE INTERNAL \"description\")\nset(CMAKE_CROSSCOMPILING True)\nset(CMAKE_TOOLCHAIN_FILE \"../cmake-scripts/toolchain_arm_clang.cmake\" CACHE FILEPATH \"CMake toolchain file\")\nset(CONFIG_SCRIPT_PRELOADED true CACHE BOOL \"Ensures that config script was preloaded\")\nset(build_test False)\nif(build_test)\n    message(STATUS \"Using test mode clang-tidy checks!\")\n    set(extra_clang_tidy_unchecks_for_tests_only \",-google-readability-avoid-underscore-in-googletest-name,-cppcoreguidelines-avoid-magic-numbers,-cppcoreguidelines-special-member-functions\")\nendif()\nset(CMAKE_CXX_CLANG_TIDY \"clang-tidy;--enable-check-profile;--checks=-*,abseil-string-find-startswith,bugprone-*,cert-*,clang-analyzer-*,cppcoreguidelines-*,google-*,hicpp-*,llvm-*,misc-*,modernize-*,-modernize-use-trailing-return-type,performance-*,readability-*,-readability-static-definition-in-anonymous-namespace,-readability-simplify-boolean-expr,portability-*${extra_clang_tidy_unchecks_for_tests_only}\" CACHE INTERNAL \"clang-tidy\")\nmessage(STATUS \"build_test: ${build_test}\")\nmessage(STATUS \"extra_clang_tidy_unchecks_for_tests_only: ${extra_clang_tidy_unchecks_for_tests_only}\")\nmessage(STATUS \"CMAKE_CXX_CLANG_TIDY: ${CMAKE_CXX_CLANG_TIDY}\")\n# We want to skip building tests when clang-tidy is run (it takes too much time and serves nothing)\nif(DEFINED CMAKE_CXX_CLANG_TIDY AND NOT build_test)\n    set(DO_NOT_BUILD_TESTS true CACHE BOOL \"Turns OFF building tests\")\n    set(DO_NOT_BUILD_BENCHMARKS true CACHE BOOL \"Turns OFF building benchmarks\")\nendif()\nunset(build_test)\nunset(extra_clang_tidy_unchecks_for_tests_only)\nset(EXPORT_PACKAGE_TO_GLOBAL_REGISTRY \"OFF\" CACHE INTERNAL \"We don't export clang-tidy-all version to global register\")"
  },
  {
    "url": "https://stackoverflow.com/questions/57082124/how-to-integrate-clang-tidy-to-cmake-and-gcc",
    "body": "set(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_VERSION 4.14.0)\nset(CMAKE_SYSTEM_PROCESSOR arm)\nset(gcc_version 8.3.0)\nset(x_tools \"/opt/zynq/xtl\")\nset(CMAKE_C_COMPILER \"clang\" CACHE INTERNAL STRING)\nset(CMAKE_CXX_COMPILER \"clang++\" CACHE INTERNAL STRING)\nset(CMAKE_RANLIB \"llvm-ranlib\" CACHE INTERNAL STRING)\nset(CMAKE_AR \"llvm-ar\" CACHE INTERNAL STRING)\nset(CMAKE_AS \"llvm-as\" CACHE INTERNAL STRING)\nset(CMAKE_LINKER \"ld.lld\" CACHE INTERNAL STRING)\nexecute_process(\n    COMMAND bash -c \"dirname `whereis ${CMAKE_LINKER} | tr -s ' ' '\\n' | grep ${CMAKE_LINKER}`\"\n    OUTPUT_VARIABLE cmake_linker_dir\n)\nstring(REGEX REPLACE \"\\n$\" \"\" cmake_linker_dir \"${cmake_linker_dir}\")\nset(cmake_linker_with_dir \"${cmake_linker_dir}/${CMAKE_LINKER}\" CACHE INTERNAL STRING)\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -iwithsysroot /include/c++/${gcc_version} -iwithsysroot /include/c++/${gcc_version}/arm-linux-musleabihf\" CACHE INTERNAL STRING)\nset(CMAKE_SYSROOT ${x_tools}/arm-linux-musleabihf)\nset(CMAKE_FIND_ROOT_PATH ${x_tools}/arm-linux-musleabihf)\nset(CMAKE_INSTALL_PREFIX ${x_tools}/arm-linux-musleabihf)\nset(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\nset(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY BOTH)\nset(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE BOTH)\nset(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE NEVER)\nset(triple arm-linux-musleabihf)\nset(CMAKE_LIBRARY_ARCHITECTURE ${triple})\nset(CMAKE_C_COMPILER_TARGET ${triple})\nset(CMAKE_CXX_COMPILER_TARGET ${triple})\nset(lib_path_arm ${x_tools}/arm-linux-musleabihf/lib)\n## Bootstrap library stuff:\nset(Scrt1_o ${lib_path_arm}/Scrt1.o)\nset(crti_o ${lib_path_arm}/crti.o)\nset(crtn_o ${lib_path_arm}/crtn.o)\nset(lib_path_gcc ${x_tools}/lib/gcc/${triple}/${gcc_version})\nset(crtbeginS_o ${lib_path_gcc}/crtbeginS.o)\nset(crtendS_o ${lib_path_gcc}/crtendS.o)\n# Clang as linker\n# --no-pie disable position independent executable, which is required when building\n# statically linked executables.\nset(CMAKE_CXX_LINK_EXECUTABLE \"clang++ --target=${triple} -Wl,--no-pie --sysroot=${CMAKE_SYSROOT} ${CMAKE_CXX_FLAGS} -fuse-ld=${cmake_linker_with_dir} <CMAKE_CXX_LINK_FLAGS> <LINK_FLAGS> <LINK_LIBRARIES> <OBJECTS> -o  <TARGET> \")\nset(CMAKE_CXX_CREATE_SHARED_LIBRARY \"clang++ -Wl, --target=${triple} --sysroot=${CMAKE_SYSROOT} ${CMAKE_CXX_FLAGS} -fuse-ld=${cmake_linker_with_dir} -shared <CMAKE_CXX_LINK_FLAGS> <LINK_FLAGS> <LINK_LIBRARIES> <OBJECTS> -o  <TARGET> \")\n#\n# Do not use CMAKE_CXX_CREATE_STATIC_LIBRARY -- it is created automatically\n# by cmake using ar and ranlib\n#\n#set(CMAKE_CXX_CREATE_STATIC_LIBRARY \"clang++ -Wl,--no-pie,--no-export-dynamic,-v -v --target=${triple} --sysroot=${CMAKE_SYSROOT} ${CMAKE_CXX_FLAGS} -fuse-ld=ld.lld <CMAKE_CXX_LINK_FLAGS> <LINK_FLAGS> <LINK_LIBRARIES> <OBJECTS> -o  <TARGET> \")\n## Linker as linker\nset(CMAKE_LINKER_ARM_COMPAT_STATIC \"-pie -EL -z relro -X --hash-style=gnu --eh-frame-hdr -m armelf_linux_eabi -dynamic-linker /lib/ld-musl-armhf.so.1 ${Scrt1_o} ${crti_o} ${crtbeginS_o} -lstdc++ -lm -lgcc_s -lgcc -lc ${crtendS_o} ${crtn_o}\")\nset(CMAKE_C_LINK_EXECUTABLE \"${CMAKE_LINKER} ${CMAKE_LINKER_ARM_COMPAT_STATIC} <CMAKE_C_LINK_FLAGS> <LINK_FLAGS> <LINK_LIBRARIES> <OBJECTS> -o  <TARGET>\")\n# Debian bug 708744(?)\n#include_directories(\"${CMAKE_SYSROOT}/usr/include/\")\n#include_directories(\"${CMAKE_SYSROOT}/usr/include/c++/${gcc_version}\")\n#include_directories(\"${CMAKE_SYSROOT}/usr/include/c++/${gcc_version}/${triple}\")\n## Clang workarounds:\nset(toolchain_lib_dir_0 \"${CMAKE_SYSROOT}/lib\")\nset(toolchain_lib_dir_1 \"${CMAKE_SYSROOT}/../lib\")\nset(toolchain_lib_dir_2 \"${CMAKE_SYSROOT}/../lib/gcc/${triple}/${gcc_version}\")\nset(CMAKE_TOOLCHAIN_LINK_FLAGS \"-L${toolchain_lib_dir_0} -L${toolchain_lib_dir_1} -L${toolchain_lib_dir_2}\")\n## CMake workarounds\nset(CMAKE_EXE_LINKER_FLAGS ${CMAKE_TOOLCHAIN_LINK_FLAGS} CACHE INTERNAL \"exe link flags\")\nset(CMAKE_MODULE_LINKER_FLAGS ${CMAKE_TOOLCHAIN_LINK_FLAGS} CACHE INTERNAL \"module link flags\")\nset(CMAKE_SHARED_LINKER_FLAGS ${CMAKE_TOOLCHAIN_LINK_FLAGS} CACHE INTERNAL \"shared link flags\")\nunset(cmake_linker_with_dir)\nunset(cmake_linker_dir)"
  },
  {
    "url": "https://stackoverflow.com/questions/61518284/error-non-const-static-data-member-must-be-initialized-out-of-line",
    "body": "#include <iostream>\nenum ArgCase1 { Case1 };\nenum ArgCase2 { Case2 };\nclass Solution {\n  public:\n    int m = 123;\n\n    Solution() = default; // will use m(123) implicitly\n    Solution(ArgCase1) { } // will use m(123) implicitly\n    Solution(ArgCase2): m(456) { } // default of m ignored\n};\n#define DEBUG(...) std::cout << #__VA_ARGS__ << \";\\n\"; __VA_ARGS__\nint main()\n{\n  DEBUG(Solution sol);\n  std::cout << \"sol.m: \" << sol.m << '\\n';\n  DEBUG(Solution sol1(Case1));\n  std::cout << \"sol1.m: \" << sol1.m << '\\n';\n  DEBUG(Solution sol2(Case2));\n  std::cout << \"sol2.m: \" << sol2.m << '\\n';\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/61708267/jump-bypasses-variable-initialization-in-switch-statement",
    "body": "c++\n#include <iostream>\n#include <string>\nint main() {\n    int choice = 0;\n    do {\n        std:: cout << \"Enter Choice\" << std::endl;\n        std:: cin >> choice;\n        switch(choice) {\n            case 1:\n                std::cout << \"Hi\";\n                break;\n            case 2: {  // Changed here\n                std::string str;\n                std::cin >> str;\n                break;\n            }\n            case 3: // `str` is not available here, no compilation error\n                std::cout << \"World\" << std:: endl;\n                break;\n            default:\n                std:: cout << \"Whatever\" << std:: endl;\n        }\n    } while(choice != 5);\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/35969730/how-to-read-output-from-cmd-exe-using-createprocess-and-createpipe",
    "body": "function ExecuteAndCaptureOutput(CommandLine: string): string;\nvar\n\tsecurityAttributes: TSecurityAttributes;\n\tstdOutRead, stdOutWrite: THandle;\n\tstartupInfo: TStartupInfo;\n\tpi: TProcessInformation;\n\tbuffer: AnsiString;\n\tbytesRead: DWORD;\n\tbRes: Boolean;\n\tle: DWORD;\nbegin\n\t{\n\t\tExecute a child process, and capture it's command line output.\n\t}\n\tResult := '';\n\tsecurityAttributes.nlength := SizeOf(TSecurityAttributes);\n\tsecurityAttributes.bInheritHandle := True;\n\tsecurityAttributes.lpSecurityDescriptor := nil;\n\tif not CreatePipe({var}stdOutRead, {var}stdOutWrite, @securityAttributes, 0) then\n\t\tRaiseLastOSError;\n\ttry\n\t\t// Set up members of the STARTUPINFO structure.\n\t\tstartupInfo := Default(TStartupInfo);\n\t\tstartupInfo.cb := SizeOf(startupInfo);\n\t\t// This structure specifies the STDIN and STDOUT handles for redirection.\n\t\tstartupInfo.dwFlags := startupInfo.dwFlags or STARTF_USESTDHANDLES; //The hStdInput, hStdOutput, and hStdError handles will be valid.\n\t\t\tstartupInfo.hStdInput := GetStdHandle(STD_INPUT_HANDLE); //don't forget to make it valid (zero is not valid)\n\t\t\tstartupInfo.hStdOutput := stdOutWrite; //give the console app the writable end of the pipe\n\t\t\tstartupInfo.hStdError := stdOutWrite; //give the console app the writable end of the pipe\n\t\t// We also want the console window to be hidden\n\t\tstartupInfo.dwFlags := startupInfo.dwFlags or STARTF_USESHOWWINDOW; //The nShowWindow member member will be valid.\n\t\t\tstartupInfo.wShowWindow := SW_HIDE; //default is that the console window is visible\n\t\t// Set up members of the PROCESS_INFORMATION structure.\n\t\tpi := Default(TProcessInformation);\n\t\t//WARNING: The Unicode version of CreateProcess can modify the contents of CommandLine.\n\t\t//Therefore CommandLine cannot point to read-only memory.\n\t\t//We can ensure it's not read-only with the RTL function UniqueString\n\t\tUniqueString({var}CommandLine);\n\t\tbRes := CreateProcess(nil, PChar(CommandLine), nil, nil, True, 0, nil, nil, startupInfo, {var}pi);\n\t\tif not bRes then\n\t\t\tRaiseLastOSError;\n\t\t//CreateProcess demands that we close these two populated handles when we're done with them. We're done with them.\n\t\tCloseHandle(pi.hProcess);\n\t\tCloseHandle(pi.hThread);\n\t\t{\n\t\t\tWe've given the console app the writable end of the pipe during CreateProcess; we don't need it anymore.\n\t\t\tWe do keep the handle for the *readable* end of the pipe; as we still need to read from it.\n\t\t\tThe other reason to close the writable-end handle now is so that there's only one out-standing reference to the writeable end: held by the console app.\n\t\t\tWhen the app closes, it will close the pipe, and ReadFile will return code 109 (The pipe has been ended).\n\t\t\tThat's how we'll know the console app is done. (no need to wait on process handles)\n\t\t}\n\t\tCloseHandle(stdOutWrite);\n\t\tstdOutWrite := 0;\n\t\tSetLength(buffer, 4096);\n\t\t//Read will return when the buffer is full, or if the pipe on the other end has been broken\n\t\twhile ReadFile(stdOutRead, buffer[1], Length(buffer), {var}bytesRead, nil) do\n\t\t\tResult := Result + string(Copy(buffer, 1, bytesRead));\n\t\t//ReadFile will either tell us that the pipe has closed, or give us an error\n\t\tle := GetLastError;\n\t\tif le <> ERROR_BROKEN_PIPE then //\"The pipe has been ended.\"\n\t\t\tRaiseLastOSError(le);\n\tfinally\n\t\tCloseHandle(stdOutRead);\n\t\tif stdOutWrite <> 0 then\n\t\t\tCloseHandle(stdOutWrite);\n\tend;\nend;"
  },
  {
    "url": "https://stackoverflow.com/questions/75778573/what-is-an-mdspan-and-what-is-it-used-for",
    "body": "template <typename T, typename Extents>\n   void print_3d_array(std::mdspan<T, Extents> ms3)\n   {\n     static_assert(ms3.rank() == 3, \"Unsupported rank\");\n     // read back using 3D view\n     for(size_t i=0; i != ms3.extent(0); i++) {\n       fmt::print(\"slice @ i = {}\\n\", i);\n       for(size_t j=0; j != ms3.extent(1); j++) {\n         for(size_t k=0; k != ms3.extent(2); k++)\n           fmt::print(\"{} \",  ms3[i, j, k]);\n         fmt::print(\"\\n\");\n       }\n     }\n   }\n\n   int main() {\n      int arr[2][3][2] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };\n      auto ms3 = std::mdspan(&arr[0][0][0], 2, 3, 2);\n        // Note: Not the most elegant construction\n      print_3d_array(ms3);\n   }"
  },
  {
    "url": "https://stackoverflow.com/questions/30867712/add-llvm-to-project-using-cmake",
    "body": "cmake_minimum_required(VERSION 3.4.3)\nproject(SimpleProject)\nfind_package(LLVM REQUIRED CONFIG)\nmessage(STATUS \"Found LLVM ${LLVM_PACKAGE_VERSION}\")\nmessage(STATUS \"Using LLVMConfig.cmake in: ${LLVM_DIR}\")\n# Set your project compile flags.\n# E.g. if using the C++ header files\n# you will need to enable C++11 support\n# for your compiler.\ninclude_directories(${LLVM_INCLUDE_DIRS})\nadd_definitions(${LLVM_DEFINITIONS})\n# Now build our tools\nadd_executable(simple-tool tool.cpp)\n# Find the libraries that correspond to the LLVM components\n# that we wish to use\nllvm_map_components_to_libnames(llvm_libs support core irreader)\n# Link against LLVM libraries\ntarget_link_libraries(simple-tool ${llvm_libs})"
  },
  {
    "url": "https://stackoverflow.com/questions/66922779/how-to-flatten-the-nested-stdoptional",
    "body": "template <typename F, typename G>\nconstexpr auto operator>=>(F f, G g) {\n    return [=]<typename T>(T t){\n        using R1 = std::remove_cvref_t<std::invoke_result_t<F, T>>;\n        static_assert(SpecializationOf<R1, std::optional>);\n        using R2 = std:remove_cvref_t<std::invoke_result_t<G, mp_first<R1>>>;\n        static_assert(SpecializationOf<R2, std::optional>);\n        if (auto o = std::invoke(f, t)) {\n            return std::invoke(g, *o);\n        } else {\n            // can't return nullopt here, have to specify the type\n            return R2();\n        }\n    };\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/64488186/why-does-strcmp-in-a-template-function-return-a-different-value",
    "body": ".LC0:\n        .string \"mom\"\n.LC1:\n        .string \"hi\"\na():\n        push    rbp\n        mov     rbp, rsp\n        mov     esi, OFFSET FLAT:.LC0\n        mov     edi, OFFSET FLAT:.LC1\n        call    int compare<3u, 4u>(char const (&) [3u], char const (&) [4u])\n        pop     rbp\n        ret\nb():\n        push    rbp\n        mov     rbp, rsp\n        mov     eax, -1\n        pop     rbp\n        ret\nint compare<3u, 4u>(char const (&) [3u], char const (&) [4u]):\n        push    rbp\n        mov     rbp, rsp\n        sub     rsp, 16\n        mov     QWORD PTR [rbp-8], rdi\n        mov     QWORD PTR [rbp-16], rsi\n        mov     rdx, QWORD PTR [rbp-16]\n        mov     rax, QWORD PTR [rbp-8]\n        mov     rsi, rdx\n        mov     rdi, rax\n        call    strcmp\n        leave\n        ret"
  },
  {
    "url": "https://stackoverflow.com/questions/56707123/how-to-suppress-clang-warnings-in-third-party-library-header-file-in-cmakelists",
    "body": "include_directories(SYSTEM ${CMAKE_CURRENT_SOURCE_DIR}/libs/imgui)\nset_target_properties(sfml-system PROPERTIES INTERFACE_SYSTEM_INCLUDE_DIRECTORIES $<TARGET_PROPERTY:sfml-system,INTERFACE_INCLUDE_DIRECTORIES>)\nset_target_properties(sfml-audio PROPERTIES INTERFACE_SYSTEM_INCLUDE_DIRECTORIES $<TARGET_PROPERTY:sfml-audio,INTERFACE_INCLUDE_DIRECTORIES>)\nset_target_properties(sfml-window PROPERTIES INTERFACE_SYSTEM_INCLUDE_DIRECTORIES $<TARGET_PROPERTY:sfml-window,INTERFACE_INCLUDE_DIRECTORIES>)\nset_target_properties(sfml-graphics PROPERTIES INTERFACE_SYSTEM_INCLUDE_DIRECTORIES $<TARGET_PROPERTY:sfml-graphics,INTERFACE_INCLUDE_DIRECTORIES>)"
  },
  {
    "url": "https://stackoverflow.com/questions/70308865/cannot-use-pointer-to-public-member-function-that-comes-from-a-private-base",
    "body": "c++\nint main() {\n  Derived d;\n  auto fn = &Derived::foo;\n  // cast to base (only legal with c-style cast)\n  // Base* b = static_cast<Base*>(&d); // not legal\n  // Base* b = reinterpret_cast<Base*>(&d); // not legal\n  Base* b = (Base*)&d; // legal\n  (b->*fn)(12);\n  // cast member function pointer to derived\n  // (also only legal with c-style cast)\n  using MemFn = int (Derived::*)(int) const;\n  // auto fnD = static_cast<MemFn>(fn); // not legal\n  // auto fnD = reinterpret_cast<MemFn>(fn); // not legal\n  auto fnD = (MemFn)fn; // legal\n  (d.*fnD)(12);\n  // or as a one liner (provided by @KamilCuk in the comments):\n  // slightly hard to read, but still legal c++:\n  (d.*((int(decltype(d)::*)(int))&decltype(d)::foo))(12); // legal\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/70308865/cannot-use-pointer-to-public-member-function-that-comes-from-a-private-base",
    "body": "c++\n  class Base {\n  public:\n      int foo(int x) const { return 2*x; }\n  };\n\n  class Derived : private Base {\n  public:\n      using Base::foo;\n  };\n\n  template<class T>\n  struct implementing_class_helper;\n\n  template<class T, class R>\n  struct implementing_class_helper<R T::*> {\n      typedef T type;\n  };\n\n  template<class T>\n  struct implementing_class : implementing_class_helper<typename std::remove_cv<T>::type> {\n\n  };\n  template<class T>\n  using implementing_class_t = implementing_class<T>;\n\n  int main() {\n    static_assert(std::is_same_v<\n      typename implementing_class<decltype(&Derived::foo)>::type,\n      Base\n    >, \"Shenanigans!\");\n  }"
  },
  {
    "url": "https://stackoverflow.com/questions/39490345/interleave-bits-efficiently",
    "body": "static const unsigned int B[] = {0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF};\nstatic const unsigned int S[] = {1, 2, 4, 8};\nunsigned int x; // Interleave lower 16 bits of x and y, so the bits of x\nunsigned int y; // are in the even positions and bits from y in the odd;\nunsigned int z; // z gets the resulting 32-bit Morton Number.\n                // x and y must initially be less than 65536.\nx = (x | (x << S[3])) & B[3];\nx = (x | (x << S[2])) & B[2];\nx = (x | (x << S[1])) & B[1];\nx = (x | (x << S[0])) & B[0];\ny = [the same thing on y]\nz = x | (y << 1);"
  },
  {
    "url": "https://stackoverflow.com/questions/67549023/why-is-the-gnu-scientific-library-matrix-multiplication-slower-than-numpy-matmul",
    "body": "110:   lea          0x80(%rsp),%rsi\n       add          $0x60,%rsi\n       mov          %r12,%rax\n       sar          $0x3,%rax\n       cmp          $0x2,%rax\n     ↓ jl           d26\n       prefetcht0   0x200(%rdi)          # Data prefetching\n       vmovups      -0x60(%rsi),%ymm1\n       prefetcht0   0xa0(%rsi)\n       vbroadcastsd -0x80(%rdi),%ymm0    # Fast SIMD instruction (AVX)\n       prefetcht0   0xe0(%rsi)\n       vmovups      -0x40(%rsi),%ymm2\n       prefetcht0   0x120(%rsi)\n       vmovups      -0x20(%rsi),%ymm3\n       vmulpd       %ymm0,%ymm1,%ymm4\n       prefetcht0   0x160(%rsi)\n       vmulpd       %ymm0,%ymm2,%ymm8\n       vmulpd       %ymm0,%ymm3,%ymm12\n       prefetcht0   0x1a0(%rsi)\n       vbroadcastsd -0x78(%rdi),%ymm0\n       vmulpd       %ymm0,%ymm1,%ymm5\n       vmulpd       %ymm0,%ymm2,%ymm9\n       [...]"
  },
  {
    "url": "https://stackoverflow.com/questions/73613280/how-can-i-implement-polymorphism-in-c-for-a-wrapper-class-that-will-hold-one-o",
    "body": "// if at least one operand is Error, return Error\nError operator+(const Error&, const Error&) { return {}; }\ntemplate<class T> Error operator+(const Error&, const T&) { return {}; }\ntemplate<class T> Error operator+(const T&, const Error&) { return {}; }\n// valid Number operations:\nNumber operator+(const Number&, const Number&) { /*impl*/ }\nString operator+(const Number&, const String&) { /*impl*/ }\n// anything else return Error\nError operator+(const Number&, const Hash&) { return {}; }\n// valid String operations:\nString operator+(const String&, const String&) { /*impl*/ }\nString operator+(const String&, const Number&) { /*impl*/ }\n// anything else return Error\nError operator+(const String&, const Hash&) { return {}; }\n// valid Hash operations:\nHash operator+(const Hash&, const Hash&) { /*impl*/ }\n// anything else return Error\nError operator+(const Hash&, const Number&) { return {}; }\nError operator+(const Hash&, const String&) { return {}; }"
  },
  {
    "url": "https://stackoverflow.com/questions/57671273/cmake-cannot-specify-include-directories-when-use-target-include-directories",
    "body": "add_executable(\n    ${PROJECT_NAME}\n\n    #other inclusion file cpp\n\n    #cpp-properties file include\n    include/cpp-properties/src/Properties.cpp\n    include/cpp-properties/src/PropertiesParser.cpp\n    include/cpp-properties/src/PropertiesUtils.cpp\n    #include bitcoin-cryptography-library\n    include/bitcoin-cryptography-library/cpp/Sha256.cpp\n    include/bitcoin-cryptography-library/cpp/Sha256Hash.cpp\n    include/bitcoin-cryptography-library/cpp/Utils.cpp\n    #include spycblocrpc\n    include/spycblockrpc/core/graph/TransactionGraph.cpp\n    include/spycblockrpc/core/graph/WrapperInformations.cpp\n    include/spycblockrpc/ConfiguratorSingleton.cpp\n    include/spycblockrpc/commands/DecodeScriptCommand.cpp\n    include/spycblockrpc/commands/DecodeRawTransaction.cpp\n    include/spycblockrpc/commands/HeightBlockchainCommand.cpp\n    include/spycblockrpc/commands/DecodeBlockAtIndexCommand.cpp\n)\n\ntarget_include_directories(${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>/include/rapidjson/include)"
  },
  {
    "url": "https://stackoverflow.com/questions/8841422/glreadpixels-data-argument-usage",
    "body": "lang-c++\n#include <GL/glut.h>\n#include <iostream>\nint mx = 0, my = 0;\nvoid display()\n{\n    glClearColor( 0, 0, 0, 1 );\n    glClear( GL_COLOR_BUFFER_BIT );\n    glMatrixMode( GL_PROJECTION );\n    glLoadIdentity();\n    glOrtho( -10, 10, -10, 10, -1, 1 );\n    glMatrixMode( GL_MODELVIEW );\n    glLoadIdentity();\n    glScalef( 5, 5, 5 );\n    glBegin( GL_TRIANGLES );\n    glColor3ub( 255, 0, 0 );\n    glVertex2f( -1, -1 );\n    glColor3ub( 0, 255, 0 );\n    glVertex2f( 1, -1 );\n    glColor3ub( 0, 0, 255 );\n    glVertex2f( 0, 1 );\n    glEnd();\n    // 4 bytes per pixel (RGBA), 1x1 bitmap\n    unsigned char pixels[ 1 * 1 * 4 ] = { 0 };\n    glReadPixels( mx, my, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, pixels );\n    std::cout << \"r: \" << static_cast< int >( pixels[ 0 ] ) << '\\n';\n    std::cout << \"g: \" << static_cast< int >( pixels[ 1 ] ) << '\\n';\n    std::cout << \"b: \" << static_cast< int >( pixels[ 2 ] ) << '\\n';\n    std::cout << \"a: \" << static_cast< int >( pixels[ 3 ] ) << '\\n' << std::endl;\n    glutSwapBuffers();\n}\nvoid mouse( int x, int y )\n{\n    mx = x;\n    my = glutGet( GLUT_WINDOW_HEIGHT ) - y;\n    glutPostRedisplay();\n}\nint main( int argc, char **argv )\n{\n    glutInit( &argc, argv );\n    glutInitDisplayMode( GLUT_RGBA | GLUT_DOUBLE );\n    glutInitWindowSize( 800, 600 );\n    glutCreateWindow( \"glReadPixels() example\" );\n    glutDisplayFunc( display );\n    glutPassiveMotionFunc( mouse );\n    glutMainLoop();\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/3772664/intersection-of-two-stdmaps",
    "body": "#include <map>\n#include <utility>\ntemplate <typename KeyType, typename LeftValue, typename RightValue>\nstd::map<KeyType, std::pair<LeftValue, RightValue>>\nIntersectMaps(const std::map<KeyType, LeftValue>& left,\n\t\t\t  const std::map<KeyType, RightValue>& right) {\n    std::map<KeyType, std::pair<LeftValue, RightValue>> result;\n    typename std::map<KeyType, LeftValue>::const_iterator il  = left.begin();\n    typename std::map<KeyType, RightValue>::const_iterator ir = right.begin();\n    while (il != left.end() && ir != right.end()) {\n        if (il->first < ir->first)\n            ++il;\n        else if (ir->first < il->first)\n            ++ir;\n        else {\n            result.insert(std::make_pair(il->first, std::make_pair(il->second, ir->second)));\n            ++il;\n            ++ir;\n        }\n    }\n    return result;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/79369634/what-does-the-to1-mean-in-the-concept-is-convertible-without-narrowing",
    "body": "template <typename From, typename To>\nconcept ConvertibleWithoutNarrowing = requires(From&& from) {\n        { static_cast<To>(std::forward<From>(from)) } -> std::convertible_to<To>;\n    } &&\n    []() constexpr {\n        if constexpr (std::is_integral_v<From> && std::is_integral_v<To>) {\n            return sizeof(From) <= sizeof(To);\n        } else if constexpr (std::is_floating_point_v<From> && std::is_integral_v<To>) {\n            return false;\n        } else {\n            return true;\n        }\n    }();"
  },
  {
    "url": "https://stackoverflow.com/questions/79539857/why-does-stdviewstake-while-do-so-many-function-invocations-even-with-c",
    "body": "template <class V>\nclass eager_common_view : public std::ranges::view_interface<eager_common_view<V>> {\n    V base_;\n    std::optional<std::ranges::iterator_t<V>> end_;\npublic:\n    eager_common_view(V v) : base_(std::move(v)) { }\n    auto begin() -> std::ranges::iterator_t<V> { return std::ranges::begin(base_); }\n    auto end() -> std::ranges::iterator_t<V> {\n        if (not end_) {\n            end_.emplace(std::ranges::next(begin(), std::ranges::end(base_)));\n        }\n        return *end_;\n    }\n};\nstruct EagerCommon : std::ranges::range_adaptor_closure<EagerCommon> {\n    template <std::ranges::viewable_range R>\n    constexpr auto operator()(R&& r) const {\n        if constexpr (std::ranges::common_range<R>) {\n            return std::views::all((R&&)r);\n        } else {\n            return eager_common_view(std::views::all((R&&)r));\n        }\n    }\n};\ninline constexpr EagerCommon eager_common;"
  },
  {
    "url": "https://stackoverflow.com/questions/63034484/how-to-create-stream-which-handles-both-input-and-output-in-c",
    "body": "pbase()                         pptr()                       epptr()\n     |                              |                             |\n------------------------------------------------------------------------\n  | 'H' | 'e' | 'l' | 'l' | 'o'  |     |     |     |     |     |     |\n------------------------------------------------------------------------\n     |                                                      |\n     --------------------------------------------------------\n                                 |\n                   allocated memory for the buffer\n           figure 2: output buffer (put area) with sample data"
  },
  {
    "url": "https://stackoverflow.com/questions/63034484/how-to-create-stream-which-handles-both-input-and-output-in-c",
    "body": "eback()                         gptr()                       egptr()\n     |                              |                             |\n------------------------------------------------------------------------\n  | 'H' | 'e' | 'l' | 'l' | 'o'  | ' ' | 'C' | '+' | '+' |     |     |\n------------------------------------------------------------------------\n     |                                                      |\n     --------------------------------------------------------\n                                 |\n                   allocated memory for the buffer\n           figure 3: input buffer (get area) with sample data"
  },
  {
    "url": "https://stackoverflow.com/questions/25270275/get-functions-names-in-a-shared-library-programmatically",
    "body": "`\n    auto library = dlopen(\"/path/to/lib.so\", RTLD_LAZY | RTLD_GLOBAL);\n    const char * libname = \"lib.so\";\n    struct link_map * map = nullptr;\n    dlinfo(library, RTLD_DI_LINKMAP, &map);\n    Elf64_Sym * symtab = nullptr;\n    char * strtab = nullptr;\n    int symentries = 0;\n    for (auto section = map->l_ld; section->d_tag != DT_NULL; ++section)\n    {\n        if (section->d_tag == DT_SYMTAB)\n        {\n            symtab = (Elf64_Sym *)section->d_un.d_ptr;\n        }\n        if (section->d_tag == DT_STRTAB)\n        {\n            strtab = (char*)section->d_un.d_ptr;\n        }\n        if (section->d_tag == DT_SYMENT)\n        {\n            symentries = section->d_un.d_val;\n        }\n    }\n    int size = strtab - (char *)symtab;\n    for (int k = 0; k < size / symentries; ++k)\n    {\n        auto sym = &symtab[k];\n        // If sym is function\n        if (ELF64_ST_TYPE(symtab[k].st_info) == STT_FUNC)\n        {\n            //str is name of each symbol\n            auto str = &strtab[sym->st_name];\n            printf(\"%s\\n\", str);\n        }\n    }"
  },
  {
    "url": "https://stackoverflow.com/questions/25270275/get-functions-names-in-a-shared-library-programmatically",
    "body": "`\nstatic int callback(struct dl_phdr_info *info, size_t size, void *data)\n{\n    // data is copy of 2nd arg in dl_iterate_phdr\n    // you can use it for your lib name as I did\n    const char * libname = (const char *)data;\n\n    // if current elf's name contains your lib\n    if (strstr(info->dlpi_name, libname))\n    {\n        printf(\"loaded %s from: %s\\n\", libname, info->dlpi_name);\n        for (int j = 0; j < info->dlpi_phnum; j++)\n        {\n            // we need to save dyanmic section since it contains symbolic table\n            if (info->dlpi_phdr[j].p_type == PT_DYNAMIC)\n            {\n                Elf64_Sym * symtab = nullptr;\n                char * strtab = nullptr;\n                int symentries = 0;\n                auto dyn = (Elf64_Dyn *)(info->dlpi_addr + info->dlpi_phdr[j].p_vaddr);\n                for (int k = 0; k < info->dlpi_phdr[j].p_memsz / sizeof(Elf64_Dyn); ++k)\n                {\n                    if (dyn[k].d_tag == DT_SYMTAB)\n                    {\n                        symtab = (Elf64_Sym *)dyn[k].d_un.d_ptr;\n                    }\n                    if (dyn[k].d_tag == DT_STRTAB)\n                    {\n                        strtab = (char*)dyn[k].d_un.d_ptr;\n                    }\n                    if (dyn[k].d_tag == DT_SYMENT)\n                    {\n                        symentries = dyn[k].d_un.d_val;\n                    }\n                }\n                int size = strtab - (char *)symtab;\n                // for each string in table\n                for (int k = 0; k < size / symentries; ++k)\n                {\n                    auto sym = &symtab[k];\n                    auto str = &strtab[sym->st_name];\n                    printf(\"%s\\n\", str);\n                }\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/18515275/can-cython-code-be-compiled-to-a-dll-so-c-application-can-call-it",
    "body": "//cyfun_dll.c\n#define BUILDING_DLL\n#include \"cyfun_dll.h\"\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n#include \"cyfun.h\"\nDLL_PUBLIC int cyfun_init(){\n  int status=PyImport_AppendInittab(\"cyfun\", PyInit_cyfun);\n  if(status==-1){\n    return -1;//error\n  }\n  Py_Initialize();\n  PyObject *module = PyImport_ImportModule(\"cyfun\");\n  if(module==NULL){\n     Py_Finalize();\n     return -1;//error\n  }\n  return 0;\n}\nDLL_PUBLIC void cyfun_finalize(){\n   Py_Finalize();\n}\nDLL_PUBLIC int cyfun_double_me(int me){\n    return double_me(me);\n}\nDLL_PUBLIC void cyfun_print_me(int me){\n    print_me(me);\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/18515275/can-cython-code-be-compiled-to-a-dll-so-c-application-can-call-it",
    "body": "BOOL WINAPI DllMain(\n    HINSTANCE hinstDLL,  // handle to DLL module\n    DWORD fdwReason,     // reason for calling function\n    LPVOID lpReserved )  // reserved\n{\n    // Perform actions based on the reason for calling.\n    switch( fdwReason )\n    {\n        case DLL_PROCESS_ATTACH:\n            return cyfun_init()==0;\n        case DLL_PROCESS_DETACH:\n            cyfun_finalize();\n            break;\n        case DLL_THREAD_ATTACH:\n         // Do thread-specific initialization.\n            break;\n        case DLL_THREAD_DETACH:\n         // Do thread-specific cleanup.\n            break;\n    }\n    return TRUE;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/66816741/why-does-this-c-style-cast-not-consider-static-cast-followed-by-const-cast",
    "body": "c++\ntree cp_build_c_cast(location_t loc, tree type, tree expr, tsubst_flags_t complain) {\n  tree value = expr;\n  tree result;\n  bool valid_p;\n  // [...]\n  /* A C-style cast can be a const_cast.  */\n  result = build_const_cast_1 (loc, type, value, complain & tf_warning,\n\t\t\t       &valid_p);\n  if (valid_p)\n    {\n      if (result != error_mark_node)\n\t{\n\t  maybe_warn_about_useless_cast (loc, type, value, complain);\n\t  maybe_warn_about_cast_ignoring_quals (loc, type, complain);\n\t}\n      return result;\n    }\n  /* Or a static cast.  */\n  result = build_static_cast_1 (loc, type, value, /*c_cast_p=*/true,\n\t\t\t\t&valid_p, complain);\n  /* Or a reinterpret_cast.  */\n  if (!valid_p)\n    result = build_reinterpret_cast_1 (loc, type, value, /*c_cast_p=*/true,\n\t\t\t\t       &valid_p, complain);\n  /* The static_cast or reinterpret_cast may be followed by a\n     const_cast.  */\n  if (valid_p\n      /* A valid cast may result in errors if, for example, a\n\t conversion to an ambiguous base class is required.  */\n      && !error_operand_p (result))\n  {\n    tree result_type;\n    maybe_warn_about_useless_cast (loc, type, value, complain);\n    maybe_warn_about_cast_ignoring_quals (loc, type, complain);\n    /* Non-class rvalues always have cv-unqualified type.  */\n    if (!CLASS_TYPE_P (type))\n\t  type = TYPE_MAIN_VARIANT (type);\n    result_type = TREE_TYPE (result);\n    if (!CLASS_TYPE_P (result_type) && !TYPE_REF_P (type))\n\t  result_type = TYPE_MAIN_VARIANT (result_type);\n    /* If the type of RESULT does not match TYPE, perform a\n\t  const_cast to make it match.  If the static_cast or\n\t  reinterpret_cast succeeded, we will differ by at most\n\t  cv-qualification, so the follow-on const_cast is guaranteed\n\t  to succeed.  */\n    if (!same_type_p (non_reference (type), non_reference (result_type)))\n\t{\n\t  result = build_const_cast_1 (loc, type, result, false, &valid_p);\n\t  gcc_assert (valid_p);\n\t}\n    return result;\n  }\n  return error_mark_node;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/64378721/what-is-the-difference-between-the-copy-constructor-and-move-constructor-in-c",
    "body": "c++\nclass MyIntArray\n{\nprivate:\n    int *arr = nullptr;\n    int size = 0;\npublic:\n    MyIntArray() = default;\n    MyIntArray(int size) {\n        arr = new int[size];\n        this->size = size;\n        for(int i = 0; i < size; ++i) {\n            arr[i] = i;\n        }\n    }\n    // copy constructor\n    MyIntArray(const MyIntArray &src) {\n        // allocate a new copy of the array...\n        arr = new int[src.size];\n        size = src.size;\n        for(int i = 0; i < src.size; ++i) {\n            arr[i] = src.arr[i];\n        }\n    }\n    // move constructor\n    MyIntArray(MyIntArray &&src) {\n        // just swap the array pointers...\n        src.swap(*this);\n    }\n    ~MyIntArray() {\n        delete[] arr;\n    }\n    // copy assignment operator\n    MyIntArray& operator=(const MyIntArray &rhs) {\n        if (&rhs != this) {\n            MyIntArray temp(rhs); // copies the array\n            temp.swap(*this);\n        }\n        return *this;\n    }\n    // move assignment operator\n    MyIntArray& operator=(MyIntArray &&rhs) {\n        MyIntArray temp(std::move(rhs)); // moves the array\n        temp.swap(*this);\n        return *this;\n    }\n    /*\n    or, the above 2 operators can be implemented as 1 operator, like below.\n    This allows the caller to decide whether to construct the rhs parameter\n    using its copy constructor or move constructor...\n    MyIntArray& operator=(MyIntArray rhs) {\n        rhs.swap(*this);\n        return *this;\n    }\n    */\n    void swap(MyIntArray &other) {\n        // swap the array pointers...\n        std::swap(arr, other.arr);\n        std::swap(size, other.size);\n    }\n};"
  },
  {
    "url": "https://stackoverflow.com/questions/64378721/what-is-the-difference-between-the-copy-constructor-and-move-constructor-in-c",
    "body": "c++\nvoid copyArray(const MyIntArray &src)\n{\n    MyIntArray arr(src); // copies the array\n    // use arr as needed...\n}\nvoid moveArray(MyIntArray &&src)\n{\n    MyIntArray arr(std::move(src)); // moved the array\n    // use arr as needed...\n}\nMyIntArray arr1(5);                // creates a new array\nMyIntArray arr2(arr1);             // copies the array\nMyIntArray arr3(std::move(arr2));  // moves the array\nMyIntArray arr4;                   // default construction\narr4 = arr3;                       // copies the array\narr4 = std::move(arr3);            // moves the array\narr4 = MyIntArray(1);              // creates a new array and moves it\ncopyArray(arr4);                   // copies the array\nmoveArray(std::move(arr4));        // moves the array\ncopyArray(MyIntArray(10));         // creates a new array and copies it\nmoveArray(MyIntArray(10));         // creates a new array and moves it"
  },
  {
    "url": "https://stackoverflow.com/questions/51433937/how-to-compile-debug-a-c-application-in-docker-with-visual-studio-code-on-wind",
    "body": "{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"(gdb) Docker\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"build/apps/program\",\n            \"args\": [],\n            \"stopAtEntry\": true,\n            \"cwd\": \"/work\",\n            \"environment\": [],\n            \"externalConsole\": true,\n            \"preLaunchTask\": \"make debug\",\n            \"targetArchitecture\": \"x64\",\n            \"sourceFileMap\": { \"/work\": \"${workspaceFolder}\" },\n            \"pipeTransport\": {\n                \"debuggerPath\": \"/usr/bin/gdb\",\n                \"pipeProgram\": \"docker.exe\",\n                \"pipeArgs\": [\"run\",\"--rm\",\"--interactive\",\"--volume\",\"${workspaceFolder}:/work\",\"--workdir\",\"/work\",\"--privileged\",\"gdb\",\"sh\",\"-c\"],\n                \"pipeCwd\": \"\"\n            },\n            \"MIMode\": \"gdb\",\n            \"setupCommands\": [\n                {\n                    \"description\": \"Enable pretty-printing for gdb\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                }\n            ]\n        }\n    ]\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/75442605/c20-concepts-constraint-normalization",
    "body": "c++\ntemplate<class T> constexpr bool always_true = true;\n// Atomic constraint: always_true<X>\n// Parameter mapping: X ↦ T (identity)\ntemplate<class T> concept Base = always_true<T>;\n// Atomic constraint: always_true<X>\n// Parameter mapping: X ↦ U (identity)\ntemplate<class U> concept Foo = Base<U>;\n// Atomic constraint: always_true<X>\n// Parameter mapping: X ↦ V::type\ntemplate<class V> concept Bar = Base<typename V::type>;\n// Atomic constraint: always_true<X>\n// Parameter mapping: X ↦ W&&\ntemplate<class W> concept Baz = Base<W&&>;"
  },
  {
    "url": "https://stackoverflow.com/questions/75442605/c20-concepts-constraint-normalization",
    "body": "c++\ntemplate<class T> constexpr bool always_true = true;\n// well-formed\n// Atomic constraint: always_true<X>\n// Parameter mapping: X ↦ T (identity)\ntemplate<class T> concept Base = always_true<T>;\n// well-formed\n// Atomic constraint: always_true<X>\n// Parameter mapping: X ↦ U::type\ntemplate<class U> concept Foo = Base<typename U::type>;\n// ill-formed, ndr (invalid parameter mapping)\n// Atomic constraint: always_true<X>\n// Parameter mapping: X ↦ V*::type\ntemplate<class V> concept Bar = Foo<V*>;\n// ill-formed, ndr (invalid parameter mapping)\n// Atomic constraint: always_true<X>\n// Parameter mapping: X ↦ W&*\ntemplate<class W> concept Baz = Foo<W&>;"
  },
  {
    "url": "https://stackoverflow.com/questions/51431425/how-to-recursively-copy-files-and-directories",
    "body": "// Recursively copies those files and folders from src to target which matches\n// predicate, and overwrites existing files in target.\nvoid CopyRecursive(const fs::path& src, const fs::path& target,\n                    const std::function<bool(fs::path)>& predicate /* or use template */) noexcept\n{\n    try\n    {\n        for (const auto& dirEntry : fs::recursive_directory_iterator(src))\n        {\n            const auto& p = dirEntry.path();\n            if (predicate(p))\n            {\n                // Create path in target, if not existing.\n                const auto relativeSrc = fs::relative(p, src);\n                const auto targetParentPath = target / relativeSrc.parent_path();\n                fs::create_directories(targetParentPath);\n                // Copy to the targetParentPath which we just created.\n                fs::copy(p, targetParentPath, fs::copy_options::overwrite_existing);\n            }\n        }\n    }\n    catch (std::exception& e)\n    {\n        std::cout << e.what();\n    }\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/44558568/how-to-iterate-through-a-qstringlist",
    "body": "#include <QStringList>\n#include <QDebug>\n#include <QDir>\nint main()\n{\n    const QString     root { \"C:/Test\" };\n    const QStringList dirs { \"A\", \"B\" };\n    QDir rootDir { root };\n    qDebug() << \"Root Path:\" << rootDir.absolutePath();\n    qDebug() << \"Root List:\" << rootDir.entryList( QDir::Dirs ) << '\\n';\n    for ( const auto& dir : dirs )\n    {\n        if ( rootDir.cd(dir) )\n        {\n            qDebug() << \"Dir Path:\" << rootDir.absolutePath();\n            qDebug() << \"Dir List:\" << rootDir.entryList( QDir::Files ) << '\\n';\n        }\n        rootDir.cdUp();\n        qDebug() << \"cding...\";\n        qDebug() << \"Dir Path:\" << rootDir.absolutePath() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/69290986/gdb-keeps-downloading-debug-info",
    "body": "debuginfod_find_debuginfo(), debuginfod_find_executable(), and debuginfod_find_source()\nquery the debuginfod server URLs contained in $DEBUGINFOD_URLS\n(see below) for the debuginfo ...\n...\nCACHE\nIf the query is successful, the debuginfod_find_*() functions save the target\nfile to a local cache. The location of the cache is controlled by the\n$DEBUGINFOD_CACHE_PATH environment variable (see below).\nCleaning of the cache is controlled by the cache_clean_interval_s and\nmax_unused_age_s files, which are found in the $DEBUGINFOD_CACHE_PATH directory.\ncache_clean_interval_s controls how frequently the cache is traversed for cleaning\nand max_unused_age_s controls how long a file can go unused\n(fstat(2) atime) before it's removed from the cache during cleaning."
  },
  {
    "url": "https://stackoverflow.com/questions/21872229/how-to-edit-and-re-build-the-gcc-libstdc-c-standard-library-source",
    "body": "configure: WARNING: using in-tree isl, disabling version check\n*** This configuration is not supported in the following subdirectories:\n     gnattools gotools target-libada target-libphobos target-zlib target-libbacktrace target-libgfortran target-libgo target-libffi target-libobjc target-liboffloadmic\n    (Any other directories should still work fine.)\nchecking for default BUILD_CONFIG... bootstrap-debug\nchecking for --enable-vtable-verify... no\n/usr/bin/ld: cannot find Scrt1.o: No such file or directory\n/usr/bin/ld: cannot find crti.o: No such file or directory\n/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-linux-gnu/11/libgcc.a when searching for -lgcc\n/usr/bin/ld: cannot find -lgcc: No such file or directory\n/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-linux-gnu/11/libgcc.a when searching for -lgcc\n/usr/bin/ld: cannot find -lgcc: No such file or directory\ncollect2: error: ld returned 1 exit status\nconfigure: error: I suspect your system does not have 32-bit development libraries (libc and headers). If you have them, rerun configure with --enable-multilib. If you do not have them, and want to build a 64-bi\nt-only compiler, rerun configure with --disable-multilib."
  },
  {
    "url": "https://stackoverflow.com/questions/8511598/large-negative-integer-literals",
    "body": "#include <iostream>\n#include <climits>\nconst char *type_of(int)                { return \"int\"; }\nconst char *type_of(unsigned int)       { return \"unsigned int\"; }\nconst char *type_of(long)               { return \"long\"; }\nconst char *type_of(unsigned long)      { return \"unsigned long\"; }\nconst char *type_of(long long)          { return \"long long\"; }\nconst char *type_of(unsigned long long) { return \"unsigned long long\"; }\nint main()\n{\n    std::cout << \"int: \" << INT_MIN << \" .. \" << INT_MAX << \"\\n\";\n    std::cout << \"long: \" << LONG_MIN << \" .. \" << LONG_MAX << \"\\n\";\n    std::cout << \"long long: \" << LLONG_MIN << \" .. \" << LLONG_MAX << \"\\n\";\n    std::cout << \"2147483647 is of type \" << type_of(2147483647) << \"\\n\";\n    std::cout << \"2147483648 is of type \" << type_of(2147483648) << \"\\n\";\n    std::cout << \"-2147483647 is of type \" << type_of(-2147483647) << \"\\n\";\n    std::cout << \"-2147483648 is of type \" << type_of(-2147483648) << \"\\n\";\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/62918059/why-is-boosts-quicksort-slower-compared-to-julias-quicksort",
    "body": "@inline function selectpivot!(v::AbstractVector, lo::Integer, hi::Integer, o::Ordering)\n    @inbounds begin\n        mi = midpoint(lo, hi)\n        # sort v[mi] <= v[lo] <= v[hi] such that the pivot is immediately in place\n        if lt(o, v[lo], v[mi])\n            v[mi], v[lo] = v[lo], v[mi]\n        end\n        if lt(o, v[hi], v[lo])\n            if lt(o, v[hi], v[mi])\n                v[hi], v[lo], v[mi] = v[lo], v[mi], v[hi]\n            else\n                v[hi], v[lo] = v[lo], v[hi]\n            end\n        end\n        # return the pivot\n        return v[lo]\n    end\nend\nfunction partition!(v::AbstractVector, lo::Integer, hi::Integer, o::Ordering)\n    pivot = selectpivot!(v, lo, hi, o)\n    # pivot == v[lo], v[hi] > pivot\n    i, j = lo, hi\n    @inbounds while true\n        i += 1; j -= 1\n        while lt(o, v[i], pivot); i += 1; end;\n        while lt(o, pivot, v[j]); j -= 1; end;\n        i >= j && break\n        v[i], v[j] = v[j], v[i]\n    end\n    v[j], v[lo] = pivot, v[j]\n    # v[j] == pivot\n    # v[k] >= pivot for k > j\n    # v[i] <= pivot for i < j\n    return j\nend\nfunction sort!(v::AbstractVector, lo::Integer, hi::Integer, a::QuickSortAlg, o::Ordering)\n    @inbounds while lo < hi\n        hi-lo <= SMALL_THRESHOLD && return sort!(v, lo, hi, SMALL_ALGORITHM, o)\n        j = partition!(v, lo, hi, o)\n        if j-lo < hi-j\n            # recurse on the smaller chunk\n            # this is necessary to preserve O(log(n))\n            # stack space in the worst case (rather than O(n))\n            lo < (j-1) && sort!(v, lo, j-1, a, o)\n            lo = j+1\n        else\n            j+1 < hi && sort!(v, j+1, hi, a, o)\n            hi = j-1\n        end\n    end\n    return v\nend"
  },
  {
    "url": "https://stackoverflow.com/questions/66268136/how-to-replace-the-deprecated-function-qwheeleventdelta-in-the-zoom-in-z",
    "body": "void MapView::wheelEvent(QWheelEvent *event)\n{\n    if(event->angleDelta().y() > 0)\n    {\n        if(m_scale < MAX_SCALE)\n        {\n            std::cout << m_scale << std::endl;\n            this->scale(ZOOM_STEP, ZOOM_STEP);\n            m_scale *= ZOOM_STEP;\n        }\n    }\n    else if(event->angleDelta().y() < 0)\n    {\n        if(m_scale >= MIN_SCALE)\n        {\n            std::cout << m_scale << std::endl;\n            this->scale(1/ZOOM_STEP, 1/ZOOM_STEP);\n            m_scale *= 1/ZOOM_STEP;\n        }\n    }\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/72877471/c-confusing-closure-captures-v-vs-v-v",
    "body": "#include <functional>\n#include <iostream>\n#include <typeinfo>\n#include <type_traits>\nstruct tracer {\n  tracer() { std::cout << \"default constructed\\n\"; }\n  tracer(const tracer &) { std::cout << \"copy constructed\\n\"; }\n  tracer(tracer &&) { std::cout << \"move constructed\\n\"; }\n  template<typename T> tracer(T &&t) {\n    if constexpr (std::is_same_v<T, const tracer>)\n      std::cout << \"template constructed (const rvalue)\\n\";\n    else if constexpr (std::is_same_v<T, tracer&>)\n      std::cout << \"template constructed (lvalue)\\n\";\n    else\n      std::cout << \"template constructed (other [\"\n                << typeid(T).name() << \"])\\n\";\n  }\n};\nint\nmain()\n{\n  using fn_t = std::function<void()>;\n  const tracer t;\n  std::cout << \"==== value capture ====\\n\";\n  fn_t([t]() {});\n  std::cout << \"==== init capture ====\\n\";\n  fn_t([t = t]() {});\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/21946447/how-much-performance-difference-when-using-string-vs-char-array",
    "body": "static void CharArray(benchmark::State& state) {\n  const char*const  baseLocation = \"baseLocation\";\n  for (auto _ : state) {\n    char fname[255] = {};\n    snprintf(fname, 255, \"%s_test_no.%lu.txt\", baseLocation, state.iterations());\n    benchmark::DoNotOptimize(fname);\n  }\n}\nBENCHMARK(CharArray);\nstatic void String(benchmark::State& state) {\n  const std::string baseLocation = \"baseLocation\";\n  for (auto _ : state) {\n    benchmark::DoNotOptimize(\n    baseLocation + \"_test_no.\" + std::to_string(state.iterations()) + \".txt\"\n    );\n  }\n}\nBENCHMARK(String);"
  },
  {
    "url": "https://stackoverflow.com/questions/70606173/what-are-monadic-bind-and-monadic-return-for-c23-optional",
    "body": "    auto safeSqrt = [](auto const& x) {\n        return x > 0 ? std::optional(std::sqrt(x)) : std::nullopt;\n    };\n    {\n        auto opt = chain(std::optional(2), safeSqrt);\n        std::cout << opt.value_or(-1) << std::endl; // prints sqrt(2)\n    }\n    {\n        auto opt = chain(std::optional(-2), safeSqrt);\n        std::cout << opt.value_or(-1) << std::endl; // prints -1\n    }\n    {\n        auto opt = chain(std::nullopt, safeSqrt);\n        static_assert(std::is_same_v<decltype(opt), std::nullopt_t>); // passes\n    }"
  },
  {
    "url": "https://stackoverflow.com/questions/79518752/efficient-algorithm-for-minimum-euclidean-distance-between-points-in-non-overlap",
    "body": "#include <array>\n#include <iostream>\n#include <optional>\n#include <random>\n#include <string>\n#include <tuple>\n#include <vector>\nconstexpr int REGION_SEED_TRIES = 100;\nconstexpr int NEW_MEMBER_TRIES = 200;\nconstexpr std::array<char, 10> REGION_SYMBOLS =\n    {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\nstruct coord {\n  int x;\n  int y;\n  coord(int x, int y) : x(x), y(y) {}\n  bool adjacent(const coord& o) const {\n    return std::abs(x - o.x) + std::abs(y - o.y) == 1;\n  }\n};\n// Methods written in inadvisable one-line format for ease of display on\n// StackOverflow\nstruct Map {\n  using CellType = uint8_t;\n  static constexpr int UNASSIGNED = 0;\n  static constexpr int BUFFER = 1;\n  int free_label = 2;\n  std::vector<CellType> data;\n  int m_width;\n  int m_height;\n  Map(int width, int height) {\n    data.resize(width * height, UNASSIGNED);\n    m_width = width;\n    m_height = height;\n  }\n  CellType& operator[](const coord& c) {\n    return data.at(c.y * m_width + c.x);\n  }\n  CellType operator[](const coord& c) const {\n    return data.at(c.y * m_width + c.x);\n  }\n  void clear() {\n    std::fill(data.begin(), data.end(), false);\n  }\n  int get_free_label() {\n    return free_label++;\n  }\n  int width() const {\n    return m_width;\n  }\n  int height() const {\n    return m_height;\n  }\n  bool on_edge(const coord& c) const {\n    return c.x == 0 || c.y == 0 || c.x == m_width - 1 || c.y == m_height - 1;\n  }\n  bool in_body(const coord& c) const {\n    return c.x >= 0 && c.y >= 0 && c.x < m_width && c.y < m_height;\n  }\n  bool neighbor_is_buffer(const coord& c) const {\n    for (int ny = c.y - 1; ny <= c.y + 1; ++ny) {\n      for (int nx = c.x - 1; nx <= c.x + 1; ++nx) {\n        const coord n{nx, ny};\n        if (!in_body(n)) {\n          continue;\n        }\n        if (data[n.y * m_width + n.x] == BUFFER) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n};\nusing RegionBoundary = std::vector<coord>;\nint rand_int(const int lb, const int ub, std::mt19937& prng) {\n  return std::uniform_int_distribution<>(lb, ub)(prng);\n}\nvoid create_region(\n    Map& map,\n    std::mt19937& prng,\n    const int distance_to_neighboring_regions) {\n  const auto region_label = map.get_free_label();\n  const auto region_size = rand_int(50, map.width() * map.height() / 2, prng);\n  std::vector<coord> region_members;\n  region_members.reserve(region_size);\n  // Seed the region\n  for (int i = 0; i < REGION_SEED_TRIES; i++) {\n    const int x = rand_int(1, map.width() - 2, prng);\n    const int y = rand_int(1, map.height() - 2, prng);\n    if (map[{x, y}] == Map::UNASSIGNED) {\n      region_members.emplace_back(x, y);\n      break;\n    }\n  }\n  if (region_members.empty()) {\n    throw std::runtime_error(\n        \"Unable to find a seed location in a reasonable amount of time\");\n  }\n  // Grow the region\n  for (int tries = 0;\n       tries < NEW_MEMBER_TRIES && region_members.size() < region_size;\n       tries++) {\n    // Choose a random member of the region to grow from\n    const auto& member =\n        region_members.at(rand_int(0, region_members.size() - 1, prng));\n    // Choose a random neighbour of the member\n    const coord neighbour(\n        member.x + rand_int(-1, 1, prng), member.y + rand_int(-1, 1, prng));\n    // Early exits so that the logic of the function is easier to follow\n    if (!neighbour.adjacent(member)) {\n      continue;\n    }\n    if (map.on_edge(neighbour)) {\n      continue;\n    }\n    if (map[neighbour] != Map::UNASSIGNED) {\n      continue;\n    }\n    // Neighbor is a valid candidate for expansion, so add it to the region\n    map[neighbour] = region_label;\n    region_members.push_back(neighbour);\n    tries = 0; // Reset the number of tries\n  }\n  // Mark cells adjacent to the region so regions don't grow into each other\n  // We grow outwards from the region converting UNASSIGNED cells to BUFFER\n  // cells and we repeat this several times, if necessary, to ensure an adequate\n  // buffer between regions\n  for (int buffer = 0; buffer < distance_to_neighboring_regions; buffer++) {\n    for (const auto& member : region_members) {\n      // We will include all 8 cells around the focal cell\n      for (int nx = member.x - 1; nx <= member.x + 1; ++nx) {\n        for (int ny = member.y - 1; ny <= member.y + 1; ++ny) {\n          const coord n{nx, ny};\n          if (!map.in_body(n)) {\n            continue;\n          }\n          if (map[n] == Map::UNASSIGNED) {\n            map[n] = Map::BUFFER;\n            // Add buffer cell to the region so that we can continue to grow the\n            // buffer between regions if we need to\n            region_members.push_back(n);\n          }\n        }\n      }\n    }\n  }\n}\nRegionBoundary get_region_boundary(const Map& map, const int region_label) {\n  // Iterate over all cells in the map considering only those that are\n  // of type `region_label` and are adjacent to a cell of type `Map::BUFFER`\n  RegionBoundary boundary;\n  for (int y = 0; y < map.height(); ++y) {\n    for (int x = 0; x < map.width(); ++x) {\n      const auto type = map[{x, y}];\n      if (type == region_label && map.neighbor_is_buffer({x, y})) {\n        boundary.emplace_back(x, y);\n      }\n    }\n  }\n  return boundary;\n}\nvoid display_map(const Map& map, const std::vector<coord>& highlight) {\n  for (int y = 0; y < map.height(); ++y) {\n    for (int x = 0; x < map.width(); ++x) {\n      const coord c = {x, y};\n      const auto type = map[c];\n      const char symbol = [&]() {\n        if (std::any_of(highlight.begin(), highlight.end(), [&](const auto& x) {\n              return x.x == c.x && x.y == c.y;\n            })) {\n          return '!';\n        }\n        if (type == Map::UNASSIGNED || type == Map::BUFFER) {\n          return ' ';\n        } else {\n          return REGION_SYMBOLS.at((type - 2) % REGION_SYMBOLS.size());\n        }\n      }();\n      std::cout << symbol;\n    }\n    std::cout << \"\\n\";\n  }\n}\nstd::optional<std::tuple<coord, coord, double>> closest_points_on_boundary(\n    const RegionBoundary& boundary1,\n    const RegionBoundary& boundary2) {\n  std::optional<std::tuple<coord, coord, double>> closest_points;\n  for (const auto& p1 : boundary1) {\n    for (const auto& p2 : boundary2) {\n      const auto distance = std::pow(p1.x - p2.x, 2) + std::pow(p1.y - p2.y, 2);\n      if (!closest_points || distance < std::get<2>(*closest_points)) {\n        closest_points = {p1, p2, distance};\n      }\n    }\n  }\n  return closest_points;\n}\nint main(int argc, char** argv) {\n  std::random_device rd;\n  std::mt19937 prng(rd());\n  if (argc != 3) {\n    std::cerr << \"Usage: \" << argv[0] << \" width height\\n\";\n    return 1;\n  }\n  const int width = std::stoi(argv[1]);\n  const int height = std::stoi(argv[2]);\n  Map map(width, height);\n  create_region(map, prng, 5);\n  create_region(map, prng, 5);\n  const auto boundary2 = get_region_boundary(map, 2);\n  const auto boundary3 = get_region_boundary(map, 3);\n  const auto closest = closest_points_on_boundary(boundary2, boundary3);\n  if (closest) {\n    display_map(map, {std::get<0>(*closest), std::get<1>(*closest)});\n  }\n  return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/72126606/should-the-cache-padding-size-of-x86-64-be-128-bytes",
    "body": "$ g++ -DSIZE=64 -pthread -O2 false-share.cpp && perf stat --all-user -etask-clock,context-switches,cpu-migrations,page-faults,cycles,instructions,uops_issued.any,uops_executed.thread,machine_clears.memory_ordering -r25 ./a.out\n Performance counter stats for './a.out' (25 runs):\n            560.22 msec task-clock                #    3.958 CPUs utilized            ( +-  0.12% )\n                 0      context-switches          #    0.000 /sec\n                 0      cpu-migrations            #    0.000 /sec\n               126      page-faults               #  224.752 /sec                     ( +-  0.35% )\n     2,180,391,747      cycles                    #    3.889 GHz                      ( +-  0.12% )\n     2,003,039,378      instructions              #    0.92  insn per cycle           ( +-  0.00% )\n     1,604,118,661      uops_issued.any           #    2.861 G/sec                    ( +-  0.00% )\n     2,003,739,959      uops_executed.thread      #    3.574 G/sec                    ( +-  0.00% )\n               494      machine_clears.memory_ordering #  881.172 /sec                     ( +-  9.00% )\n          0.141534 +- 0.000342 seconds time elapsed  ( +-  0.24% )"
  },
  {
    "url": "https://stackoverflow.com/questions/72126606/should-the-cache-padding-size-of-x86-64-be-128-bytes",
    "body": "$ g++ -DSIZE=128 -pthread -O2 false-share.cpp && perf stat --all-user -etask-clock,context-switches,cpu-migrations,page-faults,cycles,instructions,uops_issued.any,uops_executed.thread,machine_clears.memory_ordering -r25 ./a.out\n Performance counter stats for './a.out' (25 runs):\n            560.01 msec task-clock                #    3.957 CPUs utilized            ( +-  0.13% )\n                 0      context-switches          #    0.000 /sec\n                 0      cpu-migrations            #    0.000 /sec\n               124      page-faults               #  221.203 /sec                     ( +-  0.16% )\n     2,180,048,243      cycles                    #    3.889 GHz                      ( +-  0.13% )\n     2,003,038,553      instructions              #    0.92  insn per cycle           ( +-  0.00% )\n     1,604,084,990      uops_issued.any           #    2.862 G/sec                    ( +-  0.00% )\n     2,003,707,895      uops_executed.thread      #    3.574 G/sec                    ( +-  0.00% )\n                22      machine_clears.memory_ordering #   39.246 /sec                     ( +-  9.68% )\n          0.141506 +- 0.000342 seconds time elapsed  ( +-  0.24% )"
  },
  {
    "url": "https://stackoverflow.com/questions/72126606/should-the-cache-padding-size-of-x86-64-be-128-bytes",
    "body": "$ g++ -DSIZE=4 -pthread -O2 false-share.cpp && perf stat --all-user -etask-clock,context-switches,cpu-migrations,page-faults,cycles,instructions,uops_issued.any,uops_executed.thread,machine_clears.memory_ordering -r25 ./a.out\n Performance counter stats for './a.out' (25 runs):\n            809.98 msec task-clock                #    3.835 CPUs utilized            ( +-  0.42% )\n                 0      context-switches          #    0.000 /sec\n                 0      cpu-migrations            #    0.000 /sec\n               122      page-faults               #  152.953 /sec                     ( +-  0.22% )\n     3,152,973,230      cycles                    #    3.953 GHz                      ( +-  0.42% )\n     2,003,038,681      instructions              #    0.65  insn per cycle           ( +-  0.00% )\n     2,868,628,070      uops_issued.any           #    3.596 G/sec                    ( +-  0.41% )\n     2,934,059,729      uops_executed.thread      #    3.678 G/sec                    ( +-  0.30% )\n        10,810,169      machine_clears.memory_ordering #   13.553 M/sec                    ( +-  0.90% )\n           0.21123 +- 0.00124 seconds time elapsed  ( +-  0.59% )"
  },
  {
    "url": "https://stackoverflow.com/questions/69447778/fastest-way-to-draw-filled-quad-triangle-with-the-sdl2-renderer",
    "body": "// g++ main.cpp `pkg-config --cflags --libs sdl2`\n#include <SDL.h>\n#include <vector>\nint main( int argc, char** argv )\n{\n    SDL_Init( SDL_INIT_EVERYTHING );\n    SDL_Window* window = SDL_CreateWindow(\"SDL\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 800, 600, SDL_WINDOW_SHOWN );\n    SDL_Renderer* renderer = SDL_CreateRenderer( window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC );\n    const std::vector< SDL_Vertex > verts =\n    {\n        { SDL_FPoint{ 400, 150 }, SDL_Color{ 255, 0, 0, 255 }, SDL_FPoint{ 0 }, },\n        { SDL_FPoint{ 200, 450 }, SDL_Color{ 0, 0, 255, 255 }, SDL_FPoint{ 0 }, },\n        { SDL_FPoint{ 600, 450 }, SDL_Color{ 0, 255, 0, 255 }, SDL_FPoint{ 0 }, },\n    };\n    bool running = true;\n    while( running )\n    {\n        SDL_Event ev;\n        while( SDL_PollEvent( &ev ) )\n        {\n            if( ( SDL_QUIT == ev.type ) ||\n                ( SDL_KEYDOWN == ev.type && SDL_SCANCODE_ESCAPE == ev.key.keysym.scancode ) )\n            {\n                running = false;\n                break;\n            }\n        }\n        SDL_SetRenderDrawColor( renderer, 0, 0, 0, SDL_ALPHA_OPAQUE );\n        SDL_RenderClear( renderer );\n        SDL_RenderGeometry( renderer, nullptr, verts.data(), verts.size(), nullptr, 0 );\n        SDL_RenderPresent( renderer );\n    }\n    SDL_DestroyRenderer( renderer );\n    SDL_DestroyWindow( window );\n    SDL_Quit();\n    return 0;\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/79558046/c-sorting-of-parallel-vectors-with-zip-range-how-efficient-is-it-really-and-c",
    "body": "// Simple quicksort for demonstration purposes - in production you'd use a better\n// implementation, possibly copied from std or from a crate that specializes\n// in sorting.\nfn quicksort(data: &mut (impl Sortable + ?Sized)) {\n    quicksort_rec(data, 0, data.len());\n    fn quicksort_rec(data: &mut (impl Sortable + ?Sized), from: usize, to: usize) {\n        if to - from <= 1 {\n            return;\n        }\n        let pivot = partition(data, from, to);\n        quicksort_rec(data, from, pivot);\n        quicksort_rec(data, pivot + 1, to);\n    }\n    fn partition(data: &mut (impl Sortable + ?Sized), from: usize, to: usize) -> usize {\n        let pivot = to - 1;\n        let mut i = from;\n        for j in from..pivot {\n            if data.cmp(j, pivot).is_le() {\n                data.swap(i, j);\n                i += 1;\n            }\n        }\n        data.swap(i, pivot);\n        i\n    }\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/79558046/c-sorting-of-parallel-vectors-with-zip-range-how-efficient-is-it-really-and-c",
    "body": "// this struct doesn't allocate, it just holds two references\nstruct Zip<'a, K, V> {\n    keys: &'a mut [K],\n    values: &'a mut [V],\n}\nimpl<'a, K, V> Zip<'a, K, V> {\n    fn new(keys: &'a mut [K], values: &'a mut [V]) -> Self {\n        Zip { keys, values }\n    }\n}\nimpl<K: Ord, V> Sortable for Zip<'_, K, V> {\n    fn len(&self) -> usize {\n        self.keys.len()\n    }\n    fn cmp(&self, a: usize, b: usize) -> Ordering {\n        self.keys[a].cmp(&self.keys[b])\n    }\n    fn swap(&mut self, a: usize, b: usize) {\n        self.keys.swap(a, b);\n        self.values.swap(a, b);\n    }\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/66877095/using-a-c-dll-in-flutter-windows-desktop-app",
    "body": "// Copyright 2018 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport 'dart:io' show Platform;\nimport 'dart:math' as math;\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:menubar/menubar.dart';\nimport 'package:window_size/window_size.dart' as window_size;\nimport 'keyboard_test_page.dart';\nvoid main() {\n  // Try to resize and reposition the window to be half the width and height\n  // of its screen, centered horizontally and shifted up from center.\n  WidgetsFlutterBinding.ensureInitialized();\n  window_size.getWindowInfo().then((window) {\n    final screen = window.screen;\n    if (screen != null) {\n      final screenFrame = screen.visibleFrame;\n      final width = math.max((screenFrame.width / 2).roundToDouble(), 800.0);\n      final height = math.max((screenFrame.height / 2).roundToDouble(), 600.0);\n      final left = ((screenFrame.width - width) / 2).roundToDouble();\n      final top = ((screenFrame.height - height) / 3).roundToDouble();\n      final frame = Rect.fromLTWH(left, top, width, height);\n      window_size.setWindowFrame(frame);\n      window_size.setWindowMinSize(Size(0.8 * width, 0.8 * height));\n      window_size.setWindowMaxSize(Size(1.5 * width, 1.5 * height));\n      window_size\n          .setWindowTitle('Flutter Testbed on ${Platform.operatingSystem}');\n    }\n  });\n  runApp(new MyApp());\n}\n/// Top level widget for the application.\nclass MyApp extends StatefulWidget {\n  /// Constructs a new app with the given [key].\n  const MyApp({Key? key}) : super(key: key);\n  @override\n  _AppState createState() => new _AppState();\n}\nclass _AppState extends State<MyApp> {\n  Color _primaryColor = Colors.blue;\n  int _counter = 0;\n  static _AppState? of(BuildContext context) =>\n      context.findAncestorStateOfType<_AppState>();\n  /// Sets the primary color of the app.\n  void setPrimaryColor(Color color) {\n    setState(() {\n      _primaryColor = color;\n    });\n  }\n  void incrementCounter() {\n    _setCounter(_counter + 1);\n  }\n  void _decrementCounter() {\n    _setCounter(_counter - 1);\n  }\n  void _setCounter(int value) {\n    setState(() {\n      _counter = value;\n    });\n  }\n  /// Rebuilds the native menu bar based on the current state.\n  void updateMenubar() {\n    setApplicationMenu([\n      Submenu(label: 'Color', children: [\n        MenuItem(\n            label: 'Reset',\n            enabled: _primaryColor != Colors.blue,\n            shortcut: LogicalKeySet(\n                LogicalKeyboardKey.meta, LogicalKeyboardKey.backspace),\n            onClicked: () {\n              setPrimaryColor(Colors.blue);\n            }),\n        MenuDivider(),\n        Submenu(label: 'Presets', children: [\n          MenuItem(\n              label: 'Red',\n              enabled: _primaryColor != Colors.red,\n              shortcut: LogicalKeySet(LogicalKeyboardKey.meta,\n                  LogicalKeyboardKey.shift, LogicalKeyboardKey.keyR),\n              onClicked: () {\n                setPrimaryColor(Colors.red);\n              }),\n          MenuItem(\n              label: 'Green',\n              enabled: _primaryColor != Colors.green,\n              shortcut: LogicalKeySet(LogicalKeyboardKey.meta,\n                  LogicalKeyboardKey.alt, LogicalKeyboardKey.keyG),\n              onClicked: () {\n                setPrimaryColor(Colors.green);\n              }),\n          MenuItem(\n              label: 'Purple',\n              enabled: _primaryColor != Colors.deepPurple,\n              shortcut: LogicalKeySet(LogicalKeyboardKey.meta,\n                  LogicalKeyboardKey.control, LogicalKeyboardKey.keyP),\n              onClicked: () {\n                setPrimaryColor(Colors.deepPurple);\n              }),\n        ])\n      ]),\n      Submenu(label: 'Counter', children: [\n        MenuItem(\n            label: 'Reset',\n            enabled: _counter != 0,\n            shortcut: LogicalKeySet(\n                LogicalKeyboardKey.meta, LogicalKeyboardKey.digit0),\n            onClicked: () {\n              _setCounter(0);\n            }),\n        MenuDivider(),\n        MenuItem(\n            label: 'Increment',\n            shortcut: LogicalKeySet(LogicalKeyboardKey.f2),\n            onClicked: incrementCounter),\n        MenuItem(\n            label: 'Decrement',\n            enabled: _counter > 0,\n            shortcut: LogicalKeySet(LogicalKeyboardKey.f1),\n            onClicked: _decrementCounter),\n      ]),\n    ]);\n  }\n  @override\n  Widget build(BuildContext context) {\n    // Any time the state changes, the menu needs to be rebuilt.\n    updateMenubar();\n    return MaterialApp(\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        primaryColor: _primaryColor,\n        accentColor: _primaryColor,\n      ),\n      darkTheme: ThemeData.dark(),\n      home: _MyHomePage(title: 'Flutter Demo Home Page', counter: _counter),\n    );\n  }\n}\nclass _MyHomePage extends StatelessWidget {\n  const _MyHomePage({required this.title, this.counter = 0});\n  final String title;\n  final int counter;\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(title),\n      ),\n      body: LayoutBuilder(\n        builder: (context, viewportConstraints) {\n          return SingleChildScrollView(\n            child: ConstrainedBox(\n              constraints:\n                  BoxConstraints(minHeight: viewportConstraints.maxHeight),\n              child: Center(\n                child: Column(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: <Widget>[\n                    const Text(\n                      'You have pushed the button this many times:',\n                    ),\n                    new Text(\n                      '$counter',\n                      style: Theme.of(context).textTheme.headline4,\n                    ),\n                    TextInputTestWidget(),\n                    new ElevatedButton(\n                      child: new Text('Test raw keyboard events'),\n                      onPressed: () {\n                        Navigator.of(context).push(new MaterialPageRoute(\n                            builder: (context) => KeyboardTestPage()));\n                      },\n                    ),\n                    Padding(\n                      padding: const EdgeInsets.all(8.0),\n                      child: Container(\n                        width: 380.0,\n                        height: 100.0,\n                        decoration: BoxDecoration(\n                            border: Border.all(color: Colors.grey, width: 1.0)),\n                        child: Scrollbar(\n                          child: ListView.builder(\n                            padding: EdgeInsets.all(8.0),\n                            itemExtent: 20.0,\n                            itemCount: 50,\n                            itemBuilder: (context, index) {\n                              return Text('entry $index');\n                            },\n                          ),\n                        ),\n                      ),\n                    ),\n                  ],\n                ),\n              ),\n            ),\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _AppState.of(context)!.incrementCounter,\n        tooltip: 'Increment',\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n/// A widget containing controls to test text input.\nclass TextInputTestWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: const <Widget>[\n        SampleTextField(),\n        SampleTextField(),\n      ],\n    );\n  }\n}\n/// A text field with styling suitable for including in a TextInputTestWidget.\nclass SampleTextField extends StatelessWidget {\n  /// Creates a new sample text field.\n  const SampleTextField();\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      width: 200.0,\n      padding: const EdgeInsets.all(10.0),\n      child: TextField(\n        decoration: InputDecoration(border: OutlineInputBorder()),\n      ),\n    );\n  }\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/66877095/using-a-c-dll-in-flutter-windows-desktop-app",
    "body": "final Pointer<Uint8> Function(int size) nativeCreateArray =\n  nativePointerTestLib\n    .lookup<NativeFunction<Pointer<Uint8> Function(Int32)>>(\"createarray\")\n    .asFunction();\nfinal void Function(Pointer<Uint8> arr,int size) nativePopulateArray =\n  nativePointerTestLib\n    .lookup<NativeFunction<Void Function(Pointer<Uint8>, Int32)>>(\"populatearray\")\n    .asFunction();\nfinal void Function(Pointer<Uint8> arr) nativeDestroyArray =\n  nativePointerTestLib\n    .lookup<NativeFunction<Void Function(Pointer<Uint8>)>>(\"destroyarray\")\n    .asFunction();"
  },
  {
    "url": "https://stackoverflow.com/questions/66877095/using-a-c-dll-in-flutter-windows-desktop-app",
    "body": "// Copyright 2018 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport 'dart:io' show Platform;\nimport 'dart:math' as math;\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:menubar/menubar.dart';\nimport 'package:window_size/window_size.dart' as window_size;\nimport 'keyboard_test_page.dart';\nimport 'dart:ffi'; // For FFI\nfinal DynamicLibrary nativePointerTestLib = DynamicLibrary.open(\"dynamicloadtest.dll\");\nfinal Pointer<Uint8> Function(int size) nativeCreateArray =\n  nativePointerTestLib\n    .lookup<NativeFunction<Pointer<Uint8> Function(Int32)>>(\"createarray\")\n    .asFunction();\nfinal void Function(Pointer<Uint8> arr,int size) nativePopulateArray =\n  nativePointerTestLib\n    .lookup<NativeFunction<Void Function(Pointer<Uint8>, Int32)>>(\"populatearray\")\n    .asFunction();\nfinal void Function(Pointer<Uint8> arr) nativeDestroyArray =\n  nativePointerTestLib\n    .lookup<NativeFunction<Void Function(Pointer<Uint8>)>>(\"destroyarray\")\n    .asFunction();\nvoid main() {\n  // Try to resize and reposition the window to be half the width and height\n  // of its screen, centered horizontally and shifted up from center.\n  WidgetsFlutterBinding.ensureInitialized();\n  window_size.getWindowInfo().then((window) {\n    final screen = window.screen;\n    if (screen != null) {\n      final screenFrame = screen.visibleFrame;\n      final width = math.max((screenFrame.width / 2).roundToDouble(), 800.0);\n      final height = math.max((screenFrame.height / 2).roundToDouble(), 600.0);\n      final left = ((screenFrame.width - width) / 2).roundToDouble();\n      final top = ((screenFrame.height - height) / 3).roundToDouble();\n      final frame = Rect.fromLTWH(left, top, width, height);\n      window_size.setWindowFrame(frame);\n      window_size.setWindowMinSize(Size(0.8 * width, 0.8 * height));\n      window_size.setWindowMaxSize(Size(1.5 * width, 1.5 * height));\n      window_size\n          .setWindowTitle('Flutter Testbed on ${Platform.operatingSystem}');\n    }\n  });\n  runApp(new MyApp());\n}\n/// Top level widget for the application.\nclass MyApp extends StatefulWidget {\n  /// Constructs a new app with the given [key].\n  const MyApp({Key? key}) : super(key: key);\n  @override\n  _AppState createState() => new _AppState();\n}\nclass _AppState extends State<MyApp> {\n  Color _primaryColor = Colors.blue;\n  int _counter = 0;\n  static _AppState? of(BuildContext context) =>\n      context.findAncestorStateOfType<_AppState>();\n  /// Sets the primary color of the app.\n  void setPrimaryColor(Color color) {\n    setState(() {\n      _primaryColor = color;\n    });\n  }\n  void incrementCounter() {\n    _setCounter(_counter + 1);\n  }\n  void _decrementCounter() {\n    _setCounter(_counter - 1);\n  }\n  void _setCounter(int value) {\n    setState(() {\n      Pointer<Uint8> parray = nativeCreateArray(5);\n      nativePopulateArray(parray,5);\n      //Now lets print\n      print(parray);\n      String str= \"\";\n      for(int i = 0 ; i < 5; ++i){\n        int val = parray.elementAt(i).value;\n        str+=val.toString() +\" \";\n      }\n      print(str);\n      nativeDestroyArray(parray);\n      _counter = value;\n    });\n  }\n  /// Rebuilds the native menu bar based on the current state.\n  void updateMenubar() {\n    setApplicationMenu([\n      Submenu(label: 'Color', children: [\n        MenuItem(\n            label: 'Reset',\n            enabled: _primaryColor != Colors.blue,\n            shortcut: LogicalKeySet(\n                LogicalKeyboardKey.meta, LogicalKeyboardKey.backspace),\n            onClicked: () {\n              setPrimaryColor(Colors.blue);\n            }),\n        MenuDivider(),\n        Submenu(label: 'Presets', children: [\n          MenuItem(\n              label: 'Red',\n              enabled: _primaryColor != Colors.red,\n              shortcut: LogicalKeySet(LogicalKeyboardKey.meta,\n                  LogicalKeyboardKey.shift, LogicalKeyboardKey.keyR),\n              onClicked: () {\n                setPrimaryColor(Colors.red);\n              }),\n          MenuItem(\n              label: 'Green',\n              enabled: _primaryColor != Colors.green,\n              shortcut: LogicalKeySet(LogicalKeyboardKey.meta,\n                  LogicalKeyboardKey.alt, LogicalKeyboardKey.keyG),\n              onClicked: () {\n                setPrimaryColor(Colors.green);\n              }),\n          MenuItem(\n              label: 'Purple',\n              enabled: _primaryColor != Colors.deepPurple,\n              shortcut: LogicalKeySet(LogicalKeyboardKey.meta,\n                  LogicalKeyboardKey.control, LogicalKeyboardKey.keyP),\n              onClicked: () {\n                setPrimaryColor(Colors.deepPurple);\n              }),\n        ])\n      ]),\n      Submenu(label: 'Counter', children: [\n        MenuItem(\n            label: 'Reset',\n            enabled: _counter != 0,\n            shortcut: LogicalKeySet(\n                LogicalKeyboardKey.meta, LogicalKeyboardKey.digit0),\n            onClicked: () {\n              _setCounter(0);\n            }),\n        MenuDivider(),\n        MenuItem(\n            label: 'Increment',\n            shortcut: LogicalKeySet(LogicalKeyboardKey.f2),\n            onClicked: incrementCounter),\n        MenuItem(\n            label: 'Decrement',\n            enabled: _counter > 0,\n            shortcut: LogicalKeySet(LogicalKeyboardKey.f1),\n            onClicked: _decrementCounter),\n      ]),\n    ]);\n  }\n  @override\n  Widget build(BuildContext context) {\n    // Any time the state changes, the menu needs to be rebuilt.\n    updateMenubar();\n    return MaterialApp(\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        primaryColor: _primaryColor,\n        accentColor: _primaryColor,\n      ),\n      darkTheme: ThemeData.dark(),\n      home: _MyHomePage(title: 'Flutter Demo Home Page', counter: _counter),\n    );\n  }\n}\nclass _MyHomePage extends StatelessWidget {\n  const _MyHomePage({required this.title, this.counter = 0});\n  final String title;\n  final int counter;\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(title),\n      ),\n      body: LayoutBuilder(\n        builder: (context, viewportConstraints) {\n          return SingleChildScrollView(\n            child: ConstrainedBox(\n              constraints:\n                  BoxConstraints(minHeight: viewportConstraints.maxHeight),\n              child: Center(\n                child: Column(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: <Widget>[\n                    const Text(\n                      'You have pushed the button this many times:',\n                    ),\n                    new Text(\n                      '$counter',\n                      style: Theme.of(context).textTheme.headline4,\n                    ),\n                    TextInputTestWidget(),\n                    new ElevatedButton(\n                      child: new Text('Test raw keyboard events'),\n                      onPressed: () {\n                        Navigator.of(context).push(new MaterialPageRoute(\n                            builder: (context) => KeyboardTestPage()));\n                      },\n                    ),\n                    Padding(\n                      padding: const EdgeInsets.all(8.0),\n                      child: Container(\n                        width: 380.0,\n                        height: 100.0,\n                        decoration: BoxDecoration(\n                            border: Border.all(color: Colors.grey, width: 1.0)),\n                        child: Scrollbar(\n                          child: ListView.builder(\n                            padding: EdgeInsets.all(8.0),\n                            itemExtent: 20.0,\n                            itemCount: 50,\n                            itemBuilder: (context, index) {\n                              return Text('entry $index');\n                            },\n                          ),\n                        ),\n                      ),\n                    ),\n                  ],\n                ),\n              ),\n            ),\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _AppState.of(context)!.incrementCounter,\n        tooltip: 'Increment',\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n/// A widget containing controls to test text input.\nclass TextInputTestWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: const <Widget>[\n        SampleTextField(),\n        SampleTextField(),\n      ],\n    );\n  }\n}\n/// A text field with styling suitable for including in a TextInputTestWidget.\nclass SampleTextField extends StatelessWidget {\n  /// Creates a new sample text field.\n  const SampleTextField();\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      width: 200.0,\n      padding: const EdgeInsets.all(10.0),\n      child: TextField(\n        decoration: InputDecoration(border: OutlineInputBorder()),\n      ),\n    );\n  }\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/8552364/opencv-detect-contours-intersection",
    "body": "import numpy as np # just for matrix manipulation, C/C++ use cv::Mat\n# find contours.\ncontours,h = findContours( img, mode=RETR_LIST, method=CHAIN_APPROX_SIMPLE )\n# Suppose this has the contours of just the car and the obstacle.\n# create an image filled with zeros, single-channel, same size as img.\nblank = np.zeros( img.shape[0:2] )\n# copy each of the contours (assuming there's just two) to its own image.\n# Just fill with a '1'.\nimg1 = drawContours( blank.copy(), contours, 0, 1 )\nimg2 = drawContours( blank.copy(), contours, 1, 1 )\n# now AND the two together\nintersection = np.logical_and( img1, img2 )\n# OR we could just add img1 to img2 and pick all points that sum to 2 (1+1=2):\nintersection2 = (img1+img2)==2"
  },
  {
    "url": "https://stackoverflow.com/questions/72908947/writing-a-small-file-blocks-for-20-ms",
    "body": "           time    cpu  0123456  task name                       wait time  sch delay   run time\n                                 [tid/pid]                          (msec)     (msec)     (msec)\n--------------- ------  -------  ------------------------------  ---------  ---------  ---------\n   95730.123845 [0005]       i   <idle>                              0.000      0.000      0.000\n   95730.123845 [0002]    s      perf_5.4[55033]                     0.000      0.000      0.000\n   95730.124721 [0000]  i        <idle>                              0.000      0.000      0.000\n   95730.124725 [0000]  s        gmain[805/804]                      0.000      0.025      0.004\n   95730.124761 [0000]  i        <idle>                              0.004      0.000      0.036\n   95730.124765 [0000]  s        gmain[805/804]                      0.036      0.025      0.003\n   95730.124789 [0003]     i     <idle>                              0.000      0.000      0.000\n   95730.124795 [0003]     s     kworker/u12:2-e[45157]              0.000      0.023      0.006\n   95730.124822 [0002]    i      <idle>                              0.000      0.000      0.976\n   95730.124833 [0000]  i        <idle>                              0.003      0.000      0.068\n   95730.124834 [0005]       s   a.out[55040]                        0.000      0.026      0.988\n   95730.124836 [0000]  s    |   gmain[805/804]                      0.068      0.038      0.003\n   95730.124838 [0002]    s  |   sudo[54745]                         0.000      0.028      0.015\n   95730.124849 [0003]     i |   <idle>                              0.006      0.000      0.053\n   95730.124854 [0003]     s |   kworker/u12:2-e[45157]              0.053      0.027      0.004\n   95730.124886 [0002]    i  |   <idle>                              0.015      0.000      0.048\n   95730.124901 [0002]    s  |   sudo[54745]                         0.048      0.033      0.015\n   95730.124916 [0003]     i |   <idle>                              0.004      0.000      0.062\n   95730.124922 [0003]     s |   kworker/u12:2-e[45157]              0.062      0.024      0.005\n   95730.124945 [0004]      i|   <idle>                              0.000      0.000      0.000\n   95730.124987 [0004]      s|   gnome-terminal-[8464]               0.000      0.024      0.042\n   95730.127461 [0003]     i |   <idle>                              0.005      0.000      2.539\n   95730.127474 [0005]       i   <idle>                              0.988      0.000      2.639\n   95730.127475 [0003]     s     kworker/u12:2-e[45157]              2.539      0.023      0.013\n   95730.127516 [0000]  i  |     <idle>                              0.003      0.000      2.679\n   95730.127519 [0000]  s  |     gmain[805/804]                      2.679      0.027      0.003\n   95730.127530 [0005]     | s   a.out[55040]                        2.639      0.001      0.056\n   95730.127537 [0003]     i |   <idle>                              0.013      0.000      0.062\n   95730.127549 [0005]       i   <idle>                              0.056      0.000      0.018\n   95730.127550 [0003]     s     kworker/u12:2-e[45157]              0.062      0.023      0.013\n   95730.127566 [0004]      i    <idle>                              0.042      0.000      2.578\n   95730.127568 [0004]      s    kworker/u12:4-e[54041]              0.000      0.026      0.002\n   95730.127585 [0002]    i      <idle>                              0.015      0.000      2.683\n   95730.127585 [0000]  i        <idle>                              0.003      0.000      0.065\n   95730.127588 [0000]  s        gmain[805/804]                      0.065      0.026      0.003\n   95730.127591 [0005]       s   a.out[55040]                        0.018      0.001      0.042\n   95730.127595 [0002]    s  |   sudo[54745]                         2.683      0.043      0.009\n   95730.127605 [0004]      i|   <idle>                              0.002      0.000      0.037\n   95730.127617 [0005]       i   <idle>                              0.042      0.000      0.026\n   95730.127618 [0004]      s    kworker/u12:4-e[54041]              0.037      0.028      0.013\n   95730.127635 [0003]     i     <idle>                              0.013      0.000      0.085\n   95730.127637 [0003]     s     kworker/u12:2-e[45157]              0.085      0.027      0.002\n   95730.127644 [0003]     i     <idle>                              0.002      0.000      0.007\n   95730.127647 [0003]     s     kworker/u12:2-e[45157]              0.007      0.000      0.002\n   95730.127650 [0003]     i     <idle>                              0.002      0.000      0.003\n   95730.127652 [0003]     s     kworker/u12:2-e[45157]              0.003      0.000      0.001\n   95730.127653 [0003]     i     <idle>                              0.001      0.000      0.001\n   95730.127659 [0003]     s     kworker/u12:2-e[45157]              0.001      0.000      0.006\n   95730.127662 [0002]    i      <idle>                              0.009      0.000      0.067\n   95730.127662 [0000]  i        <idle>                              0.003      0.000      0.073\n   95730.127666 [0000]  s        gmain[805/804]                      0.073      0.036      0.003\n   95730.127669 [0003]     i     <idle>                              0.006      0.000      0.010\n   95730.127672 [0004]      i    <idle>                              0.013      0.000      0.053\n   95730.127673 [0003]     s     kworker/u12:2-e[45157]              0.010      0.000      0.004\n   95730.127674 [0004]      s    kworker/u12:4-e[54041]              0.053      0.026      0.002\n   95730.127676 [0004]      i    <idle>                              0.002      0.000      0.001\n   95730.127678 [0004]      s    kworker/u12:4-e[54041]              0.001      0.001      0.002\n   95730.127679 [0002]    s      sudo[54745]                         0.067      0.052      0.016\n   95730.127692 [0001]   i       <idle>                              0.000      0.000      0.000\n   95730.127717 [0001]   s       gnome-terminal-[8464]               2.704      0.019      0.024\n   95730.127725 [0005]       s   a.out[55040]                        0.026      0.001      0.107\n   95730.127755 [0002]    i  |   <idle>                              0.016      0.000      0.075"
  },
  {
    "url": "https://stackoverflow.com/questions/72908947/writing-a-small-file-blocks-for-20-ms",
    "body": "unlink:             0.000072 s\nopenat:             0.000047 s\nnewfstatat:         0.000007 s\nwrite:              0.000044 s\nclose:              0.000006 s\n[...] (write x 7)\nopenat:             0.000019 s\nnewfstatat:         0.000005 s\nwrite:              0.000011 s\nclose:              0.000022 s\n[...] (write x 7)\nopenat:             0.002334 s  <----- latency spike\nnewfstatat:         0.000057 s\nwrite:              0.000080 s\nclose:              0.000052 s\n[...] (write x 7)\nopenat:             0.000021 s\nnewfstatat:         0.000005 s\nwrite:              0.000029 s\nclose:              0.000014 s\n[...]"
  },
  {
    "url": "https://stackoverflow.com/questions/72908947/writing-a-small-file-blocks-for-20-ms",
    "body": "__x64_sys_unlink();               92.569 us\n__x64_sys_openat();               48.103 us\n__x64_sys_newfstatat();            2.609 us\n__x64_sys_write();                33.606 us\nexit_to_user_mode_prepare();      12.517 us\n__x64_sys_write();                 8.277 us\n__x64_sys_write();                 2.482 us\n__x64_sys_write();                 2.257 us\n__x64_sys_write();                 2.240 us\n__x64_sys_write();                 5.987 us\n__x64_sys_write();                 5.090 us\n__x64_sys_openat();               77.006 us    <------ Fast\n__x64_sys_newfstatat();            2.433 us\n__x64_sys_write();                43.509 us\nexit_to_user_mode_prepare();      83.260 us\n__x64_sys_write();                 5.688 us\n__x64_sys_write();                 6.339 us\n__x64_sys_write();                 4.521 us\n__x64_sys_write();                 3.006 us\n__x64_sys_write();                 4.309 us\n__x64_sys_write();                 3.472 us\n__x64_sys_write();                 2.669 us\n__x64_sys_openat() {\n    [CONTEXT SWITCH: a.out-73884 => <idle>-0]\n    [MISSING PART: KERNEL THREAD]\n    [CONTEXT SWITCH: <idle>-0 => a.out-73884]\n}                               2441.794 us    <----- Latency spike\n__x64_sys_newfstatat();            3.007 us\n__x64_sys_write();                74.643 us\nexit_to_user_mode_prepare();      64.822 us\n__x64_sys_write();                24.032 us\n__x64_sys_write();                 3.002 us\n__x64_sys_write();                 2.408 us\n__x64_sys_write();                 4.181 us\n__x64_sys_write();                 3.662 us\n__x64_sys_write();                 2.381 us\n__x64_sys_write();                23.284 us\n__x64_sys_openat();               79.258 us\n__x64_sys_newfstatat();           27.363 us\n__x64_sys_write();                45.040 us\n[...]"
  },
  {
    "url": "https://stackoverflow.com/questions/78471094/nrvo-vs-early-return-for-types-not-benefitting-from-move-semantics-gcc-14-wnrv",
    "body": "movaps XMMWORD PTR [rsp+0x10],xmm0        # xmm0 is all zeros\nmov    DWORD PTR [rsp],0x20               # result1.buttonCount = 32\nmovups XMMWORD PTR [rsp+0x4],xmm5         # result1.axes[0:4] = {5, 5, 5, 5}\nmovdqa xmm6,XMMWORD PTR [rsp]             # xmm6 = {32, 5, 5, 5}\nmovdqa xmm7,XMMWORD PTR [rsp+0x10]        # xmm7 = {5, 0, 0, 0}\nmov    DWORD PTR [rsp+0x40],0x0\nmov    DWORD PTR [rsp+0x90],0x0\nmovaps XMMWORD PTR [rsp+0x20],xmm0\nmovaps XMMWORD PTR [rsp+0x30],xmm0\nmovaps XMMWORD PTR [rsp+0x50],xmm6        # result2.buttonCount, result2.axes[0:3] = {32, 5, 5, 5}\nmovaps XMMWORD PTR [rsp+0x60],xmm7        # result2.axes[4:8] = {5, 0, 0, 0}\nmovaps XMMWORD PTR [rsp+0x70],xmm0\nmovaps XMMWORD PTR [rsp+0x80],xmm0"
  },
  {
    "url": "https://stackoverflow.com/questions/29989512/where-can-i-find-the-list-of-boost-component-that-i-can-use-in-cmake",
    "body": "[...]\n-- BoostConfig: discovered components: atomic;chrono;container;context;coroutine;date_time;exception;fiber;filesystem;graph;graph_parallel;headers;iostreams;locale;log;log_setup;math_c99;math_c99f;math_c99l;math_tr1;math_tr1f;math_tr1l;mpi;mpi_python;nowide;numpy;prg_exec_monitor;program_options;python;random;regex;serialization;stacktrace_addr2line;stacktrace_backtrace;stacktrace_basic;stacktrace_noop;system;test_exec_monitor;thread;timer;type_erasure;unit_test_framework;wave;wserialization\n[...]\n-- BoostConfig: Boost_ALL_TARGETS: Boost::headers;Boost::atomic;Boost::chrono;Boost::container;Boost::context;Boost::coroutine;Boost::date_time;Boost::exception;Boost::fiber;Boost::filesystem;Boost::graph;Boost::graph_parallel;Boost::iostreams;Boost::locale;Boost::log;Boost::log_setup;Boost::math_c99;Boost::math_c99f;Boost::math_c99l;Boost::math_tr1;Boost::math_tr1f;Boost::math_tr1l;Boost::mpi;Boost::mpi_python;Boost::nowide;Boost::numpy;Boost::prg_exec_monitor;Boost::program_options;Boost::python;Boost::random;Boost::regex;Boost::serialization;Boost::stacktrace_addr2line;Boost::stacktrace_backtrace;Boost::stacktrace_basic;Boost::stacktrace_noop;Boost::system;Boost::test_exec_monitor;Boost::thread;Boost::timer;Boost::type_erasure;Boost::unit_test_framework;Boost::wave;Boost::wserialization\n[...]"
  },
  {
    "url": "https://stackoverflow.com/questions/29989512/where-can-i-find-the-list-of-boost-component-that-i-can-use-in-cmake",
    "body": "-- BoostConfig: Boost_ALL_TARGETS:\nBoost::headers\nBoost::atomic\nBoost::chrono\nBoost::container\nBoost::context\nBoost::coroutine\nBoost::date_time\nBoost::exception\nBoost::fiber\nBoost::filesystem\nBoost::graph\nBoost::graph_parallel\nBoost::iostreams\nBoost::locale\nBoost::log\nBoost::log_setup\nBoost::math_c99\nBoost::math_c99f\nBoost::math_c99l\nBoost::math_tr1\nBoost::math_tr1f\nBoost::math_tr1l\nBoost::mpi\nBoost::mpi_python\nBoost::nowide\nBoost::numpy\nBoost::prg_exec_monitor\nBoost::program_options\nBoost::python\nBoost::random\nBoost::regex\nBoost::serialization\nBoost::stacktrace_addr2line\nBoost::stacktrace_backtrace\nBoost::stacktrace_basic\nBoost::stacktrace_noop\nBoost::system\nBoost::test_exec_monitor\nBoost::thread\nBoost::timer\nBoost::type_erasure\nBoost::unit_test_framework\nBoost::wave\nBoost::wserialization"
  },
  {
    "url": "https://stackoverflow.com/questions/69660148/c20-how-to-wait-on-an-atomic-object-with-timeout",
    "body": "    // NOTE: volatile overloads are not supported\n    template <class T> struct timed_atomic : atomic<T> {\n      using atomic<T>::atomic;\n      bool try_wait(T old, memory_order order = seq_cst) const noexcept {\n        T value = this->load(order);\n        // TODO: Ignore padding bits in comparison\n        return memcmp(addressof(value), addressof(old), sizeof(T));\n      }\n      void wait(T old, memory_order order = seq_cst) const {\n        unique_lock lock(mtx);\n        cond.wait(lock, [=, this]() { return try_wait(old, relaxed); });\n      }\n      template <class Rep, class Period>\n      bool wait_for(T old, const duration<Rep, Period> &rel_time,\n                    memory_order order = seq_cst) const {\n        unique_lock lock(mtx);\n        return cond.wait_for(lock, rel_time,\n                             [=, this]() { return try_wait(old, relaxed); });\n      }\n      template <class Clock, class Duration>\n      bool wait_until(T old, const time_point<Clock, Duration> &abs_time,\n                      memory_order order = seq_cst) const {\n        unique_lock lock(mtx);\n        return cond.wait_until(lock, abs_time,\n                               [=, this]() { return try_wait(old, relaxed); });\n      }\n      void notify_one() const {\n        { lock_guard _(mtx); }\n        cond.notify_one();\n      }\n      void notify_all() const {\n        { lock_guard _(mtx); }\n        cond.notify_all();\n      }\n    private:\n      mutable mutex mtx;\n      mutable condition_variable cond;\n      using enum memory_order;\n    };"
  },
  {
    "url": "https://stackoverflow.com/questions/69660148/c20-how-to-wait-on-an-atomic-object-with-timeout",
    "body": "    template <class T> struct timed_atomic : atomic<T> {\n      using atomic<T>::atomic;\n      bool try_wait(T old, memory_order order = seq_cst) const noexcept {\n        T value = this->load(order);\n        // TODO: Ignore padding bits in comparison\n        return memcmp(addressof(value), addressof(old), sizeof(T));\n      }\n      template <class Rep, class Period>\n      bool wait_for(T old, const duration<Rep, Period> &rel_time,\n                    memory_order order = seq_cst) const {\n        return wait_until(old, steady_clock::now() + rel_time, order);\n      }\n      template <class Clock, class Duration>\n      bool wait_until(T old, const time_point<Clock, Duration> &abs_time,\n                      memory_order order = seq_cst) const {\n        while (!try_wait(old, order)) {\n          if (Clock::now() >= abs_time)\n            return false;\n          sleep_for(100ms);\n        }\n        return true;\n      }\n      // NOTE: volatile overloads are omitted\n    private:\n      using enum memory_order;\n    };"
  },
  {
    "url": "https://stackoverflow.com/questions/55495932/why-does-the-buffering-of-stdifstream-break-stdgetline-when-using-llvm",
    "body": "typedef struct pipe_reader {\n    FILE* stream;\n    char* line_buf;\n    size_t buf_size;\n} pipe_reader;\npipe_reader new_reader(const char* pipe_path) {\n    pipe_reader preader;\n    preader.stream = fopen(pipe_path, \"r\");\n    preader.line_buf = NULL;\n    preader.buf_size = 0;\n    return preader;\n}\nbool check_reader(const pipe_reader* preader) {\n    if (!preader || preader->stream == NULL) {\n        return false;\n    }\n    return true;\n}\nconst char* recv_msg(pipe_reader* preader) {\n    if (!check_reader(preader)) {\n        return NULL;\n    }\n    ssize_t read = getline(&preader->line_buf, &preader->buf_size, preader->stream);\n    if (read > 0) {\n        preader->line_buf[read - 1] = '\\0';\n        return preader->line_buf;\n    }\n    return NULL;\n}\nvoid close_reader(pipe_reader* preader) {\n    if (!check_reader(preader)) {\n        return;\n    }\n    fclose(preader->stream);\n    preader->stream = NULL;\n    if (preader->line_buf) {\n        free(preader->line_buf);\n        preader->line_buf = NULL;\n    }\n}"
  },
  {
    "url": "https://stackoverflow.com/questions/76843246/why-does-the-address-of-an-out-of-scope-variable-equal-zero-with-constexpr",
    "body": "// In your example, x does exist at compile time, but its lifetime ends after foo() exits.\n// You cannot dereference a pointer &x after x is dead, but you can do some other things:\nint x = 5;\n// The address of a local variable is never null.\n// GCC and clang compile this.\n// You can even perform this comparison outside foo(), like in your assertion, when\n// x has died.\nstatic_assert(&x != nullptr);\n// The distance between two addresses can be computed, if those addresses are\n// constant expresssions. GCC and clang compile this.\nstatic_assert(&x - &x == 0);"
  }
]