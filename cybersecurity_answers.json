[
  {
    "url": "https://stackoverflow.com/questions/549/the-definitive-guide-to-form-based-website-authentication",
    "title": "The definitive guide to form-based website authentication",
    "question_id": 549,
    "posted_date": "2008-08-02T15:51:50",
    "answers": [
      {
        "answer_id": 477578,
        "is_accepted": true,
        "score": 3967,
        "creation_date": "2009-01-25T06:27:46",
        "body_markdown": "## PART I: How To Log In ##\r\n\r\nWe&#39;ll assume you already know how to build a login+password HTML form which POSTs the values to a script on the server side for authentication. The sections below will deal with patterns for sound practical auth, and how to avoid the most common security pitfalls.\r\n\r\n**To HTTPS or not to HTTPS?**\r\n\r\nUnless the connection is already secure (that is, tunneled through HTTPS using SSL/TLS), your login form values will be sent in cleartext, which allows anyone eavesdropping on the line between browser and web server will be able to read logins as they pass through. This type of wiretapping is done routinely by governments, but in general, we won&#39;t address &#39;owned&#39; wires other than to say this: Just use HTTPS.\r\n\r\nIn essence, the only **practical** way to protect against wiretapping/packet sniffing during login is by using HTTPS or another certificate-based encryption scheme (for example, [TLS][1]) or a proven &amp; tested challenge-response scheme (for example, the [Diffie-Hellman][2]-based SRP). *Any other method can be easily circumvented* by an eavesdropping attacker.\r\n\r\nOf course, if you are willing to get a little bit impractical, you could also employ some form of two-factor authentication scheme (e.g. the Google Authenticator app, a physical &#39;cold war style&#39; codebook, or an RSA key generator dongle). If applied correctly, this could work even with an unsecured connection, but it&#39;s hard to imagine that a dev would be willing to implement two-factor auth but not SSL.\r\n\r\n**(Do not) Roll-your-own JavaScript encryption/hashing**\r\n\r\nGiven the perceived (though now [avoidable][27]) cost and technical difficulty of setting up an SSL certificate on your website, some developers are tempted to roll their own in-browser hashing or encryption schemes in order to avoid passing cleartext logins over an unsecured wire.\r\n\r\nWhile this is a noble thought, it is essentially useless (and can be a [security flaw][3]) unless it is combined with one of the above - that is, either securing the line with strong encryption or using a tried-and-tested challenge-response mechanism (if you don&#39;t know what that is, just know that it is one of the most difficult to prove, most difficult to design, and most difficult to implement concepts in digital security).\r\n\r\nWhile it is true that hashing the password *can be* effective against **password disclosure**, it is vulnerable to replay attacks, Man-In-The-Middle attacks / hijackings (if an attacker can inject a few bytes into your unsecured HTML page before it reaches your browser, they can simply comment out the hashing in the JavaScript), or brute-force attacks (since you are handing the attacker both username, salt and hashed password).\r\n\r\n**CAPTCHAS against humanity**\r\n\r\n[CAPTCHA][4] is meant to thwart one specific category of attack: automated dictionary/brute force trial-and-error with no human operator. There is no doubt that this is a real threat, however, there are ways of dealing with it seamlessly that don&#39;t require a CAPTCHA, specifically properly designed server-side login throttling schemes - we&#39;ll discuss those later.\r\n\r\nKnow that CAPTCHA implementations are not created alike; they often aren&#39;t human-solvable, most of them are actually ineffective against bots, all of them are ineffective against cheap third-world labor (according to [OWASP][5], the current sweatshop rate is $12 per 500 tests), and some implementations may be technically illegal in some countries (see [OWASP Authentication Cheat Sheet][6]). If you must use a CAPTCHA, use Google&#39;s [reCAPTCHA][7], since it is OCR-hard by definition (since it uses already OCR-misclassified book scans) and tries very hard to be user-friendly.\r\n\r\nPersonally, I tend to find CAPTCHAS annoying, and use them only as a last resort when a user has failed to log in a number of times and throttling delays are maxed out. This will happen rarely enough to be acceptable, and it strengthens the system as a whole.\r\n\r\n**Storing Passwords / Verifying logins**\r\n\r\nThis may finally be common knowledge after all the highly-publicized hacks and user data leaks we&#39;ve seen in recent years, but it has to be said: Do not store passwords in cleartext in your database. User databases are routinely hacked, leaked or gleaned through SQL injection, and if you are storing raw, plaintext passwords, that is instant game over for your login security.\r\n\r\nSo if you can&#39;t store the password, how do you check that the login+password combination POSTed from the login form is correct? The answer is hashing using a [key derivation function][24]. Whenever a new user is created or a password is changed, you take the password and run it through a KDF, such as Argon2, bcrypt, scrypt or PBKDF2, turning the cleartext password (&quot;correcthorsebatterystaple&quot;) into a long, random-looking string, which is a lot safer to store in your database. To verify a login, you run the same hash function on the entered password, this time passing in the salt and compare the resulting hash string to the value stored in your database. Argon2, bcrypt and scrypt store the salt with the hash already. Check out this [article][23] on sec.stackexchange for more detailed information.\r\n\r\nThe reason a salt is used is that hashing in itself is not sufficient -- you&#39;ll want to add a so-called &#39;salt&#39; to protect the hash against [rainbow tables][8]. A salt effectively prevents two passwords that exactly match from being stored as the same hash value, preventing the whole database being scanned in one run if an attacker is executing a password guessing attack.\r\n\r\nA cryptographic hash should not be used for password storage because user-selected passwords are not strong enough (i.e. do not usually contain enough entropy) and a password guessing attack could be completed in a relatively short time by an attacker with access to the hashes. This is why KDFs are used - these effectively [&quot;stretch the key&quot;][25], which means that every password guess an attacker makes causes multiple repetitions of the hash algorithm, for example 10,000 times, which causes the attacker to guess the password 10,000 times slower.\r\n\r\n**Session data - &quot;You are logged in as Spiderman69&quot;**\r\n\r\nOnce the server has verified the login and password against your user database and found a match, the system needs a way to remember that the browser has been authenticated. This fact should only ever be stored server side in the session data.\r\n\r\n&gt; If you are unfamiliar with session data, here&#39;s how it works: A single randomly-generated string is stored in an expiring cookie and used to reference a collection of data - the session data - which is stored on the server. If you are using an MVC framework, this is undoubtedly handled already.\r\n\r\nIf at all possible, make sure the session cookie has the secure and HTTP Only flags set when sent to the browser. The HttpOnly flag provides some protection against the cookie being read through XSS attack. The secure flag ensures that the cookie is only sent back via HTTPS, and therefore protects against network sniffing attacks. The value of the cookie should not be predictable. Where a cookie referencing a non-existent session is presented, its value should be replaced immediately to prevent [session fixation][9].\r\n\r\nSession state can also be maintained on the client side. This is achieved by using techniques like JWT (JSON Web Token).\r\n\r\n## PART II: How To Remain Logged In - The Infamous &quot;Remember Me&quot; Checkbox ##\r\n\r\nPersistent Login Cookies (&quot;remember me&quot; functionality) are a danger zone; on the one hand, they are entirely as safe as conventional logins when users understand how to handle them; and on the other hand, they are an enormous security risk in the hands of careless users, who may use them on public computers and forget to log out, and who may not know what browser cookies are or how to delete them.\r\n\r\nPersonally, I like persistent logins for the websites I visit on a regular basis, but I know how to handle them safely. If you are positive that your users know the same, you can use persistent logins with a clean conscience. If not - well, then you may subscribe to the philosophy that users who are careless with their login credentials brought it upon themselves if they get hacked. It&#39;s not like we go to our user&#39;s houses and tear off all those facepalm-inducing Post-It notes with passwords they have lined up on the edge of their monitors, either.\r\n\r\nOf course, some systems can&#39;t afford to have *any* accounts hacked; for such systems, there is no way you can justify having persistent logins.\r\n\r\n**If you DO decide to implement persistent login cookies, this is how you do it:**\r\n\r\n 1. First, take some time to read [Paragon Initiative&#39;s article][10] on the subject. You&#39;ll need to get a bunch of elements right, and the article does a great job of explaining each.\r\n\r\n 2. And just to reiterate one of the most common pitfalls, **DO NOT STORE THE PERSISTENT LOGIN COOKIE (TOKEN) IN YOUR DATABASE, ONLY A HASH OF IT!** The login token is Password Equivalent, so if an attacker got their hands on your database, they could use the tokens to log in to any account, just as if they were cleartext login-password combinations. Therefore, use hashing (according to https://security.stackexchange.com/a/63438/5002 a weak hash will do just fine for this purpose) when storing persistent login tokens.\r\n\r\n\r\n## PART III: Using Secret Questions ##\r\n\r\n**Don&#39;t implement &#39;secret questions&#39;**. The &#39;secret questions&#39; feature is a security anti-pattern. Read the paper from link number 4 from the MUST-READ list. You can ask Sarah Palin about that one, after her Yahoo! email account got hacked during a previous presidential campaign because the answer to her security question was... &quot;Wasilla High School&quot;!\r\n\r\nEven with user-specified questions, it is highly likely that most users will choose either:\r\n\r\n - A &#39;standard&#39; secret question like mother&#39;s maiden name or favorite pet\r\n\r\n - A simple piece of trivia that anyone could lift from their blog, LinkedIn profile, or similar\r\n\r\n - Any question that is easier to answer than guessing their password. Which, for any decent password, is every question you can imagine\r\n\r\n**In conclusion, security questions are inherently insecure in virtually all their forms and variations, and should not be employed in an authentication scheme for any reason.**\r\n\r\nThe true reason why security questions even exist in the wild is that they conveniently save the cost of a few support calls from users who can&#39;t access their email to get to a reactivation code. This at the expense of security and Sarah Palin&#39;s reputation. Worth it? Probably not.\r\n\r\n## PART IV: Forgotten Password Functionality ##\r\n\r\nI already mentioned why you should **never use security questions** for handling forgotten/lost user passwords; it also goes without saying that you should never e-mail users their actual passwords. There are at least two more all-too-common pitfalls to avoid in this field:\r\n\r\n 1. Don&#39;t *reset* a forgotten password to an autogenerated strong password - such passwords are notoriously hard to remember, which means the user must either change it or write it down - say, on a bright yellow Post-It on the edge of their monitor. Instead of setting a new password, just let users pick a new one right away - which is what they want to do anyway. (An exception to this might be if the users are universally using a password manager to store/manage passwords that would normally be impossible to remember without writing it down).\r\n\r\n 2. Always hash the lost password code/token in the database. ***AGAIN***, this code is another example of a Password Equivalent, so it MUST be hashed in case an attacker got their hands on your database. When a lost password code is requested, send the plaintext code to the user&#39;s email address, then hash it, save the hash in your database -- and *throw away the original*. Just like a password or a persistent login token.\r\n\r\nA final note: always make sure your interface for entering the &#39;lost password code&#39; is at least as secure as your login form itself, or an attacker will simply use this to gain access instead. Making sure you generate very long &#39;lost password codes&#39; (for example, 16 case-sensitive alphanumeric characters) is a good start, but consider adding the same throttling scheme that you do for the login form itself.\r\n\r\n## PART V: Checking Password Strength ##\r\n\r\nFirst, you&#39;ll want to read this small article for a reality check: [The 500 most common passwords][11]\r\n\r\nOkay, so maybe the list isn&#39;t the *canonical* list of most common passwords on *any* system *anywhere ever*, but it&#39;s a good indication of how poorly people will choose their passwords when there is no enforced policy in place. Plus, the list looks frighteningly close to home when you compare it to publicly available analyses of recently stolen passwords.\r\n\r\nSo: With no minimum password strength requirements, 2% of users use one of the top 20 most common passwords. Meaning: if an attacker gets just 20 attempts, 1 in 50 accounts on your website will be crackable.\r\n\r\nThwarting this requires calculating the entropy of a password and then applying a threshold.  The National Institute of Standards and Technology (NIST) [Special Publication 800-63][12] has a set of very good suggestions.  That, when combined with a dictionary and keyboard layout analysis (for example, &#39;qwertyuiop&#39; is a bad password), can [reject 99% of all poorly selected passwords][13] at a level of 18 bits of entropy.  Simply calculating password strength and [showing a visual strength meter][14] to a user is good, but insufficient.  Unless it is enforced, a lot of users will most likely ignore it.\r\n\r\nAnd for a refreshing take on user-friendliness of high-entropy passwords, Randall Munroe&#39;s [Password Strength xkcd][15] is highly recommended.\r\n\r\nUtilize Troy Hunt&#39;s [Have I Been Pwned API][26] to check users passwords against passwords compromised in public data breaches.\r\n\r\n## PART VI: Much More - Or: Preventing Rapid-Fire Login Attempts ##\r\n\r\nFirst, have a look at the numbers: [Password Recovery Speeds - How long will your password stand up][16]\r\n\r\nIf you don&#39;t have the time to look through the tables in that link, here&#39;s the list of them:\r\n\r\n 1. It takes *virtually no time* to crack a weak password, even if you&#39;re cracking it with an abacus\r\n\r\n 2. It takes *virtually no time* to crack an alphanumeric 9-character password if it is **case insensitive**\r\n\r\n 3. It takes *virtually no time* to crack an intricate, symbols-and-letters-and-numbers, upper-and-lowercase password if it is **less than 8 characters long** (a desktop PC can search the entire keyspace up to 7 characters in a matter of days or even hours)\r\n\r\n 4. **It would, however, take an inordinate amount of time to crack even a 6-character password, *if you were limited to one attempt per second!***\r\n\r\n\r\nSo what can we learn from these numbers? Well, lots, but we can focus on the most important part: the fact that preventing large numbers of rapid-fire successive login attempts (ie. the *brute force* attack) really isn&#39;t that difficult. But preventing it *right* isn&#39;t as easy as it seems.\r\n\r\nGenerally speaking, you have three choices that are all effective against brute-force attacks *(and dictionary attacks, but since you are already employing a strong passwords policy, they shouldn&#39;t be an issue)*:\r\n\r\n - Present a **CAPTCHA** after N failed attempts (annoying as hell and often ineffective -- but I&#39;m repeating myself here)\r\n\r\n - **Locking accounts** and requiring email verification after N failed attempts (this is a [DoS][17] attack waiting to happen)\r\n\r\n - And finally, **login throttling**: that is, setting a time delay between attempts after N failed attempts (yes, DoS attacks are still possible, but at least they are far less likely and a lot more complicated to pull off).\r\n\r\n**Best practice #1:** A short time delay that increases with the number of failed attempts, like:\r\n\r\n - 1 failed attempt = no delay\r\n - 2 failed attempts = 2 sec delay\r\n - 3 failed attempts = 4 sec delay\r\n - 4 failed attempts = 8 sec delay\r\n - 5 failed attempts = 16 sec delay\r\n - etc.\r\n\r\nDoS attacking this scheme would be very impractical, since the resulting lockout time is slightly larger than the sum of the previous lockout times.\r\n\r\n&gt; To clarify: The delay is *not* a delay before returning the response to the browser. It is more like a timeout or refractory period during which login attempts to a specific account or from a specific IP address will not be accepted or evaluated at all. That is, correct credentials will not return in a successful login, and incorrect credentials will not trigger a delay increase.\r\n\r\n**Best practice #2:** A medium length time delay that goes into effect after N failed attempts, like:\r\n\r\n - 1-4 failed attempts = no delay\r\n - 5 failed attempts = 15-30 min delay\r\n\r\nDoS attacking this scheme would be quite impractical, but certainly doable. Also, it might be relevant to note that such a long delay can be very annoying for a legitimate user. Forgetful users will dislike you.\r\n\r\n**Best practice #3:** Combining the two approaches - either a fixed, short time delay that goes into effect after N failed attempts, like:\r\n\r\n - 1-4 failed attempts = no delay\r\n - 5+ failed attempts = 20 sec delay\r\n\r\nOr, an increasing delay with a fixed upper bound, like:\r\n\r\n - 1 failed attempt = 5 sec delay\r\n - 2 failed attempts = 15 sec delay\r\n - 3+ failed attempts = 45 sec delay\r\n\r\nThis final scheme was taken from the OWASP best-practices suggestions (link 1 from the MUST-READ list) and should be considered best practice, even if it is admittedly on the restrictive side.\r\n\r\n&gt; *As a rule of thumb, however, I would say: the stronger your password policy is, the less you have to bug users with delays. If you require strong (case-sensitive alphanumerics + required numbers and symbols) 9+ character passwords, you could give the users 2-4 non-delayed password attempts before activating the throttling.*\r\n\r\nDoS attacking this final login throttling scheme would be ***very*** impractical. And as a final touch, always allow persistent (cookie) logins (and/or a CAPTCHA-verified login form) to pass through, so legitimate users won&#39;t even be delayed *while the attack is in progress*. That way, the very impractical DoS attack becomes an *extremely* impractical attack.\r\n\r\nAdditionally, it makes sense to do more aggressive throttling on admin accounts, since those are the most attractive entry points\r\n\r\n## PART VII: Distributed Brute Force Attacks ##\r\n\r\nJust as an aside, more advanced attackers will try to circumvent login throttling by &#39;spreading their activities&#39;:\r\n\r\n - Distributing the attempts on a botnet to prevent IP address flagging\r\n\r\n - Rather than picking one user and trying the 50.000 most common passwords (which they can&#39;t, because of our throttling), they will pick THE most common password and try it against 50.000 users instead. That way, not only do they get around maximum-attempts measures like CAPTCHAs and login throttling, their chance of success increases as well, since the number 1 most common password is far more likely than number 49.995\r\n\r\n - Spacing the login requests for each user account, say, 30 seconds apart, to sneak under the radar\r\n\r\nHere, the best practice would be **logging the number of failed logins, system-wide**, and using a running average of your site&#39;s bad-login frequency as the basis for an upper limit that you then impose on all users.\r\n\r\nToo abstract? Let me rephrase:\r\n\r\nSay your site has had an average of 120 bad logins per day over the past 3 months. Using that (running average), your system might set the global limit to 3 times that -- ie. 360 failed attempts over a 24 hour period. Then, if the total number of failed attempts across all accounts exceeds that number within one day (or even better, monitor the rate of acceleration and trigger on a calculated threshold), it activates system-wide login throttling - meaning short delays for ALL users (still, with the exception of cookie logins and/or backup CAPTCHA logins).\r\n\r\nI also posted a question with [more details and a really good discussion of how to avoid tricky pitfals][18] in fending off distributed brute force attacks\r\n\r\n## PART VIII: Two-Factor Authentication and Authentication Providers ##\r\n\r\nCredentials can be compromised, whether by exploits, passwords being written down and lost, laptops with keys being stolen, or users entering logins into phishing sites.  Logins can be further protected with two-factor authentication, which uses out-of-band factors such as single-use codes received from a phone call, SMS message, app, or dongle. Several providers offer two-factor authentication services.\r\n\r\nAuthentication can be completely delegated to a single-sign-on service, where another provider handles collecting credentials. This pushes the problem to a trusted third party. Google and Twitter both provide standards-based SSO services, while Facebook provides a similar proprietary solution.\r\n\r\n## MUST-READ LINKS About Web Authentication ##\r\n\r\n 1. [OWASP Guide To Authentication][6] / [OWASP Authentication Cheat Sheet][19]\r\n 2. [Dos and Donâ€™ts of Client Authentication on the Web (very readable MIT research paper)][20]\r\n 3. [Wikipedia: HTTP cookie][21]\r\n 4. [Personal knowledge questions for fallback authentication: Security questions in the era of Facebook (very readable Berkeley research paper)][22]\r\n\r\n\r\n  [1]: https://en.wikipedia.org/wiki/Transport_Layer_Security\r\n  [2]: https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange\r\n  [3]: https://stackoverflow.com/questions/1380168/does-it-make-security-sense-to-hash-password-on-client-end\r\n  [4]: https://en.wikipedia.org/wiki/CAPTCHA\r\n  [5]: https://en.wikipedia.org/wiki/OWASP\r\n  [6]: https://www.owasp.org/index.php/Authentication_Cheat_Sheet\r\n  [7]: https://en.wikipedia.org/wiki/ReCAPTCHA\r\n  [8]: https://en.wikipedia.org/wiki/Rainbow_table\r\n  [9]: https://owasp.org/www-community/attacks/Session_fixation\r\n  [10]: https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence\r\n  [11]: http://www.whatsmypass.com/?p=415\r\n  [12]: https://en.wikipedia.org/wiki/Password_strength#NIST_Special_Publication_800-63\r\n  [13]: https://cubicspot.blogspot.com/2012/01/how-to-calculate-password-strength-part.html\r\n  [14]: https://blogs.dropbox.com/tech/2012/04/zxcvbn-realistic-password-strength-estimation/\r\n  [15]: https://xkcd.com/936/\r\n  [16]: https://www.lockdown.co.uk/?pg=combi&amp;s=articles\r\n  [17]: https://en.wikipedia.org/wiki/Denial-of-service_attack\r\n  [18]: https://stackoverflow.com/questions/479233/what-is-the-best-distributed-brute-force-countermeasure\r\n  [19]: https://www.owasp.org/index.php/Authentication_Cheat_Sheet\r\n  [20]: https://pdos.csail.mit.edu/papers/webauth:sec10.pdf\r\n  [21]: https://en.wikipedia.org/wiki/HTTP_cookie#Drawbacks_of_cookies\r\n  [22]: https://cups.cs.cmu.edu/soups/2008/proceedings/p13Rabkin.pdf\r\n  [23]: https://security.stackexchange.com/a/31846/8340\r\n  [24]: https://en.wikipedia.org/wiki/Key_derivation_function\r\n  [25]: https://en.wikipedia.org/wiki/Key_stretching\r\n  [26]: https://haveibeenpwned.com/API/\r\n  [27]: https://letsencrypt.org/",
        "code_snippets": [],
        "author": {
          "display_name": "Jens Roland",
          "reputation": 27780,
          "profile_link": "https://stackoverflow.com/users/57068/jens-roland"
        }
      },
      {
        "answer_id": 555,
        "is_accepted": false,
        "score": 434,
        "creation_date": "2008-08-02T16:40:45",
        "body_markdown": "# Definitive Article\r\n\r\n### Sending credentials\r\nThe only practical way to send credentials 100% securely is by using [SSL][1]. Using JavaScript to hash the password is not safe. Common pitfalls for client-side password hashing:\r\n\r\n* If the connection between the client and server is unencrypted, everything you do is [vulnerable to man-in-the-middle attacks][2]. An attacker could replace the incoming javascript to break the hashing or send all credentials to their server, they could listen to client responses and impersonate the users perfectly, etc. etc. SSL with trusted Certificate Authorities is designed to prevent MitM attacks.\r\n* The hashed password received by the server is [less secure][3] if you don&#39;t do additional, redundant work on the server.\r\n\r\nThere&#39;s another secure method called **SRP**, but it&#39;s patented (although it is [freely licensed][4]) and there are few good implementations available.\r\n\r\n### Storing passwords\r\nDon&#39;t ever store passwords as plaintext in the database. Not even if you don&#39;t care about the security of your own site. Assume that some of your users will reuse the password of their online bank account. So, store the hashed password, and throw away the original. And make sure the password doesn&#39;t show up in access logs or application logs. OWASP [recommends the use of Argon2](https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet#Impose_infeasible_verification_on_attacker) as your first choice for new applications. If this is not available, PBKDF2 or scrypt should be used instead. And finally if none of the above are available, use bcrypt.\r\n\r\nHashes by themselves are also insecure. For instance, identical passwords mean identical hashes--this makes hash lookup tables an effective way of cracking lots of passwords at once. Instead, store the **salted** hash. A salt is a string appended to the password prior to hashing - use a different (random) salt per user. The salt is a public value, so you can store them with the hash in the database. See [here](http://www.codeproject.com/Articles/704865/Salted-Password-Hashing-Doing-it-Right) for more on this.\r\n\r\nThis means that you can&#39;t send the user their forgotten passwords (because you only have the hash). Don&#39;t reset the user&#39;s password unless you have authenticated the user (users must prove that they are able to read emails sent to the stored (and validated) email address.)\r\n\r\n### Security questions \r\n\r\nSecurity questions are insecure - avoid using them. Why? Anything a security question does, a password does better. Read ***PART III: Using Secret Questions*** in [@Jens Roland answer][6] here in this wiki.\r\n\r\n### Session cookies\r\n\r\nAfter the user logs in, the server sends the user a session cookie. The server can retrieve the username or id from the cookie, but nobody else can generate such a cookie (TODO explain mechanisms).\r\n\r\n[Cookies can be hijacked][7]: they are only as secure as the rest of the client&#39;s machine and other communications. They can be read from disk, sniffed in network traffic, lifted by a cross-site scripting attack, phished from a poisoned DNS so the client sends their cookies to the wrong servers. Don&#39;t send persistent cookies. Cookies should expire at the end of the client session (browser close or leaving your domain).\r\n\r\nIf you want to autologin your users, you can set a persistent cookie, but it should be distinct from a full-session cookie. You can set an additional flag that the user has auto-logged in, and needs to log in for real for sensitive operations. This is popular with shopping sites that want to provide you with a seamless, personalized shopping experience but still protect your financial details. For example, when you return to visit Amazon, they show you a page that looks like you&#39;re logged in, but when you go to place an order (or change your shipping address, credit card etc.), they ask you to confirm your password.\r\n\r\nFinancial websites such as banks and credit cards, on the other hand, only have sensitive data and should not allow auto-login or a low-security mode.\r\n\r\n### List of external resources\r\n\r\n- [Dos and Don&#39;ts of Client Authentication on the Web (PDF)](http://pdos.csail.mit.edu/papers/webauth:sec10.pdf)  \r\n  21 page academic article with many great tips.  \r\n- [Ask YC: Best Practices for User Authentication](http://news.ycombinator.com/item?id=205572)  \r\n  Forum discussion on the subject  \r\n- [You&#39;re Probably Storing Passwords Incorrectly](http://www.codinghorror.com/blog/archives/000953.html)  \r\n  Introductory article about storing passwords\r\n- [Discussion: Coding Horror: You&#39;re Probably Storing Passwords Incorrectly](http://news.ycombinator.com/item?id=55660)  \r\n  Forum discussion about a Coding Horror article.\r\n- [Never store passwords in a database!](&lt;http://blog.moertel.com/articles/2006/12/15/never-store-passwords-in-a-database)  \r\n  Another warning about storing passwords in the database.\r\n- [Password cracking](http://en.wikipedia.org/wiki/Password_cracking)  \r\n  Wikipedia article on weaknesses of several password hashing schemes.\r\n- [Enough With The Rainbow Tables: What You Need To Know About Secure Password Schemes](http://www.securityfocus.com/blogs/262)  \r\n  Discussion about rainbow tables and how to defend against them, and against other threads. Includes extensive discussion.\r\n\r\n\r\n  [1]: http://en.wikipedia.org/wiki/SSL\r\n  [2]: https://stackoverflow.com/questions/14907581/ssl-and-man-in-the-middle-misunderstanding\r\n  [3]: https://security.stackexchange.com/questions/45254/owasp-recommendation-on-client-side-password-hashing\r\n  [4]: http://srp.stanford.edu/license.txt\r\n  [5]: https://security.stackexchange.com/questions/4781/do-any-security-experts-recommend-bcrypt-for-password-storage\r\n  [6]: http://srp.stanford.edu/license.txt\r\n  [7]: http://en.wikipedia.org/wiki/Session_hijacking",
        "code_snippets": [],
        "author": {
          "display_name": "Michiel de Mare",
          "reputation": 42480,
          "profile_link": "https://stackoverflow.com/users/136/michiel-de-mare"
        }
      }
    ]
  },
  {
    "url": "https://stackoverflow.com/questions/2669690/why-does-google-prepend-while1-to-their-json-responses",
    "title": "Why does Google prepend while(1); to their JSON responses?",
    "question_id": 2669690,
    "posted_date": "2010-04-19T14:00:09",
    "answers": [
      {
        "answer_id": 2669766,
        "is_accepted": true,
        "score": 4601,
        "creation_date": "2010-04-19T14:11:41",
        "body_markdown": "It prevents [JSON hijacking](http://haacked.com/archive/2009/06/25/json-hijacking.aspx), a major JSON security issue that is formally [fixed][1] in all major browsers [since 2011][2] with ECMAScript 5.\r\n\r\nContrived example: say Google has a URL like `mail.google.com/json?action=inbox` which returns the first 50 messages of your inbox in JSON format. Evil websites on other domains can&#39;t make AJAX requests to get this data due to the same-origin policy, but they can include the URL via a `&lt;script&gt;` tag. The URL is visited with *your* cookies, and by [overriding the global array constructor or accessor methods](http://ejohn.org/blog/re-securing-json/) they can have a method called whenever an object (array or hash) attribute is set, allowing them to read the JSON content.\r\n\r\nThe `while(1);` or `&amp;&amp;&amp;BLAH&amp;&amp;&amp;` prevents this: an AJAX request at `mail.google.com` will have full access to the text content, and can strip it away. But a `&lt;script&gt;` tag insertion blindly executes the JavaScript without any processing, resulting in either an infinite loop or a syntax error.\r\n\r\nThis does not address the issue of [cross-site request forgery][3].\r\n\r\n\r\n  [1]: https://security.stackexchange.com/questions/155518/why-json-hijacking-attack-doesnt-work-in-modern-browsers-how-was-it-fixed\r\n  [2]: https://caniuse.com/#feat=es5\r\n  [3]: https://en.wikipedia.org/wiki/Cross-site_request_forgery",
        "code_snippets": [],
        "author": {
          "display_name": "rjh",
          "reputation": 50324,
          "profile_link": "https://stackoverflow.com/users/74496/rjh"
        }
      },
      {
        "answer_id": 21510402,
        "is_accepted": false,
        "score": 675,
        "creation_date": "2014-02-02T07:09:00",
        "body_markdown": "It prevents disclosure of the response through JSON hijacking.\r\n\r\nIn theory, the content of HTTP responses is protected by the Same Origin Policy: pages from one domain cannot get any pieces of information from pages on the other domain (unless explicitly allowed).\r\n\r\nAn attacker can request pages on other domains on your behalf, e.g. by using a `&lt;script src=...&gt;` or `&lt;img&gt;` tag, but it can&#39;t get any information about the result (headers, contents).\r\n\r\nThus, if you visit an attacker&#39;s page, it couldn&#39;t read your email from gmail.com.\r\n\r\nExcept that when using a script tag to request JSON content, the JSON is executed as JavaScript in an attacker&#39;s controlled environment. If the attacker can replace the Array or Object constructor or some other method used during object construction, anything in the JSON would pass through the attacker&#39;s code, and be disclosed.  \r\n\r\nNote that this happens when the JSON is executed as JavaScript, not when it&#39;s parsed.\r\n\r\nThere are multiple countermeasures:\r\n\r\n# Making sure the JSON never executes\r\n\r\nBy placing a `while(1);` statement before the JSON data, Google ensures that the JSON data is never executed as JavaScript.\r\n\r\nOnly a legitimate page could actually get the whole content, strip the `while(1);`, and parse the remainder as JSON.\r\n\r\nThings like `for(;;);` have been seen on Facebook for instance, with the same results.\r\n\r\n# Making sure the JSON is not valid JavaScript\r\n\r\nSimilarly, adding invalid tokens before the JSON, like `&amp;&amp;&amp;START&amp;&amp;&amp;`, makes sure that it is never executed.\r\n\r\n# Always return JSON with an Object on the outside\r\n\r\nThis is [OWASP recommended way](https://cheatsheetseries.owasp.org/cheatsheets/AJAX_Security_Cheat_Sheet.html#always-return-json-with-an-object-on-the-outside) to protect from JSON hijacking and is the less intrusive one.\r\n\r\nSimilarly to the previous counter-measures, it makes sure that the JSON is never executed as JavaScript.\r\n\r\nA valid JSON object, when not enclosed by anything, is not valid in JavaScript, since the `{ }` gets interpreted as a code block:\r\n\r\n    eval(&#39;{&quot;foo&quot;:&quot;bar&quot;}&#39;)\r\n    // SyntaxError: Unexpected token :\r\n\r\nThis is however valid JSON:\r\n\r\n    JSON.parse(&#39;{&quot;foo&quot;:&quot;bar&quot;}&#39;)\r\n    // Object {foo: &quot;bar&quot;}\r\n\r\nSo, make sure you always return an Object at the top level of the response and make sure that the JSON is not valid JavaScript, while still being valid JSON.\r\n\r\nAs noted by @hvd in the comments, the empty object `{}` is valid JavaScript, and knowing the object is empty may itself be valuable information.\r\n\r\n# Comparison of the above methods\r\n\r\nThe OWASP way is less intrusive, as it needs no client library changes, and transfers valid JSON. It is unsure whether past or future browser bugs could defeat this, however.  As noted by @oriadam, it is unclear whether data could be leaked in a parse error through an error handling or not (e.g. window.onerror).\r\n\r\nGoogle&#39;s way requires a client library in order for it to support automatic de-serialization and can be considered to be safer with regard to browser bugs.\r\n\r\nBoth methods require server-side changes in order to avoid developers accidentally sending vulnerable JSON.",
        "code_snippets": [],
        "author": {
          "display_name": "Arnaud Le Blanc",
          "reputation": 99959,
          "profile_link": "https://stackoverflow.com/users/576875/arnaud-le-blanc"
        }
      },
      {
        "answer_id": 871508,
        "is_accepted": false,
        "score": 397,
        "creation_date": "2009-05-15T22:08:49",
        "body_markdown": "This is to ensure some other site can&#39;t do nasty tricks to try to steal your data. For example, by [replacing the array constructor][1], then including this JSON URL via a `&lt;script&gt;` tag, a malicious third-party site could steal the data from the JSON response. By putting a `while(1);` at the start, the script will hang instead.\r\n\r\nA same-site request using XHR and a separate JSON parser, on the other hand, can easily ignore the `while(1);` prefix.\r\n\r\n  [1]: http://ejohn.org/blog/re-securing-json/",
        "code_snippets": [],
        "author": {
          "display_name": "bdonlan",
          "reputation": 231639,
          "profile_link": "https://stackoverflow.com/users/36723/bdonlan"
        }
      }
    ]
  },
  {
    "url": "https://stackoverflow.com/questions/8881291/why-is-char-preferred-over-string-for-passwords",
    "title": "Why is char[] preferred over String for passwords?",
    "question_id": 8881291,
    "posted_date": "2012-01-16T09:20:42",
    "answers": [
      {
        "answer_id": 8881376,
        "is_accepted": true,
        "score": 4757,
        "creation_date": "2012-01-16T09:26:16",
        "body_markdown": "[Strings are immutable][1]. That means once you&#39;ve created the `String`, if another process can dump memory, there&#39;s no way (aside from [reflection](https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29)) you can get rid of the data before [garbage collection](https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29) kicks in.\r\n\r\nWith an array, you can explicitly wipe the data after you&#39;re done with it. You can overwrite the array with anything you like, and the password won&#39;t be present anywhere in the system, even before garbage collection.\r\n\r\nSo yes, this *is* a security concern - but even using `char[]` only reduces the window of opportunity for an attacker, and it&#39;s only for this specific type of attack.\r\n\r\nAs noted in the comments, it&#39;s possible that arrays being moved by the garbage collector will leave stray copies of the data in memory. I believe this is implementation-specific - the garbage collector *may* clear all memory as it goes, to avoid this sort of thing. Even if it does, there&#39;s still the time during which the `char[]` contains the actual characters as an attack window.\r\n\r\n\r\n  [1]: https://stackoverflow.com/questions/1552301/immutability-of-strings-in-java",
        "code_snippets": [],
        "author": {
          "display_name": "Jon Skeet",
          "reputation": 1506317,
          "profile_link": "https://stackoverflow.com/users/22656/jon-skeet"
        }
      },
      {
        "answer_id": 8885343,
        "is_accepted": false,
        "score": 1347,
        "creation_date": "2012-01-16T14:37:30",
        "body_markdown": "While other suggestions here seem valid, there is one other good reason. With plain `String` you have much higher chances of **accidentally printing the password to logs**, monitors or some other insecure place. `char[]` is less vulnerable.\r\n\r\nConsider this:\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tObject pw = &quot;Password&quot;;\r\n\t\tSystem.out.println(&quot;String: &quot; + pw);\r\n\t\r\n\t\tpw = &quot;Password&quot;.toCharArray();\r\n\t\tSystem.out.println(&quot;Array: &quot; + pw);\r\n\t}\r\n\r\nPrints:\r\n\r\n\tString: Password\r\n\tArray: [C@5829428e",
        "code_snippets": [],
        "author": {
          "display_name": "Konrad Garus",
          "reputation": 54085,
          "profile_link": "https://stackoverflow.com/users/277683/konrad-garus"
        }
      },
      {
        "answer_id": 8889285,
        "is_accepted": false,
        "score": 752,
        "creation_date": "2012-01-16T22:20:57",
        "body_markdown": "To quote an official document, the [Java Cryptography Architecture guide][1] says this about `char[]` vs. `String` passwords (about password-based encryption, but this is more generally about passwords of course):\r\n\r\n&gt; It would seem logical to collect and store the password in an object\r\n&gt; of type `java.lang.String`. However, here&#39;s the caveat: `Object`s of\r\n&gt; type `String` are immutable, i.e., there are no methods defined that\r\n&gt; allow you to change (overwrite) or zero out the contents of a `String`\r\n&gt; after usage. This feature makes `String` objects unsuitable for\r\n&gt; storing security sensitive information such as user passwords. You\r\n&gt; should always collect and store security sensitive information in a\r\n&gt; `char` array instead.\r\n\r\n[Guideline 2-2 of the Secure Coding Guidelines for the Java Programming Language, Version 4.0][2] also says something similar (although it is originally in the context of logging):\r\n\r\n&gt; *Guideline 2-2: Do not log highly sensitive information*\r\n&gt; \r\n&gt; Some information, such as Social Security numbers (SSNs) and\r\n&gt; passwords, is highly sensitive. This information should not be kept\r\n&gt; for longer than necessary nor where it may be seen, even by\r\n&gt; administrators. For instance, it should not be sent to log files and\r\n&gt; its presence should not be detectable through searches. Some transient\r\n&gt; data may be kept in mutable data structures, such as char arrays, and\r\n&gt; cleared immediately after use. Clearing data structures has reduced\r\n&gt; effectiveness on typical Java runtime systems as objects are moved in\r\n&gt; memory transparently to the programmer.\r\n&gt; \r\n&gt; This guideline also has implications for implementation and use of\r\n&gt; lower-level libraries that do not have semantic knowledge of the data\r\n&gt; they are dealing with. As an example, a low-level string parsing\r\n&gt; library may log the text it works on. An application may parse an SSN\r\n&gt; with the library. This creates a situation where the SSNs are\r\n&gt; available to administrators with access to the log files.\r\n\r\n\r\n  [1]: http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#PBEEx\r\n  [2]: http://www.oracle.com/technetwork/java/seccodeguide-139067.html#2",
        "code_snippets": [],
        "author": {
          "display_name": "Bruno",
          "reputation": 122894,
          "profile_link": "https://stackoverflow.com/users/372643/bruno"
        }
      },
      {
        "answer_id": 8881395,
        "is_accepted": false,
        "score": 393,
        "creation_date": "2012-01-16T09:27:33",
        "body_markdown": "Character arrays (`char[]`) can be cleared after use by setting each character to zero and Strings not. If someone can somehow see the memory image, they can see a password in plain text if Strings are used, but if `char[]` is used, after purging data with 0&#39;s, the password is secure.\r\n",
        "code_snippets": [],
        "author": {
          "display_name": "alephx",
          "reputation": 4928,
          "profile_link": "https://stackoverflow.com/users/1011704/alephx"
        }
      }
    ]
  },
  {
    "url": "https://stackoverflow.com/questions/60174/how-can-i-prevent-sql-injection-in-php",
    "title": "How can I prevent SQL injection in PHP?",
    "question_id": 60174,
    "posted_date": "2008-09-12T19:55:00",
    "answers": [
      {
        "answer_id": 60496,
        "is_accepted": true,
        "score": 9695,
        "creation_date": "2008-09-13T08:30:26",
        "body_markdown": "The *correct* way to avoid SQL injection attacks, no matter which database you use, is to **separate the data from SQL**, so that data stays data and will **never be interpreted** as commands by the SQL parser. It is possible to create an SQL statement with correctly formatted data parts, but if you don&#39;t *fully* understand the details, you should always **use prepared statements and parameterized queries.** These are SQL statements that are sent to and parsed by the database server separately from any parameters. This way it is impossible for an attacker to inject malicious SQL.\r\n\r\nYou basically have two options to achieve this:\r\n\r\n1. Using [**PDO**][1] (for any supported database driver):\r\n\r\n       $stmt = $pdo-&gt;prepare(&#39;SELECT * FROM users WHERE name = :name&#39;);\r\n       $stmt-&gt;execute([ &#39;name&#39; =&gt; $name ]);\r\n\r\n       foreach ($stmt as $row) {\r\n           // Do something with $row\r\n       }\r\n\r\n2. Using [**MySQLi**][2] (for MySQL):   \r\n **Since PHP 8.2+** we can make use of [`execute_query()`][3] which prepares, binds parameters, and executes SQL statement in one method:\r\n    ```php\r\n    $result = $db-&gt;execute_query(&#39;SELECT * FROM users WHERE name = ?&#39;, [$name]);\r\n    while ($row = $result-&gt;fetch_assoc()) {\r\n        // Do something with $row\r\n    }\r\n    ```\r\n    **Up to PHP8.1:**\r\n    ```php\r\n    $stmt = $db-&gt;prepare(&#39;SELECT * FROM employees WHERE name = ?&#39;);\r\n    $stmt-&gt;bind_param(&#39;s&#39;, $name); // &#39;s&#39; specifies variable type &#39;string&#39;\r\n    $stmt-&gt;execute();\r\n    $result = $stmt-&gt;get_result();\r\n    while ($row = $result-&gt;fetch_assoc()) {\r\n        // Do something with $row\r\n    }\r\n    ```\r\nIf you&#39;re connecting to a database other than MySQL, there is a driver-specific second option that you can refer to (for example, `pg_prepare()` and `pg_execute()` for PostgreSQL). PDO is the universal option.\r\n\r\n\r\n----------\r\n\r\n\r\nCorrectly setting up the connection\r\n-----------------------------------\r\n\r\n#### PDO\r\n\r\nNote that when using **PDO** to access a MySQL database *real* prepared statements are **not used by default**. To fix this you have to disable the emulation of prepared statements. An example of creating a connection using **PDO** is:\r\n\r\n&lt;!-- language: lang-php --&gt;\r\n    $dsn = &#39;mysql:dbname=dbtest;host=127.0.0.1;charset=utf8mb4&#39;;\r\n    $dbConnection = new PDO($dsn, &#39;user&#39;, &#39;password&#39;);\r\n\r\n    $dbConnection-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);\r\n    $dbConnection-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\r\n\r\nIn the above example, the error mode isn&#39;t strictly necessary, **but it is advised to add it**. This way PDO will inform you of all MySQL errors by means of throwing the `PDOException`.\r\n\r\nWhat is **mandatory**, however, is the first `setAttribute()` line, which tells PDO to disable emulated prepared statements and use *real* prepared statements. This makes sure the statement and the values aren&#39;t parsed by PHP before sending it to the MySQL server (giving a possible attacker no chance to inject malicious SQL).\r\n\r\nAlthough you can set the `charset` in the options of the constructor, it&#39;s important to note that &#39;older&#39; versions of PHP (before 5.3.6) [silently ignored the charset parameter][4] in the DSN.\r\n\r\n#### Mysqli\r\n\r\nFor mysqli we have to follow the same routine:\r\n\r\n    mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT); // error reporting\r\n    $dbConnection = new mysqli(&#39;127.0.0.1&#39;, &#39;username&#39;, &#39;password&#39;, &#39;test&#39;);\r\n    $dbConnection-&gt;set_charset(&#39;utf8mb4&#39;); // charset\r\n\r\n----------\r\n\r\n\r\nExplanation\r\n-----------\r\n\r\nThe SQL statement you pass to `prepare` is parsed and compiled by the database server. By specifying parameters (either a `?` or a named parameter like `:name` in the example above) you tell the database engine where you want to filter on. Then when you call `execute`, the prepared statement is combined with the parameter values you specify.\r\n\r\nThe important thing here is that the parameter values are combined with the compiled statement, not an SQL string. SQL injection works by tricking the script into including malicious strings when it creates SQL to send to the database. So by sending the actual SQL separately from the parameters, you limit the risk of ending up with something you didn&#39;t intend.\r\n\r\nAny parameters you send when using a prepared statement will just be treated as strings (although the database engine may do some optimization so parameters may end up as numbers too, of course). In the example above, if the `$name` variable contains `&#39;Sarah&#39;; DELETE FROM employees` the result would simply be a search for the string `&quot;&#39;Sarah&#39;; DELETE FROM employees&quot;`, and you will not end up with [an empty table][5].\r\n\r\nAnother benefit of using prepared statements is that if you execute the same statement many times in the same session it will only be parsed and compiled once, giving you some speed gains.\r\n\r\nOh, and since you asked about how to do it for an insert, here&#39;s an example (using PDO):\r\n\r\n    $stmt = $db-&gt;prepare(&#39;INSERT INTO table (column) VALUES (:column)&#39;);\r\n    $stmt-&gt;execute([&#39;column&#39; =&gt; $value]);\r\n\r\n\r\n----------\r\n\r\n\r\nCan prepared statements be used for dynamic queries?\r\n----------------------------------------------------\r\n\r\nWhile you can still use prepared statements for the query parameters, the structure of the dynamic query itself cannot be parametrized and certain query features cannot be parametrized.\r\n\r\nFor these specific scenarios, the best thing to do is use a whitelist filter that restricts the possible values.\r\n\r\n    // Value whitelist\r\n    // $dir can only be &#39;DESC&#39;, otherwise it will be &#39;ASC&#39;\r\n    if (empty($dir) || $dir !== &#39;DESC&#39;) {\r\n       $dir = &#39;ASC&#39;;\r\n    }\r\n\r\n\r\n  [1]: http://php.net/manual/en/book.pdo.php\r\n  [2]: http://php.net/manual/en/book.mysqli.php\r\n  [3]: https://www.php.net/manual/en/mysqli.execute-query.php\r\n  [4]: http://php.net/manual/en/ref.pdo-mysql.connection.php\r\n  [5]: http://xkcd.com/327/",
        "code_snippets": [
          "php\r\n    $result = $db-&gt;execute_query(&#39;SELECT * FROM users WHERE name = ?&#39;, [$name]);\r\n    while ($row = $result-&gt;fetch_assoc()) {\r\n        // Do something with $row\r\n    }",
          "php\r\n    $stmt = $db-&gt;prepare(&#39;SELECT * FROM employees WHERE name = ?&#39;);\r\n    $stmt-&gt;bind_param(&#39;s&#39;, $name); // &#39;s&#39; specifies variable type &#39;string&#39;\r\n    $stmt-&gt;execute();\r\n    $result = $stmt-&gt;get_result();\r\n    while ($row = $result-&gt;fetch_assoc()) {\r\n        // Do something with $row\r\n    }"
        ],
        "author": {
          "display_name": "Theo",
          "reputation": 133020,
          "profile_link": "https://stackoverflow.com/users/1109/theo"
        }
      },
      {
        "answer_id": 60442,
        "is_accepted": false,
        "score": 1751,
        "creation_date": "2008-09-13T05:48:48",
        "body_markdown": "\r\nTo use the **parameterized query**, you need to use either **Mysqli** or **PDO**. To rewrite your example with Mysqli, we would need something like the following.\r\n\r\n    &lt;?php\r\n    mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);\r\n    $mysqli = new mysqli(&quot;server&quot;, &quot;username&quot;, &quot;password&quot;, &quot;database_name&quot;);\r\n\r\n    $variable = $_POST[&quot;user-input&quot;];\r\n    $stmt = $mysqli-&gt;prepare(&quot;INSERT INTO table (column) VALUES (?)&quot;);\r\n    // &quot;s&quot; means the database expects a string\r\n    $stmt-&gt;bind_param(&quot;s&quot;, $variable);\r\n    $stmt-&gt;execute();\r\n\r\nThe key function you&#39;ll want to read up on there would be [`mysqli::prepare`][4].\r\n\r\nAlso, as others have suggested, you may find it useful/easier to step up a layer of abstraction with something like [PDO][5].\r\n\r\nPlease note that the case you asked about is a fairly simple one and that more complex cases may require more complex approaches. In particular:\r\n\r\n* If you want to alter the structure of the SQL based on user input, parameterized queries are not going to help, and the escaping required is not covered by `mysql_real_escape_string`. In this kind of case, you would be better off passing the user&#39;s input through a whitelist to ensure only &#39;safe&#39; values are allowed through.\r\n\r\n  [1]: http://php.net/mysql_real_escape_string\r\n  [2]: http://php.net/mysqli\r\n  [3]: http://php.net/mysql\r\n  [4]: http://php.net/mysqli.prepare\r\n  [5]: http://php.net/pdo\r\n  [6]: https://stackoverflow.com/users/978756/polynomial\r\n  [7]: http://webappsec.org/projects/articles/091007.txt",
        "code_snippets": [],
        "author": {
          "display_name": "Matt Sheppard",
          "reputation": 118103,
          "profile_link": "https://stackoverflow.com/users/797/matt-sheppard"
        }
      },
      {
        "answer_id": 8255054,
        "is_accepted": false,
        "score": 1187,
        "creation_date": "2011-11-24T04:50:49",
        "body_markdown": "Every answer here covers only part of the problem.\nIn fact, there are **four** different query parts which we can add to SQL dynamically: -\n\n- a string\n- a number\n- an identifier\n- a syntax keyword\n\nAnd prepared statements cover only two of them.\n\nBut sometimes we have to make our query even more dynamic, adding operators or identifiers as well.\nSo, we will need different protection techniques.\n\nIn general, such a protection approach is based on *whitelisting*.\n\nIn this case, every dynamic parameter should be hardcoded in your script and chosen from that set.\nFor example, to do dynamic ordering:\n\n    $orders  = array(&quot;name&quot;, &quot;price&quot;, &quot;qty&quot;); // Field names\n    $key = array_search($_GET[&#39;sort&#39;], $orders)); // if we have such a name\n    $orderby = $orders[$key]; // If not, first one will be set automatically. \n    $query = &quot;SELECT * FROM `table` ORDER BY $orderby&quot;; // Value is safe\n\nTo ease the process I wrote a [whitelist helper function](https://phpdelusions.net/pdo_examples/order_by) that does all the job in one line:\n\n    $orderby = white_list($_GET[&#39;orderby&#39;], &quot;name&quot;, [&quot;name&quot;,&quot;price&quot;,&quot;qty&quot;], &quot;Invalid field name&quot;);\n    $query  = &quot;SELECT * FROM `table` ORDER BY `$orderby`&quot;; // sound and safe\n\nThere is another way to secure identifiers - escaping but I rather stick to whitelisting as a more robust and explicit approach. Yet as long as you have an identifier quoted, you can escape the quote character to make it safe. For example, by default for mysql you have to [double the quote character to escape it](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). For other other DBMS escaping rules would be different.\n\nStill, there is an issue with SQL syntax keywords (such as `AND`, `DESC` and such), but white-listing seems the only approach in this case.\n\nSo, a general recommendation may be phrased as\n\n&gt; - Any variable that represents an SQL data literal, (or, to put it simply - an SQL string, or a number) must be added through a prepared statement. No Exceptions.\n&gt; - Any other query part, such as an SQL keyword, a table or a field name, or an operator - must be filtered through a white list.\n\n### Update\n\nAlthough there is a general agreement on the best practices regarding SQL injection protection, there are **still many bad practices as well.** And some of them too deeply rooted in the minds of PHP users. For instance, on this very page there are (although invisible to most visitors) **more than 80 deleted answers** - all removed by the community due to bad quality or promoting bad and outdated practices. Worse yet, some of the bad answers aren&#39;t deleted, but rather prospering.\n\nFor example, [there(1)][1] [are(2)][2] [still(3)][3] [many(4)][4] [answers(5)][5], including the [second most upvoted answer][6] suggesting you manual string escaping - an outdated approach that is proven to be insecure.\n\nOr there is a slightly better answer that suggests just [another method of string formatting][7] and even boasts it as the ultimate panacea. While of course, it is not. This method is no better than regular string formatting, yet it keeps all its drawbacks: it is applicable to strings only and, like any other manual formatting, it&#39;s essentially optional, non-obligatory measure, prone to human error of any sort.\n\nI think that all this because of one very old superstition, supported by such authorities like [OWASP][8] or [the PHP manual][9], which proclaims equality between whatever &quot;escaping&quot; and protection from SQL injections.\n\nRegardless of what PHP manual said for ages, **`*_escape_string` by no means makes data safe** and never has been intended to. Besides being useless for any SQL part other than string, manual escaping is wrong, because it is manual as opposite to automated.\n\nAnd OWASP makes it even worse, stressing on escaping *user input* which is an utter nonsense: there should be no such words in the context of injection protection. Every variable is potentially dangerous - no matter the source! Or, in other words - every variable has to be properly formatted to be put into a query - no matter the source again. It&#39;s the destination that matters. The moment a developer starts to separate the sheep from the goats (thinking whether some particular variable is &quot;safe&quot; or not) he/she takes his/her first step towards disaster. Not to mention that even the wording suggests bulk escaping at the entry point, resembling the very magic quotes feature - already despised, deprecated and removed.\n\nSo, unlike whatever &quot;escaping&quot;, prepared statements *is* the measure that indeed protects from SQL injection (when applicable).\n\n  [1]: https://stackoverflow.com/a/11802479\n  [2]: https://stackoverflow.com/a/6381189\n  [3]: https://stackoverflow.com/a/60195/\n  [4]: https://stackoverflow.com/a/12426697/\n  [5]: https://stackoverflow.com/a/21179234\n  [6]: https://stackoverflow.com/a/60442\n  [7]: https://stackoverflow.com/a/12710285\n  [8]: https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_4:_Escaping_All_User_Supplied_Input\n  [9]: http://php.net/manual/en/function.mysql-real-escape-string.php#refsect1-function.mysql-real-escape-string-description\n\n",
        "code_snippets": [],
        "author": {
          "display_name": "Your Common Sense",
          "reputation": 158068,
          "profile_link": "https://stackoverflow.com/users/285587/your-common-sense"
        }
      },
      {
        "answer_id": 60180,
        "is_accepted": false,
        "score": 907,
        "creation_date": "2008-09-12T20:02:20",
        "body_markdown": "I&#39;d recommend using [PDO][1] (PHP Data Objects) to run parameterized SQL queries. \r\n\r\nNot only does this protect against SQL injection, but it also speeds up queries. \r\n\r\nAnd by using PDO rather than `mysql_`, `mysqli_`, and `pgsql_` functions, you make your application a little more abstracted from the database, in the rare occurrence that you have to switch database providers.\r\n\r\n  [1]: https://www.php.net/manual/en/book.pdo.php\r\n",
        "code_snippets": [],
        "author": {
          "display_name": "Kibbee",
          "reputation": 66164,
          "profile_link": "https://stackoverflow.com/users/1862/kibbee"
        }
      },
      {
        "answer_id": 60530,
        "is_accepted": false,
        "score": 669,
        "creation_date": "2008-09-13T09:20:56",
        "body_markdown": "Use `PDO` and prepared queries.\r\n\r\n(`$conn` is a `PDO` object)\r\n\r\n    $stmt = $conn-&gt;prepare(&quot;INSERT INTO tbl VALUES(:id, :name)&quot;);\r\n    $stmt-&gt;bindValue(&#39;:id&#39;, $id);\r\n    $stmt-&gt;bindValue(&#39;:name&#39;, $name);\r\n    $stmt-&gt;execute();\r\n\r\n",
        "code_snippets": [],
        "author": {
          "display_name": "Imran",
          "reputation": 91199,
          "profile_link": "https://stackoverflow.com/users/1897/imran"
        }
      },
      {
        "answer_id": 12710285,
        "is_accepted": false,
        "score": 594,
        "creation_date": "2012-10-03T10:07:42",
        "body_markdown": "As you can see, people suggest you use prepared statements at the most. It&#39;s not wrong, but when your query is executed **just once** per process, there would be a slight performance penalty. \r\n\r\nI was facing this issue, but I think I solved it in *very* sophisticated way - the way hackers use to avoid using quotes. I used this in conjunction with emulated prepared statements. I use it to prevent *all* kinds of possible SQL injection attacks.\r\n\r\n## My approach:\r\n\r\n - If you expect input to be integer make sure it&#39;s ***really*** integer. In a variable-type language like PHP it is this *very* important. You can use for example this very simple but powerful solution: `sprintf(&quot;SELECT 1,2,3 FROM table WHERE 4 = %u&quot;, $input);`  \r\n\r\n - If you expect anything else from integer **hex it**. If you hex it, you will perfectly escape all input. In C/C++ there&#39;s a function called [`mysql_hex_string()`][1], in PHP you can use [`bin2hex()`][2].\r\n   \r\n   Don&#39;t worry about that the escaped string will have a 2x size of its original length because even if you use `mysql_real_escape_string`, PHP has to allocate same capacity `((2*input_length)+1)`, which is the same.\r\n\r\n - This hex method is often used when you transfer binary data, but I see no reason why not use it on all data to prevent SQL injection attacks. Note that you have to prepend data with `0x` or use the MySQL function `UNHEX` instead.\r\n\r\nSo, for example, the query:\r\n\r\n    SELECT password FROM users WHERE name = &#39;root&#39;;\r\n\r\nWill become:\r\n\r\n    SELECT password FROM users WHERE name = 0x726f6f74;\r\n\r\nor\r\n\r\n    SELECT password FROM users WHERE name = UNHEX(&#39;726f6f74&#39;);\r\n\r\nHex is the perfect escape. No way to inject.\r\n\r\n## Difference between UNHEX function and 0x prefix\r\n\r\nThere was some discussion in comments, so I finally want to make it clear. These two approaches are very similar, but they are a little different in some ways:\r\n\r\nThe `0x` prefix can only be used for data columns such as `char`, `varchar`, `text`, `block`, `binary`, etc.  \r\nAlso, its use is a little complicated if you are about to insert an empty string. You&#39;ll have to entirely replace it with `&#39;&#39;`, or you&#39;ll get an error.\r\n\r\n`UNHEX()` works on **any** column; you do not have to worry about the empty string.\r\n\r\n---\r\n\r\n## Hex methods are often used as attacks\r\n\r\nNote that this hex method is often used as an SQL injection attack where integers are just like strings and escaped just with `mysql_real_escape_string`. Then you can avoid the use of quotes.\r\n\r\nFor example, if you just do something like this:\r\n\r\n    &quot;SELECT title FROM article WHERE id = &quot; . mysql_real_escape_string($_GET[&quot;id&quot;])\r\n\r\nan attack can inject you very *easily*. Consider the following injected code returned from your script:\r\n\r\n    SELECT ... WHERE id = -1 UNION ALL SELECT table_name FROM information_schema.tables;\r\n\r\nand now just extract table structure:\r\n\r\n    SELECT ... WHERE id = -1 UNION ALL SELECT column_name FROM information_schema.column WHERE table_name = __0x61727469636c65__;\r\n\r\nAnd then just select whatever data ones want. Isn&#39;t it cool?\r\n\r\nBut if the coder of an injectable site would hex it, no injection would be possible because the query would look like this:\r\n\r\n    SELECT ... WHERE id = UNHEX(&#39;2d312075...3635&#39;);\r\n\r\n  [1]: http://dev.mysql.com/doc/refman/5.0/en/mysql-hex-string.html\r\n  [2]: http://www.php.net/manual/en/function.bin2hex.php\r\n",
        "code_snippets": [],
        "author": {
          "display_name": "user823738",
          "reputation": 17551,
          "profile_link": "https://stackoverflow.com/users/823738/user823738"
        }
      },
      {
        "answer_id": 6381189,
        "is_accepted": false,
        "score": 519,
        "creation_date": "2011-06-17T00:00:21",
        "body_markdown": "&gt;**Deprecated Warning:**\r\nThis answer&#39;s sample code (like the question&#39;s sample code) uses PHP&#39;s `MySQL` extension, which was deprecated in PHP 5.5.0 and removed entirely in PHP 7.0.0.\r\n\r\n&gt; **Security Warning**: This answer is not in line with security best practices. [Escaping is inadequate to prevent SQL injection](https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide), use *prepared statements* instead. Use the strategy outlined below at your own risk. (Also, `mysql_real_escape_string()` was removed in PHP 7.)\r\n\r\n&gt; **IMPORTANT**\r\n&gt; \r\n&gt; The best way to prevent SQL Injection is to use **Prepared Statements** *instead of escaping*, as [the accepted answer](https://stackoverflow.com/a/60496/2224584) demonstrates. \r\n&gt; \r\n&gt; There are libraries such as [Aura.Sql](https://github.com/auraphp/Aura.Sql) and [EasyDB](https://github.com/paragonie/easydb) that allow developers to use prepared statements easier. To learn more about why prepared statements are better at [stopping SQL injection](https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide), refer to [this `mysql_real_escape_string()` bypass](https://stackoverflow.com/a/12118602/2224584) and [recently fixed Unicode SQL Injection vulnerabilities in WordPress](https://kraft.im/2015/05/how-emoji-saved-your-sites-hide/).\r\n\r\nInjection prevention - [mysql_real_escape_string()][1]\r\n\r\nPHP has a specially-made function to prevent these attacks. All you need to do is use the mouthful of a function, `mysql_real_escape_string`.\r\n\r\n`mysql_real_escape_string` takes a string that is going to be used in a MySQL query and return the same string with all SQL injection attempts safely escaped. Basically, it will replace those troublesome quotes(&#39;) a user might enter with a MySQL-safe substitute, an escaped quote \\&#39;.\r\n\r\n**NOTE:** you must be connected to the database to use this function!\r\n\r\n// Connect to MySQL\r\n\r\n    $name_bad = &quot;&#39; OR 1&#39;&quot;; \r\n    \r\n    $name_bad = mysql_real_escape_string($name_bad);\r\n    \r\n    $query_bad = &quot;SELECT * FROM customers WHERE username = &#39;$name_bad&#39;&quot;;\r\n    echo &quot;Escaped Bad Injection: &lt;br /&gt;&quot; . $query_bad . &quot;&lt;br /&gt;&quot;;\r\n    \r\n    \r\n    $name_evil = &quot;&#39;; DELETE FROM customers WHERE 1 or username = &#39;&quot;; \r\n    \r\n    $name_evil = mysql_real_escape_string($name_evil);\r\n    \r\n    $query_evil = &quot;SELECT * FROM customers WHERE username = &#39;$name_evil&#39;&quot;;\r\n    echo &quot;Escaped Evil Injection: &lt;br /&gt;&quot; . $query_evil;\r\n\r\nYou can find more details in *[MySQL - SQL Injection Prevention][2]*.\r\n\r\n  [1]: http://php.net/manual/en/function.mysql-real-escape-string.php\r\n  [2]: http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php\r\n",
        "code_snippets": [],
        "author": {
          "display_name": "rahularyansharma",
          "reputation": 10777,
          "profile_link": "https://stackoverflow.com/users/779158/rahularyansharma"
        }
      },
      {
        "answer_id": 60195,
        "is_accepted": false,
        "score": 491,
        "creation_date": "2008-09-12T20:15:53",
        "body_markdown": "&gt; **Security Warning**: This answer is not in line with security best practices. [Escaping is inadequate to prevent SQL injection](https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide), use *prepared statements* instead. Use the strategy outlined below at your own risk.\r\n\r\nYou could do something basic like this:\r\n\r\n    $safe_variable = mysqli_real_escape_string($dbConnection, $_POST[&quot;user-input&quot;]);\r\n    mysqli_query($dbConnection, &quot;INSERT INTO table (column) VALUES (&#39;&quot; . $safe_variable . &quot;&#39;)&quot;);\r\n\r\nThis won&#39;t solve every problem, but it&#39;s a very good stepping stone. I left out obvious items such as checking the variable&#39;s existence, format (numbers, letters, etc.).\r\n",
        "code_snippets": [],
        "author": {
          "display_name": "Tanerax",
          "reputation": 5876,
          "profile_link": "https://stackoverflow.com/users/567/tanerax"
        }
      },
      {
        "answer_id": 348719,
        "is_accepted": false,
        "score": 397,
        "creation_date": "2008-12-08T00:26:35",
        "body_markdown": "Whatever you do end up using, make sure that you check your input hasn&#39;t already been mangled by `magic_quotes` or some other well-meaning rubbish, and if necessary, run it through `stripslashes` or whatever to sanitize it.",
        "code_snippets": [],
        "author": {
          "display_name": "Rob",
          "reputation": 48397,
          "profile_link": "https://stackoverflow.com/users/3542/rob"
        }
      },
      {
        "answer_id": 6565763,
        "is_accepted": false,
        "score": 378,
        "creation_date": "2011-07-03T17:50:15",
        "body_markdown": "&gt;**Deprecated Warning:**\r\nThis answer&#39;s sample code (like the question&#39;s sample code) uses PHP&#39;s `MySQL` extension, which was deprecated in PHP 5.5.0 and removed entirely in PHP 7.0.0.\r\n\r\n&gt; **Security Warning**: This answer is not in line with security best practices. [Escaping is inadequate to prevent SQL injection](https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide), use *prepared statements* instead. Use the strategy outlined below at your own risk. (Also, `mysql_real_escape_string()` was removed in PHP 7.)\r\n\r\nParameterized query AND input validation is the way to go. There are many scenarios under which SQL injection may occur, even though `mysql_real_escape_string()` has been used.\r\n\r\nThose examples are vulnerable to SQL injection:\r\n\r\n\t$offset = isset($_GET[&#39;o&#39;]) ? $_GET[&#39;o&#39;] : 0;\r\n\t$offset = mysql_real_escape_string($offset);\r\n\tRunQuery(&quot;SELECT userid, username FROM sql_injection_test LIMIT $offset, 10&quot;);\r\nor\r\n\r\n\t$order = isset($_GET[&#39;o&#39;]) ? $_GET[&#39;o&#39;] : &#39;userid&#39;;\r\n\t$order = mysql_real_escape_string($order);\r\n\tRunQuery(&quot;SELECT userid, username FROM sql_injection_test ORDER BY `$order`&quot;);\r\n\r\nIn both cases, you can&#39;t use `&#39;` to protect the encapsulation.\r\n\r\n[Source][1]: *The Unexpected SQL Injection (When Escaping Is Not Enough)*\r\n\r\n  [1]: http://www.webappsec.org/projects/articles/091007.txt\r\n",
        "code_snippets": [],
        "author": {
          "display_name": "Cedric",
          "reputation": 3074,
          "profile_link": "https://stackoverflow.com/users/154607/cedric"
        }
      },
      {
        "answer_id": 11308776,
        "is_accepted": false,
        "score": 323,
        "creation_date": "2012-07-03T06:14:50",
        "body_markdown": "In my opinion, the best way to generally prevent SQL injection in your PHP application (or any web application, for that matter) is to think about your application&#39;s architecture. If the only way to protect against SQL injection is to remember to use a special method or function that does The Right Thing every time you talk to the database, you are doing it wrong. That way, it&#39;s just a matter of time until you forget to correctly format your query at some point in your code.\r\n\r\nAdopting the MVC pattern and a framework like [CakePHP][1] or [CodeIgniter][2] is probably the right way to go: Common tasks like creating secure database queries have been solved and centrally implemented in such frameworks. They help you to organize your web application in a sensible way and make you think more about loading and saving objects than about securely constructing single SQL queries. \r\n\r\n  [1]: http://cakephp.org/\r\n  [2]: http://codeigniter.com/\r\n",
        "code_snippets": [],
        "author": {
          "display_name": "Johannes Fahrenkrug",
          "reputation": 44926,
          "profile_link": "https://stackoverflow.com/users/171933/johannes-fahrenkrug"
        }
      },
      {
        "answer_id": 11610605,
        "is_accepted": false,
        "score": 314,
        "creation_date": "2012-07-23T06:19:50",
        "body_markdown": "There are many ways of preventing SQL injections and other SQL hacks. You can easily find it on the Internet (Google Search). Of course **PDO is one of the good solutions.** But I would like to suggest you some good links prevention from SQL injection.\r\n\r\n*[What is SQL injection and how to prevent][1]*\r\n\r\n*[PHP manual for SQL injection][2]*\r\n\r\n*[Microsoft explanation of SQL injection and prevention in PHP][3]*\r\n\r\nAnd some other like *[Preventing SQL injection with MySQL and PHP][4]*.\r\n\r\nNow, **why you do you need to prevent your query from SQL injection?**\r\n\r\nI would like to let you know: Why do we try for preventing SQL injection with a short example below:\r\n\r\nQuery for login authentication match:\r\n\r\n    $query=&quot;select * from users where email=&#39;&quot;.$_POST[&#39;email&#39;].&quot;&#39; and password=&#39;&quot;.$_POST[&#39;password&#39;].&quot;&#39; &quot;;\r\n\r\nNow, if someone (a hacker) puts\r\n\r\n    $_POST[&#39;email&#39;]= admin@emali.com&#39; OR &#39;1=1\r\nand password anything....\r\n\r\nThe query will be parsed into the system only up to:\r\n\r\n    $query=&quot;select * from users where email=&#39;admin@emali.com&#39; OR &#39;1=1&#39;;\r\n\r\nThe other part will be discarded. So, what will happen? A non-authorized user (hacker) will be able to log in as administrator without having his/her password. Now, he/she can do anything that the administrator/email person can do. See, it&#39;s very dangerous if SQL injection is not prevented.\r\n\r\n  [1]: http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php\r\n  [2]: https://php.net/manual/en/security.database.sql-injection.php\r\n  [3]: https://learn.microsoft.com/en-gb/archive/blogs/brian_swan/whats-the-right-way-to-prevent-sql-injection-in-php-scripts\r\n  [4]: https://web.archive.org/web/20190221025712/http://www.digifuzz.net/archives/2007/07/preventing-sql-injection-with-php/\r\n",
        "code_snippets": [],
        "author": {
          "display_name": "Manish Shrivastava",
          "reputation": 32098,
          "profile_link": "https://stackoverflow.com/users/1133932/manish-shrivastava"
        }
      },
      {
        "answer_id": 1669109,
        "is_accepted": false,
        "score": 313,
        "creation_date": "2009-11-03T13:05:20",
        "body_markdown": "I favor [stored procedures][1] ([MySQL has had stored procedures support since 5.0][2]) from a security point of view - the advantages are -\r\n\r\n   1. Most databases (including [MySQL][3]) enable user access to be restricted to executing stored procedures. The fine-grained security access control is useful to prevent escalation of privileges attacks. This prevents compromised applications from being able to run SQL directly against the database.\r\n   2. They abstract the raw SQL query from the application so less information of the database structure is available to the application. This makes it harder for people to understand the underlying structure of the database and design suitable attacks.\r\n   3. They accept only parameters, so the advantages of parameterized queries are there. Of course - IMO you still need to sanitize your input - especially if you are using dynamic SQL inside the stored procedure.\r\n\r\nThe disadvantages are -\r\n\r\n   1. They (stored procedures) are tough to maintain and tend to multiply very quickly. This makes managing them an issue.\r\n   2. They are not very suitable for dynamic queries - if they are built to accept dynamic code as parameters then a lot of the advantages are negated.\r\n\r\n  [1]: http://en.wikipedia.org/wiki/Stored_procedure\r\n  [2]: http://dev.mysql.com/doc/refman/5.1/en/stored-routines-syntax.html\r\n  [3]: http://dev.mysql.com/doc/refman/5.1/en/stored-routines-privileges.html\r\n",
        "code_snippets": [],
        "author": {
          "display_name": "Nikhil",
          "reputation": 3590,
          "profile_link": "https://stackoverflow.com/users/14944/nikhil"
        }
      }
    ]
  },
  {
    "url": "https://stackoverflow.com/questions/2283937/how-should-i-ethically-approach-user-password-storage-for-later-plaintext-retrie",
    "title": "How should I ethically approach user password storage for later plaintext retrieval?",
    "question_id": 2283937,
    "posted_date": "2010-02-17T14:54:40",
    "answers": [
      {
        "answer_id": 2350498,
        "is_accepted": true,
        "score": 1034,
        "creation_date": "2010-02-28T03:16:51",
        "body_markdown": "How about taking another approach or angle at this problem?  Ask why the password is required to be in plaintext:  if it&#39;s so that the user can retrieve the password, then strictly speaking you don&#39;t really need to retrieve the password they set (they don&#39;t remember what it is anyway), you need to be able to give them a password they *can use*.\r\n\r\nThink about it:  if the user needs to retrieve the password, it&#39;s because they&#39;ve forgotten it. In which case a new password is just as good as the old one. But, one of the drawbacks of common password reset mechanisms used today is that the generated passwords produced in a reset operation are generally a bunch of random characters, so they&#39;re difficult for the user to simply type in correctly unless they copy-n-paste. That can be a problem for less savvy computer users.\r\n\r\nOne way around that problem is to provide auto-generated passwords that are more or less natural language text.  While natural language strings might not have the entropy that a string of random characters of the same length has, there&#39;s nothing that says your auto-generated password needs to have only 8 (or 10 or 12) characters.  Get a high-entropy auto-generated passphrase by stringing together several random words (leave a space between them, so they&#39;re still recognizable and typeable by anyone who can read). Six random words of varying length are probably easier to type correctly and with confidence than 10 random characters, and they can have a higher entropy as well.  For example, the entropy of a 10 character password drawn randomly from uppercase, lowercase, digits and 10 punctuation symbols (for a total of 72 valid symbols) would have an entropy of 61.7 bits.  Using a dictionary of 7776 words (as Diceware uses) which could be randomly selected for a six word passphrase, the passphrase would have an entropy of 77.4 bits. See the [Diceware FAQ][1] for more info.\r\n\r\n  - a passphrase with about 77 bits of entropy: &quot;admit prose flare table acute flair&quot;\r\n\r\n  - a password with about 74 bits of entropy:   &quot;K:&amp;$R^tt~qkD&quot;\r\n\r\nI know I&#39;d prefer typing the phrase, and with copy-n-paste, the phrase is no less easy to use that the password either, so no loss there. Of course if your website (or whatever the protected asset is) doesn&#39;t need 77 bits of entropy for an auto-generated passphrase, generate fewer words (which I&#39;m sure your users would appreciate).\r\n\r\nI understand the arguments that there are password protected assets that really don&#39;t have a high level of value, so the breach of a password might not be the end of the world. For example, I probably wouldn&#39;t care if 80% of the passwords I use on various websites was breached:  all that could happen is a someone spamming or posting under my name for a while.  That wouldn&#39;t be great, but it&#39;s not like they&#39;d be breaking into my bank account. However, given the fact that many people use the same password for their web forum sites as they do for their bank accounts (and probably national security databases), I think it would be best to handle even those &#39;low-value&#39; passwords as non-recoverable.\r\n\r\n\r\n  [1]: http://world.std.com/~reinhold/dicewarefaq.html#calculatingentropy",
        "code_snippets": [],
        "author": {
          "display_name": "Michael Burr",
          "reputation": 340731,
          "profile_link": "https://stackoverflow.com/users/12711/michael-burr"
        }
      },
      {
        "answer_id": 2290037,
        "is_accepted": false,
        "score": 587,
        "creation_date": "2010-02-18T11:05:01",
        "body_markdown": "Imagine someone has commissioned a large building to be built - a bar, let&#39;s say - and the following conversation takes place:\r\n\r\n**Architect:** *For a building of this size and capacity, you will need fire exits here, here, and here.*  \r\n**Client:** *No, that&#39;s too complicated and expensive to maintain, I don&#39;t want any side doors or back doors.*  \r\n**Architect:** *Sir, fire exits are not optional, they are required as per the city&#39;s fire code.*  \r\n**Client:** *I&#39;m not paying you to argue.  Just do what I asked.*\r\n\r\nDoes the architect then ask how to ethically build this building without fire exits?\r\n\r\nIn the building and engineering industry, the conversation is most likely to end like this:\r\n\r\n**Architect:** *This building cannot be built without fire exits.  You can go to any other licensed professional and he will tell you the same thing. I&#39;m leaving now; call me back when you are ready to cooperate.*\r\n\r\nComputer programming may not be a *licensed* profession, but people often seem to wonder why our profession doesn&#39;t get the same respect as a civil or mechanical engineer - well, look no further.  Those professions, when handed garbage (or outright dangerous) requirements, will simply refuse.  They know it is not an excuse to say, &quot;well, I did my best, but he insisted, and I&#39;ve gotta do what he says.&quot;  They could lose their license for that excuse.\r\n\r\nI don&#39;t know whether or not you or your clients are part of any publicly-traded company, but storing passwords in any recoverable form would cause you to to fail several different types of security audits.  The issue is not how difficult it would be for some &quot;hacker&quot; who got access to your database to recover the passwords.  **The vast majority of security threats are internal.**  What you need to protect against is some disgruntled employee walking off with all the passwords and selling them to the highest bidder.  Using asymmetrical encryption and storing the private key in a separate database does absolutely nothing to prevent this scenario; there&#39;s always going to be *someone* with access to the private database, and that&#39;s a serious security risk.\r\n\r\n**There is no ethical or responsible way to store passwords in a recoverable form.  Period.**",
        "code_snippets": [],
        "author": {
          "display_name": "Aaronaught",
          "reputation": 122704,
          "profile_link": "https://stackoverflow.com/users/38360/aaronaught"
        }
      }
    ]
  },
  {
    "url": "https://stackoverflow.com/questions/129677/how-can-i-sanitize-user-input-with-php",
    "title": "How can I sanitize user input with PHP?",
    "question_id": 129677,
    "posted_date": "2008-09-24T16:20:39",
    "answers": [
      {
        "answer_id": 130323,
        "is_accepted": true,
        "score": 1317,
        "creation_date": "2008-09-24T18:30:37",
        "body_markdown": "It&#39;s a common misconception that user input can be filtered. PHP even had a (now defunct) &quot;feature&quot;, called [magic-quotes][1], that builds on this idea. It&#39;s nonsense. Forget about filtering (or cleaning, or whatever people call it).\r\n\r\nWhat you should do, to avoid problems, is quite simple: whenever you embed a piece of data within a foreign code, you must format it according to the rules of that code. But you must understand that such rules could be too complicated to try to follow them all manually. For example, in SQL, rules for strings, numbers and identifiers are all different. For your convenience, in most cases there is a dedicated tool for such embedding. For example, when some data has to be used in the SQL query, instead of adding a variable directly to SQL string, it has to be done though a parameter in the query, using prepared statement. And it will take care of all the proper formatting.\r\n\r\nAnother example is HTML: If you embed strings within HTML markup, you must escape it with [`htmlspecialchars`][2]. This means that every single `echo` or `print` statement should use `htmlspecialchars`.\r\n\r\nA third example could be shell commands: If you are going to embed strings (such as arguments) to external commands, and call them with [`exec`][3], then you must use [`escapeshellcmd`][4] and [`escapeshellarg`][5].\r\n\r\nAlso, a very compelling example is JSON. The rules are so numerous and complicated that you would never be able to follow them all manually. That&#39;s why you should never ever create a JSON string manually, but always use a dedicated function, [`json_encode()`][6] that will correctly format every bit of data. \r\n\r\nAnd so on and so forth ...\r\n\r\nThe *only* case where you need to actively filter data, is if you&#39;re accepting preformatted input. For example, if you let your users post HTML markup, that you plan to display on the site. However, you should be wise to avoid this at all cost, since no matter how well you filter it, it will always be a potential security hole.\r\n\r\n\r\n  [1]: https://en.wikipedia.org/wiki/Magic_quotes\r\n  [2]: http://php.net/manual/function.htmlspecialchars.php\r\n  [3]: http://php.net/manual/function.exec.php\r\n  [4]: http://php.net/manual/function.escapeshellcmd.php\r\n  [5]: http://php.net/manual/function.escapeshellarg.php\r\n  [6]: https://www.php.net/json_encode",
        "code_snippets": [],
        "author": {
          "display_name": "troelskn",
          "reputation": 117633,
          "profile_link": "https://stackoverflow.com/users/18180/troelskn"
        }
      }
    ]
  },
  {
    "url": "https://stackoverflow.com/questions/401656/secure-hash-and-salt-for-php-passwords",
    "title": "Secure hash and salt for PHP passwords",
    "question_id": 401656,
    "posted_date": "2008-12-30T17:02:45",
    "answers": [
      {
        "answer_id": 401684,
        "is_accepted": true,
        "score": 1031,
        "creation_date": "2008-12-30T17:15:09",
        "body_markdown": "&gt; **DISCLAIMER**: This answer was written in 2008.\r\n&gt;\r\n&gt; Since then, PHP has given us [`password_hash`](http://php.net/manual/en/function.password-hash.php) and [`password_verify`](http://php.net/manual/en/function.password-verify.php) and, since their introduction, they are the recommended password hashing &amp; checking method.\r\n&gt;\r\n&gt; The theory of the answer is still a good read though.\r\n\r\nTL;DR\r\n-----\r\n\r\n### Don&#39;ts\r\n\r\n - Don&#39;t limit what characters users can enter for passwords. Only idiots do this.\r\n - Don&#39;t limit the length of a password. If your users want a sentence with supercalifragilisticexpialidocious in it, don&#39;t prevent them from using it.\r\n - Don&#39;t strip or escape HTML and special characters in the password.\r\n - Never store your user&#39;s password in plain-text.\r\n - Never email a password to your user *except when they have lost theirs, and you sent a temporary one.*\r\n - Never, ever log passwords in any manner.\r\n - Never hash passwords with [SHA1] or MD5 or even SHA256! [Modern crackers] can exceed 60 and 180 billion hashes/second (respectively).\r\n - Don&#39;t mix [bcrypt and with the *raw* output of hash()][bcrypt-security], either use hex output or base64_encode it. (This applies to any input that may have a rogue `\\0` in it, which can seriously weaken security.)\r\n\r\n  [bcrypt-security]: http://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html\r\n\r\n### Dos\r\n\r\n - Use scrypt when you can; bcrypt if you cannot.\r\n - Use PBKDF2 if you cannot use either bcrypt or scrypt, with SHA2 hashes.\r\n - Reset everyone&#39;s passwords when the database is compromised.\r\n - Implement a reasonable 8-10 character minimum length, plus require at least 1 upper case letter, 1 lower case letter, a number, and a symbol. This will improve the entropy of the password, in turn making it harder to crack. (See the &quot;What makes a good password?&quot; section for some debate.)\r\n\r\n  [modern crackers]: http://securityledger.com/new-25-gpu-monster-devours-passwords-in-seconds/\r\n  [SHA1]: http://arstechnica.com/security/2012/12/oh-great-new-attack-makes-some-password-cracking-faster-easier-than-ever/\r\n\r\nWhy hash passwords anyway?\r\n--------------------------\r\n\r\nThe objective behind hashing passwords is simple: preventing malicious access to user accounts by compromising the database. So the goal of password hashing is to deter a hacker or cracker by costing them too much time or money to calculate the plain-text passwords. And time/cost are the best deterrents in your arsenal.\r\n\r\nAnother reason that you want a good, robust hash on a user accounts is to give you enough time to change all the passwords in the system. If your database is compromised you will need enough time to at *least* lock the system down, if not change every password in the database.\r\n\r\nJeremiah Grossman, CTO of Whitehat Security, [stated on White Hat Security blog](https://www.whitehatsec.com/blog/cracking-aes-256-dmgs-and-epic-self-pwnage/) after a recent password recovery that required brute-force breaking of his password protection:\r\n\r\n&gt; Interestingly, in living out this nightmare, I learned A LOT I didnâ€™t know about password cracking, storage, and complexity. *Iâ€™ve come to appreciate why password storage is ever so much more important than password complexity. If you donâ€™t know how your password is stored, then all you really can depend upon is complexity.* This might be common knowledge to password and crypto pros, but for the average InfoSec or Web Security expert, I highly doubt it.\r\n\r\n(Emphasis mine.)\r\n\r\nWhat makes a *good* password anyway?\r\n------------------------------------\r\n\r\n[Entropy]. (Not that I fully subscribe to Randall&#39;s viewpoint.)\r\n\r\nIn short, entropy is how much variation is within the password. When a password is only lowercase roman letters, that&#39;s only 26 characters. That isn&#39;t much variation. Alpha-numeric passwords are better, with 36 characters. But allowing upper and lower case, with symbols, is roughly 96 characters. That&#39;s a lot better than just letters. One problem is, to make our passwords memorable we insert patternsâ€”which reduces entropy. Oops!\r\n\r\nPassword entropy is [approximated][entropy-calc] easily. Using the full range of ascii characters (roughly 96 typeable characters) yields an entropy of 6.6 per character, which at 8 characters for a password is still too low (52.679 bits of entropy) for future security. But the good news is: longer passwords, and passwords with unicode characters, really increase the entropy of a password and make it harder to crack.\r\n\r\nThere&#39;s a longer discussion of password entropy on the [Crypto StackExchange][entropy2] site. A good Google search will also turn up a lot of results.\r\n\r\nIn the comments I talked with @popnoodles, who pointed out that *enforcing* a password policy of X length with X many letters, numbers, symbols, etc, can actually reduce entropy by making the password scheme more predictable. I do agree. Randomess, as truly random as possible, is always the safest but least memorable solution.\r\n\r\nSo far as I&#39;ve been able to tell, making the world&#39;s best password is a Catch-22. Either its not memorable, too predictable, too short, too many unicode characters (hard to type on a Windows/Mobile device), too long, etc. No password is truly good enough for our purposes, so we must protect them as though they were in Fort Knox.\r\n\r\n  [entropy]: http://xkcd.com/936/\r\n  [entropy2]: https://crypto.stackexchange.com/questions/374/how-should-i-calculate-the-entropy-of-a-password\r\n  [entropy-calc]: https://ritcyberselfdefense.wordpress.com/2011/09/24/how-to-calculate-password-entropy/\r\n\r\nBest practices\r\n--------------\r\n\r\nBcrypt and [scrypt][1] are the current best practices. [Scrypt][1] will be better than bcrypt in time, but it hasn&#39;t seen adoption as a standard by Linux/Unix or by webservers, and hasn&#39;t had in-depth reviews of its algorithm posted yet. But still, the future of the algorithm does look promising. If you are working with Ruby there is an [scrypt gem][2] that will help you out, and Node.js now has its own [scrypt][node-scrypt] package. You can use Scrypt in PHP either via the [Scrypt](https://pecl.php.net/package/scrypt) extension or the [Libsodium](https://paragonie.com/book/pecl-libsodium/read/07-password-hashing.md) extension (both are available in PECL).\r\n\r\nI highly suggest reading the documentation for the [crypt function][3] if you want to understand how to use bcrypt, or finding yourself a [good][4] [wrapper][5] or use something like [PHPASS][6] for a more legacy implementation. I recommend a minimum of 12 rounds of bcrypt, if not 15 to 18.\r\n\r\nI changed my mind about using bcrypt when I learned that bcrypt only uses blowfish&#39;s key schedule, with a variable cost mechanism. The latter lets you increase the cost to brute-force a password by increasing blowfish&#39;s already expensive key schedule.\r\n\r\n  [1]:http://www.tarsnap.com/scrypt.html\r\n  [2]:http://rubygems.org/gems/scrypt\r\n  [3]:http://us.php.net/crypt\r\n  [4]:https://stackoverflow.com/questions/4795385/how-do-you-use-bcrypt-for-hashing-passwords-in-php/6337021#6337021\r\n  [5]:https://gist.github.com/1070401\r\n  [6]:http://www.openwall.com/phpass/\r\n  [node-scrypt]: https://npmjs.org/package/scrypt\r\n\r\nAverage practices\r\n-----------------\r\n\r\nI almost can&#39;t imagine this situation anymore. [PHPASS][6] supports PHP 3.0.18 through 5.3, so it is usable on almost every installation imaginableâ€”and should be used if you don&#39;t *know for certain* that your environment supports bcrypt.\r\n\r\nBut suppose that you cannot use bcrypt or PHPASS at all. What then?\r\n\r\nTry an implementation of [PDKBF2][7] with the [maximum number of rounds][8] that your environment/application/user-perception can tolerate. The lowest number I&#39;d recommend is 2500 rounds. Also, make sure to use [hash_hmac()][hash_hmac] if it is available to make the operation harder to reproduce.\r\n\r\n  [7]:http://www.itnewb.com/tutorial/Encrypting-Passwords-with-PHP-for-Storage-Using-the-RSA-PBKDF2-Standard\r\n  [8]:https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pkbdf2-sha256\r\n  [hash_hmac]: http://php.net/hash_hmac\r\n\r\nFuture Practices\r\n----------------\r\n\r\nComing in PHP 5.5 is a [full password protection library][php55] that abstracts away any pains of working with bcrypt. While most of us are stuck with PHP 5.2 and 5.3 in most common environments, especially shared hosts, @ircmaxell has built a [compatibility layer][ircmaxell] for the coming API that is backward compatible to PHP 5.3.7.\r\n\r\n  [php55]: http://php.net/manual/en/ref.password.php\r\n  [ircmaxell]: https://github.com/ircmaxell/password_compat\r\n\r\nCryptography Recap &amp; Disclaimer\r\n-------------------------------\r\n\r\nThe computational power required to actually *crack* a hashed password doesn&#39;t exist. The only way for computers to &quot;crack&quot; a password is to recreate it and simulate the hashing algorithm used to secure it. The speed of the hash is linearly related to its ability to be brute-forced. Worse still, most hash algorithms can be easily parallelized to perform even faster. This is why costly schemes like bcrypt and scrypt are so important.\r\n\r\nYou cannot possibly foresee all threats or avenues of attack, and so you must make your best effort to protect your users **up front**. If you do not, then you might even miss the fact that you were attacked until it&#39;s too late... *and you&#39;re liable*. To avoid that situation, act paranoid to begin with. Attack your own software (internally) and attempt to steal user credentials, or modify other user&#39;s accounts or access their data. If you don&#39;t test the security of your system, then you cannot blame anyone but yourself.\r\n\r\nLastly: I am not a cryptographer. Whatever I&#39;ve said is my opinion, but I happen to think it&#39;s based on good ol&#39; common sense ... and lots of reading. Remember, be as paranoid as possible, make things as hard to intrude as possible, and then, if you are still worried, contact a white-hat hacker or cryptographer to see what they say about your code/system.",
        "code_snippets": [],
        "author": {
          "display_name": "Robert K",
          "reputation": 30338,
          "profile_link": "https://stackoverflow.com/users/24950/robert-k"
        }
      }
    ]
  },
  {
    "url": "https://stackoverflow.com/questions/332365/how-does-the-sql-injection-from-the-bobby-tables-xkcd-comic-work",
    "title": "How does the SQL injection from the &quot;Bobby Tables&quot; XKCD comic work?",
    "question_id": 332365,
    "posted_date": "2008-12-01T16:50:10",
    "answers": [
      {
        "answer_id": 332367,
        "is_accepted": true,
        "score": 1206,
        "creation_date": "2008-12-01T16:50:58",
        "body_markdown": "**It drops the students table.**\r\n\r\nThe original code in the school&#39;s program probably looks something like\r\n\r\n    q = &quot;INSERT INTO Students VALUES (&#39;&quot; + FNMName.Text + &quot;&#39;, &#39;&quot; + LName.Text + &quot;&#39;)&quot;;\r\n\r\nThis is the naive way to add text input into a query, and is *very bad*, as you will see.\r\n\r\nAfter the values from the first name, middle name textbox *FNMName.Text* (which is `Robert&#39;); DROP TABLE STUDENTS; --`) and the last name textbox *LName.Text* (let&#39;s call it `Derper`) are concatenated with the rest of the query, the result is now actually *two queries* separated by the [statement terminator][1] (semicolon).  The second query has been **injected** into the first.  When the code executes this query against the database, it will look like this\r\n\r\n    INSERT INTO Students VALUES (&#39;Robert&#39;); DROP TABLE Students; --&#39;, &#39;Derper&#39;)\r\n\r\nwhich, in plain English, roughly translates to the two queries:\r\n\r\n&gt; Add a new record to the Students table with a Name value of &#39;Robert&#39;\r\n\r\nand\r\n\r\n&gt; Delete the Students table\r\n\r\nEverything past the second query is [marked as a comment][2]:  `--&#39;, &#39;Derper&#39;)`\r\n\r\nThe `&#39;` in the student&#39;s name is not a comment, it&#39;s the closing [string delimiter][3].  Since the student&#39;s name is a string, it&#39;s needed syntactically to complete the hypothetical query.  Injection attacks only work *when the SQL query they inject results in valid SQL*.\r\n\r\n&lt;sup&gt;&lt;sup&gt;Edited ***again*** as per [dan04](https://stackoverflow.com/users/287586/dan04)&#39;s astute comment&lt;/sup&gt;&lt;/sup&gt;\r\n\r\n\r\n  [1]: http://en.wikipedia.org/wiki/SQL#Language_elements\r\n  [2]: http://msdn.microsoft.com/en-us/library/ms181627.aspx\r\n  [3]: http://msdn.microsoft.com/en-us/library/ms179899.aspx",
        "code_snippets": [],
        "author": {
          "display_name": "user1228",
          "reputation": 0,
          "profile_link": ""
        }
      },
      {
        "answer_id": 332380,
        "is_accepted": false,
        "score": 676,
        "creation_date": "2008-12-01T16:55:08",
        "body_markdown": "Let&#39;s say the name was used in a variable, `$Name`.  You then run this query:\r\n\r\n    INSERT INTO Students VALUES ( &#39;$Name&#39; )\r\n\r\nThe code is mistakenly placing anything the user supplied as the variable. You wanted the SQL to be:\r\n\r\n&gt; INSERT INTO Students VALUES ( &#39;&lt;kbd&gt;Robert Tables&lt;/kbd&gt;` )\r\n\r\nBut a clever user can supply whatever they want:\r\n\r\n&gt; INSERT INTO Students VALUES ( &#39;&lt;kbd&gt;Robert&#39;); DROP TABLE Students; --&lt;/kbd&gt;&#39; ) \r\n\r\nWhat you get is:\r\n\r\n    INSERT INTO Students VALUES ( &#39;Robert&#39; );  DROP TABLE STUDENTS; --&#39; )\r\n\r\nThe `--` only comments the remainder of the line.\r\n",
        "code_snippets": [],
        "author": {
          "display_name": "sinoth",
          "reputation": 7712,
          "profile_link": "https://stackoverflow.com/users/42224/sinoth"
        }
      }
    ]
  },
  {
    "url": "https://stackoverflow.com/questions/25098021/securityerror-blocked-a-frame-with-origin-from-accessing-a-cross-origin-frame",
    "title": "SecurityError: Blocked a frame with origin from accessing a cross-origin frame",
    "question_id": 25098021,
    "posted_date": "2014-08-02T14:14:39",
    "answers": [
      {
        "answer_id": 25098153,
        "is_accepted": true,
        "score": 1196,
        "creation_date": "2014-08-02T14:28:50",
        "body_markdown": "Same-origin policy\r\n------------------\r\n\r\nYou **can&#39;t** access an `&lt;iframe&gt;` with different origin using JavaScript, it would be a huge security flaw if you could do it. For the [same-origin policy][1] **browsers block scripts trying to access a frame with a different origin**.\r\n\r\nOrigin is considered different if at least one of the following parts of the address isn&#39;t maintained:\r\n\r\n&lt;pre&gt;&lt;b&gt;protocol&lt;/b&gt;://&lt;b&gt;hostname&lt;/b&gt;:&lt;b&gt;port&lt;/b&gt;/...&lt;/pre&gt;\r\n\r\nProtocol, hostname and port must be the same of your domain if you want to access a frame.\r\n\r\n&lt;sup&gt;NOTE: though mostly unused nowadays, Internet Explorer is known to not strictly follow this rule, see [here][2] for details.&lt;/sup&gt;\r\n\r\n### Examples\r\n\r\nHere&#39;s what would happen trying to access the following URLs from `http://www.example.com/home/index.html`\r\n\r\n```none\r\nURL                                             RESULT\r\nhttp://www.example.com/home/other.html       -&gt; Success\r\nhttp://www.example.com/dir/inner/another.php -&gt; Success\r\nhttp://www.example.com:80                    -&gt; Success (default port for HTTP)\r\nhttp://www.example.com:2251                  -&gt; Failure: different port\r\nhttp://data.example.com/dir/other.html       -&gt; Failure: different hostname\r\nhttps://www.example.com/home/index.html:80   -&gt; Failure: different protocol\r\nftp://www.example.com:21                     -&gt; Failure: different protocol &amp; port\r\nhttps://google.com/search?q=james+bond       -&gt; Failure: different protocol, port &amp; hostname\r\n```\r\n\r\nWorkaround\r\n----------\r\n\r\nEven though same-origin policy blocks scripts from accessing the content of sites with a different origin, **if you own both the pages, you can work around this problem using [`window.postMessage`][3] and its relative `message` event** to send messages between the two pages, like this:\r\n\r\n- In your main page:\r\n\r\n      const frame = document.getElementById(&#39;your-frame-id&#39;);\r\n      frame.contentWindow.postMessage(/*any variable or object here*/, &#39;https://your-second-site.example&#39;);\r\n\r\n   The second argument to `postMessage()` can be `&#39;*&#39;` to indicate no preference about the origin of the destination. A target origin should always be provided when possible, to avoid disclosing the data you send to any other site.\r\n\r\n- In your `&lt;iframe&gt;` (contained in the main page):\r\n\r\n      window.addEventListener(&#39;message&#39;, event =&gt; {\r\n          // IMPORTANT: check the origin of the data!\r\n          if (event.origin === &#39;https://your-first-site.example&#39;) {\r\n              // The data was sent from your site.\r\n              // Data sent with postMessage is stored in event.data:\r\n              console.log(event.data);\r\n          } else {\r\n              // The data was NOT sent from your site!\r\n              // Be careful! Do not use it. This else branch is\r\n              // here just for clarity, you usually shouldn&#39;t need it.\r\n              return;\r\n          }\r\n      });\r\n\r\nThis method can be applied in **both directions**, creating a listener in the main page too, and receiving responses from the frame. The same logic can also be implemented in pop-ups and basically any new window generated by the main page (e.g. using [`window.open()`][4]) as well, without any difference.\r\n\r\nDisabling same-origin policy in *your* browser\r\n----------------------------------------------\r\n\r\nThere already are some good answers about this topic (I just found them googling), so, for the browsers where this is possible, I&#39;ll link the relative answer. However, please remember that **disabling the same-origin policy will only affect *your* browser**. Also, running a browser with same-origin security settings disabled grants *any* website access to cross-origin resources, so **it&#39;s very unsafe and should NEVER be done if you do not know exactly what you are doing (e.g. development purposes)**.\r\n\r\n - [Google Chrome][5]\r\n - [Mozilla Firefox][6]\r\n - [Safari][7]\r\n - [Opera][8]: same as Chrome\r\n - Microsoft Edge: same as Chrome\r\n - Brave: same as Chrome\r\n - Microsoft Edge (old non-Chromium version): [not possible][9]\r\n - [Microsoft Internet Explorer][10]\r\n\r\n  [1]: https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\r\n  [2]: https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#Exceptions_in_Internet_Explorer\r\n  [3]: https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\r\n  [4]: https://developer.mozilla.org/en-US/docs/Web/API/Window/open\r\n  [5]: https://stackoverflow.com/q/3102819/3889449\r\n  [6]: https://stackoverflow.com/q/17088609/3889449\r\n  [7]: https://stackoverflow.com/q/4556429/3889449\r\n  [8]: https://stackoverflow.com/q/7543678/3889449\r\n  [9]: https://superuser.com/q/1020612/591004\r\n  [10]: https://stackoverflow.com/q/20947359/3889449",
        "code_snippets": [
          "none\r\nURL                                             RESULT\r\nhttp://www.example.com/home/other.html       -&gt; Success\r\nhttp://www.example.com/dir/inner/another.php -&gt; Success\r\nhttp://www.example.com:80                    -&gt; Success (default port for HTTP)\r\nhttp://www.example.com:2251                  -&gt; Failure: different port\r\nhttp://data.example.com/dir/other.html       -&gt; Failure: different hostname\r\nhttps://www.example.com/home/index.html:80   -&gt; Failure: different protocol\r\nftp://www.example.com:21                     -&gt; Failure: different protocol &amp; port\r\nhttps://google.com/search?q=james+bond       -&gt; Failure: different protocol, port &amp; hostname"
        ],
        "author": {
          "display_name": "Marco Bonelli",
          "reputation": 69706,
          "profile_link": "https://stackoverflow.com/users/3889449/marco-bonelli"
        }
      }
    ]
  },
  {
    "url": "https://stackoverflow.com/questions/13854425/how-to-avoid-reverse-engineering-of-an-apk-file",
    "title": "How to avoid reverse engineering of an APK file",
    "question_id": 13854425,
    "posted_date": "2012-12-13T01:42:14",
    "answers": [
      {
        "answer_id": 13854693,
        "is_accepted": true,
        "score": 408,
        "creation_date": "2012-12-13T02:03:12",
        "body_markdown": "&gt; &amp;nbsp;1. How can I completely avoid reverse engineering of an Android APK? Is this possible?\r\n\r\nAFAIK, there is not any trick for complete avoidance of reverse engineering.\r\n\r\nAnd also very well said by @inazaruk: *Whatever you do to your code, a potential attacker is able to change it in any way she or he finds it feasible*. You basically can&#39;t protect your application from being modified. And any protection you put in there can be disabled/removed.\r\n\r\n&gt;  &amp;nbsp;2. How can I protect all the app&#39;s resources, assets and source code so that hackers can&#39;t hack the APK file in any way?\r\n\r\nYou can do different tricks to make hacking harder though. For example, use obfuscation (if it&#39;s Java code). This usually slows down reverse engineering significantly.\r\n\r\n&gt;  &amp;nbsp;3. Is there a way to make hacking more tough or even impossible? What more can I do to protect the source code in my APK file?\r\n\r\nAs everyone says, and as you probably know, there&#39;s no 100% security. But the place to start for Android, that Google has built in, is ProGuard. If you have the option of including **shared libraries**, you can include the needed code in C++ to verify file sizes, integration,\r\netc. If you need to add an external native library to your APK&#39;s library folder on every build,\r\nthen you can use it by the below suggestion.\r\n\r\nPut the library in the native library path which defaults to &quot;libs&quot; in\r\nyour project folder. If you built the native code for the **&#39;armeabi&#39;** target then put it\r\nunder **libs/armeabi**. If it was built with **armeabi-v7a** then put it under\r\n**libs/armeabi-v7a.**\r\n\r\n    &lt;project&gt;/libs/armeabi/libstuff.so\r\n",
        "code_snippets": [],
        "author": {
          "display_name": "Bhavesh Patadiya",
          "reputation": 25830,
          "profile_link": "https://stackoverflow.com/users/1228170/bhavesh-patadiya"
        }
      }
    ]
  }
]