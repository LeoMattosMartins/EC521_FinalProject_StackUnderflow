import re
import sys
import os
import subprocess

# Goal of this program is to check for errors within files from Interpreted languages. These languages include Python, Ruby, Go, PHP, etc. 
# The interpreter checker will have instructions given to it so it will know how to check programs for errors within itself. 

def read_file(filename):

    try:
        with open(filename, 'r', encoding='utf-8') as file:
            return file.read()
    except FileNotFoundError:
        print(f"Error: The file '{filename}' was not found!")
        sys.exit(1)

def which_lang(filename):
    # Detects whether the language needs to have a variable declaration (var, let, etc.) during declaration (JS, Java, Go, etc.), or not (Python, Ruby, PHP, etc.)
    if filename.endswith(".py"):
        return False
    elif filename.endswith(".js"):
        return True
    elif filename.endswith(".java"):
        return True
    elif filename.endswith(".go"):
        return True
    elif filename.endswith(".rb"):
        print("Ruby File detected...")
        return False
    elif filename.endswith(".php"):
        print("PHP File detected...")
        return False
    else:
        ext = os.path.splitext(filename)[1]
        print(f"Unknown File Type... Extension was {ext}")
        return None

def eval_detected(code):

    pattern = re.compile(r"eval\((.*?)\)")
    matches = pattern.findall(code)
    if matches:
        return [f"Eval found with contents: {match}" for match in matches]
    else:
        return []

# What if the vulnerability was the friends we lost along the way :( 
def detect_vulnerability(code, needs_dec):

    vulnerabilities = []
    lines = code.split('\n')

    for idx, line in enumerate(lines, start=1):
        trimmed_line = line.strip()
        if not trimmed_line:
            continue

        # Check semicolons if not Python
        if needs_dec and not trimmed_line.endswith(";"):
            vulnerabilities.append(f"Line {idx}: Missing semicolon.") # Only bum programmers miss semicolons.
        elif trimmed_line.endswith(";") and not needs_dec:
            vulnerabilities.append(f"Created semicolon when not needed in line: {idx}")

        # Detect possible array (list) out-of-bounds
        bracket_pattern = re.compile(r"\[(\d+)\]")
        for cap in bracket_pattern.finditer(trimmed_line):
            index = int(cap.group(1))
            # Highly simplified check: if index is bigger than the line length
            if index > len(trimmed_line):
                vulnerabilities.append(f"Line {idx}: Possible out-of-bounds array access.")

    # Print out any vulnerabilities found
    if vulnerabilities:
        print("Potential vulnerabilities found:")
        for v in vulnerabilities:
            print(f"  - {v}")
    else:
        print("No obvious vulnerabilities found.")

def error_check(code, needs_dec):
    errors = []
    declaratory_keywords = ["let", "var", "const"]
    lines = code.split('\n')

    for idx, line in enumerate(lines, start=1):
        stripped_line = line.strip()
        if not stripped_line:
            continue

        # Check for wrong use of "="
        # If "=" is found and no declaratory keyword at the start (for strict languages like JS, Java, Go)
        if "=" in stripped_line:
            if needs_dec:
                if not any(stripped_line.startswith(keyword) for keyword in declaratory_keywords):
                    errors.append(f"Line {idx}: Possible missing variable declaration (let/var/const/etc.) near '='.")
            else:
                if any(stripped_line.startswith(keyword) for keyword in declaratory_keywords):
                    errors.append(f"Line {idx}: Unnecessary declaratory keyword (let/var/const) used.")

        # Check for semicolon issues
        if needs_dec:
            if not stripped_line.endswith(";") and not stripped_line.startswith("//"):  # ignore comment lines
                errors.append(f"Line {idx}: Missing semicolon at the end of statement.")
        else:
            if stripped_line.endswith(";"):
                errors.append(f"Line {idx}: Unnecessary semicolon at end of line.")

    return errors
    
def detect_api_keys(code):

    # Simple regex matching lines containing 'API_KEY', 'SECRET_KEY', or 'PRIVATE_KEY'
    key_pattern = re.compile(r"(API_KEY|SECRET_KEY|PRIVATE_KEY)\s*=\s*[\"']([^\"']+)[\"']", re.IGNORECASE)
    found_keys = key_pattern.findall(code)
    finding_keys = []
    if found_keys:
        for match in found_keys:
            finding_keys.append(f"Hardcoded sensitive information detected: {match[0]} = \"{match[1]}\". ")
    return finding_keys if finding_keys else None

def detect_insecure_mktemp(code):

    found_mktemp = []
    if "mktemp(" in code:
        found_mktemp.append("mktemp() usage detected. Consider using mkstemp() for safer temporary file creation.")
        return found_mktemp
    else:
        return
    
def detect_command_injection(code):

    findings = []
    patterns = [
        (r"os\.system\s*\(", "os.system"),
        (r"subprocess\.(call|Popen|run)\s*\(", "subprocess.call/Popen/run"),
    ]
    for pat, func in patterns:
        if re.search(pat, code):
            findings.append(
                f"Potential Command Injection: use of `{func}` without sanitizing inputs."
            )
    return findings

def detect_path_traversal(code):

    findings = []
    # open(user_input)
    if re.search(r"open\s*\(\s*(input\s*\(|sys\.argv|\w+\.get\()", code):
        findings.append(
            "Potential Path Traversal: `open()` called on user-controlled path."
        )
    # os.path.join(user_input, …)
    if re.search(r"os\.path\.join\s*\([^)]*(input\s*\(|sys\.argv)", code):
        findings.append(
            "Potential Path Traversal: `os.path.join()` used with user-controlled input."
        )
    return findings


def detect_sensitive_info(code):

    findings = []
    for key in ["API_KEY", "SECRET_KEY", "PRIVATE_KEY", "PASSWORD", "TOKEN"]:
        # match e.g. PASSWORD = "hunter2"
        pattern = rf"{key}\s*=\s*['\"]([^'\"]+)['\"]"
        for match in re.findall(pattern, code, re.IGNORECASE):
            findings.append(
                f"Hardcoded sensitive information `{key}` → \"{match}\""
            )
    return findings


def detect_arbitrary_code_execution(code):

    findings = []
    checks = {
        "eval()":       r"eval\s*\(",
        "exec()":       r"exec\s*\(",
        "compile()":    r"compile\s*\(",
        "pickle.loads": r"pickle\.loads\s*\(",
        "marshal.loads":r"marshal\.loads\s*\("
    }
    for name, pat in checks.items():
        if re.search(pat, code):
            findings.append(
                f"Potential Arbitrary Code Execution: use of `{name}`."
            )
    return findings


def detect_resource_leaks(code):

    findings = []
    if "open(" in code:
        if not re.search(r"with\s+open\s*\(", code) and not re.search(r"\.close\s*\(", code):
            findings.append(
                "Potential Resource Leak: `open()` used without `with` or `.close()`."
            )
    return findings


def main():
    if len(sys.argv) < 2:
        print("Usage: python translated_script.py <filename>")
        sys.exit(1)

    filename = sys.argv[1]
    code = read_file(filename)
    needs_dec = which_lang(filename)

    all_issues = []


    all_issues += detect_command_injection(code)
    all_issues += detect_path_traversal(code)
    all_issues += detect_sensitive_info(code)
    all_issues += detect_arbitrary_code_execution(code)
    all_issues += detect_resource_leaks(code)

    if all_issues:
        print("Issues detected:")
        for issue in all_issues:
            print(f"  - {issue}")
    else:
        print("No issues found!")


if __name__ == "__main__":
    main()
